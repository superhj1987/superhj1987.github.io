<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[后端技术杂谈 | 飒然Hang]]></title>
  <link href="http://www.rowkey.me/atom.xml" rel="self"/>
  <link href="http://www.rowkey.me/"/>
  <updated>2018-06-04T16:29:19+08:00</updated>
  <id>http://www.rowkey.me/</id>
  <author>
    <name><![CDATA[飒然Hang]]></name>
    <email><![CDATA[superhj1987@126.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[微服务的十个反模式和陷阱]]></title>
    <link href="http://www.rowkey.me/blog/2018/06/02/microservice-pitfall/"/>
    <updated>2018-06-02T19:29:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2018/06/02/microservice-pitfall</id>
    <content type="html"><![CDATA[<p>O’Reilly的电子书《Microservices AntiPatterns and Pitfalls》讲述了在微服务设计实现时十种最常见的反模式和陷阱。本文基于此书，将这十个点列出。书籍地址：<a href="https://www.oreilly.com/programming/free/microservices-antipatterns-and-pitfalls.csp">https://www.oreilly.com/programming/free/microservices-antipatterns-and-pitfalls.csp</a>，更全的反模式和陷阱可见作者的视频：<a href="http://oreil.ly/29GVuDG">http://oreil.ly/29GVuDG</a></p>

<!--more-->


<h2>数据驱动迁移反模式-Data-Driven Migration</h2>

<p><img src="http://www.rowkey.me/post_images/ms-anti/data-driven-1.png" alt="" /></p>

<p>如上图所示，此种反模式的问题在于微服务的粒度没有最终确定之前就做了数据迁移，如此当不断的调整服务粒度时，那么数据库就免不了频繁迁移，带来极大的成本。更好的方式如下图所示：</p>

<p><img src="http://www.rowkey.me/post_images/ms-anti/data-driven-2.png" alt="" /></p>

<p>即先分离功能，数据库先保持之前的单体，等到服务粒度最终确认之后，再分离数据库。</p>

<h2>超时反模式-The Timeout</h2>

<p>微服务架构是由一些列分离的服务组成的，这些服务之间通过一些远程协议进行互相之间的通信。这也牵扯到了服务的可用性和响应性。如下图所示：</p>

<p><img src="http://www.rowkey.me/post_images/ms-anti/availability-res.png" alt="" /></p>

<ul>
<li>可用性：服务消费方能够连接服务方，并可以向其发送请求。</li>
<li>响应性：服务方能够在消费方期望时间内给予请求响应。</li>
</ul>


<p>为了防止服务的不可用和无法响应，通常的做法就是设置一个调用超时。此种做法表面上看是没问题的，但是试想一下如下情景：发起一个购买100个商品的请求，请求成功返回一个确认号。如果当请求超时但是请求在服务端已经成功执行了，此时这个交易实际是完成的，但是消费方没有拿到确认号，如果重试请求，那么服务方需要一个复杂的机制判断这是否一次重复提交。</p>

<p>一种解决此问题的方案是设置一个较长的超时时间，如一个服务的通常响应耗时需要2s，最大耗时需要5s，那么超时时间可以设置为10s。但这样的问题就是如果服务不可用，所有消费方都得等待10s，这个是非常损耗性能的。</p>

<p>解决超时反模式的方案就是使用“断路器模式”。就类似于房屋中的电源断路器，当断路器关闭，电流可以通过，当断路器打开，那么电流中断一直到断路器关闭。断路器模式就是说当检测到服务方无法响应时就打开，后续的请求都会被拒绝掉。一旦服务方可响应了，那么断路器关闭，请求恢复。其工作模式如下图所示：</p>

<p><img src="http://www.rowkey.me/post_images/ms-anti/circuit-breaker.png" alt="" /></p>

<p>断路器会持续地监测远程服务，确保其是可响应的。只要服务可响应，那么断路器会一直关闭，允许请求通过。如果服务突然不可响应，那么断路器打开，拒绝后续的请求。而后续如果断路器又检测到服务恢复了，那么断路器会自动关闭，请求也就恢复了。此种方案与超时时间相比，最大的优势就是一旦服务不可响应，那么断路器模式可以让请求立刻返回而不是需要等待一定的时间。</p>

<p>Hystrix的Netflix是此种断路器模式的一种开源实现。此外，Akka中也包含了一个断路器实现：Akka CircuitBreaker类。</p>

<p>关于“断路器模式”的详细信息可见：<a href="https://martinfowler.com/bliki/CircuitBreaker.html">https://martinfowler.com/bliki/CircuitBreaker.html</a>。</p>

<h2>共享反模式-I Was Taught to Share</h2>

<p>微服务被普遍认为就是一种不共享任何东西的架构。但实际上只能是尽可能地少共享，毕竟在某些层面代码还是会被多个服务共享的。例如，与单独部署一套安全服务（验证和认证）其他所有服务都通过远程访问此服务相比，把安全相关的功能封装成jar包（security.jar），然后其他服务都集成此jar包，如此就能够避免每次都要发起对安全服务的访问，从而提高性能和可靠性。但后面的方案带来的问题就是依赖噩梦：每一个服务都依赖多个自定义的jar包。如此不仅打破了服务之间的边界上下文，同时也引入了诸如总体可靠性、变更控制、易测试性、部署等问题。</p>

<p>在一个使用面向对象编程语言的单体应用中，使用abstract类和接口实现代码复用和共享是一个良好的实践。但当从单体切换到微服务架构时，对于很多自定义的共享类和工具类（日期、字符串、计算）的处理要考虑到微服务间共享的东西越少越有利于保持服务间的边界上下文，从而更利于快速测试和部署。以下是几种推荐的方式，也是解决“共享反模式”的方案：</p>

<ol>
<li><p>共享项目</p>

<p> <img src="http://www.rowkey.me/post_images/ms-anti/share-project.png" alt="" /></p>

<p> 将共享的代码作为一个项目在编译期与各个服务集成。此种方式便于变更和开发软件，但是最大的问题在于很难发觉哪一个共享模块被修改以及修改的原因，也无法确定自己的服务是否需要这些变更。尤其是在服务发布前期发现某一个共享模块发生了变动的话需要再一次的测试才能走后续流程。</p></li>
<li><p>共享库</p>

<p> <img src="http://www.rowkey.me/post_images/ms-anti/share-library.png" alt="" /></p>

<p> 此种方式即将共享的代码作为类库集成到服务中。如此每次共享的库有改动，服务都需要重新打包、测试、重启。但相比起第一种，其由版本标记，能够更好地控制服务的部署和开发，服务开发者可以自己控制合适将共享库的改动集成进来。</p>

<p> 更进一步的，如果采用此种方案，一定要避免把所有共享的代码都打包进一个jar包中如common.jar。否则会很难确定何时要把库的变动集成到服务中。更好的做法是将共享代码分成几个单独上下文的库，如：security.jar、dateutils.jar、persistence.jar等，如此会比较容易的确定何时去集成共享库的变动。</p></li>
<li><p>冗余</p>

<p> <img src="http://www.rowkey.me/post_images/ms-anti/replica.png" alt="" /></p>

<p> 此种方案违反DRY原则，在每一服务中都冗余一份共享代码，如此能够避免依赖共享也能够保持边界上下文。但是一旦共享的代码有变动，那么所有服务都需要改动。因此，此种方案主要用于共享模块非常稳定，极小可能变动的情况。</p></li>
<li><p>服务合并</p>

<p> <img src="http://www.rowkey.me/post_images/ms-anti/consolidation.png" alt="" /></p>

<p> 当多个服务共性的代码变动比较频繁时可以采用此种方案合并成一个服务，如此就避免了多了服务频繁的测试和部署，也避免了依赖共享库。</p></li>
</ol>


<h2>可达性报告反模式-Reach-in Reporting</h2>

<p>微服务中各个服务以及其相应的数据都是包含在一个单独的边界上下文中的，也就是说数据是隔离到多个数据库中的。因此，这也会使得收集微服务的各种数据生成报告变得相对困难。一般来说有四种方案解决这个问题。其中，前三种是这里所说的“”都是从各个微服务中拉取数据，因此此反模式被称作“reach-in reporting”。</p>

<ol>
<li><p>数据库拉取模式</p>

<p> <img src="http://www.rowkey.me/post_images/ms-anti/database-pull.png" alt="" /></p>

<p> 报告服务直接总各个服务的数据库中拉取数据从而生成各种报告。此种方式简单迅速，但是会让报告服务和业务服务相互依赖，是一种数据库共享集成风格（通过共享的数据库将多个应用耦合在一起）。如此一旦数据库有改动，所有相关服务都要改动，也就打破了微服务中极为重要的边界上下文。</p></li>
<li><p>HTTP拉取模式</p>

<p> <img src="http://www.rowkey.me/post_images/ms-anti/http-pull.png" alt="" /></p>

<p> 与数据库拉取模式相比，此种方式不再是直接去访问服务的数据库，而是通过rest HTTP接口去请求服务的数据。此种方式能够保持服务的边界上下文，但是性能比较慢，而且HTTP请求无法很好的承载大数据。</p></li>
<li><p>批量拉取模式</p>

<p> <img src="http://www.rowkey.me/post_images/ms-anti/batch-pull.png" alt="" /></p>

<p> 此种方式会有一个单独的报告数据库/数据仓库来存储各个服务的聚合数据。会通过一个批量任务（离线或者基于增量实时）将服务更新的数据导入到报告数据库/数据仓库中。与数据库拉取模式一样，此种方式这也是一种数据库共享集成风格，会打破服务的边界上下文。</p></li>
<li><p>异步事件推送模式</p>

<p> <img src="http://www.rowkey.me/post_images/ms-anti/event.png" alt="" /></p>

<p> 此种方式即解决“Reach-in reporting&#8221;反模式的方案。每个服务都把自己的发生的事件异步推送给一个数据捕获服务中即可，后续数据捕获服务会将数据解析存储到报告数据库中。此种方式实现起来较复杂，需要在服务和数据捕获服务之间制定一种协议用于异步传输事件数据。但其能够保持服务的边界上下文，同时也能保证数据的时效性。</p></li>
</ol>


<h2>沙粒陷阱-Grains of Sand</h2>

<p>微服务实现中最有挑战的问题在于如何拆分service，如何控制服务的粒度，而正确的服务粒度则决定了微服务是否能够成功实现。服务粒度也能够影响到性能、健壮性、可靠性、易测试性、部署等。</p>

<p>“沙粒陷阱”即把服务拆分的太细。其中的一个原因就是很多时候开发者会把一个class与一个服务等同。合理的，应该是一个服务组件(Service component)对应一个服务。一个服务组件具有清晰、简洁的角色、职责，具有一组定义好的操作。其一般通过多个模块(Java Class)实现。如果组件和模块是一对一的关系，那么不仅仅会造成服务粒度过细同时也是一种不好的编程实践：服务的实现都是通过一个Class，那么此Class会非常大并且承担太多的责任，不利于测试和维护。</p>

<p>更进一步的，服务的粒度并不应该受其中实现类的数目影响：有些服务可能只需要一个类就可以实现，而有些服务会需要多个类来实现。</p>

<p>为了避免“沙粒陷阱”，可以通过以下三种测试来判断服务粒度是否合理：</p>

<ol>
<li><p>分析服务范围和功能</p>

<p> 主要是要明确服务用来干什么？有哪些操作？一般通过使用文档或者语言来描述服务的范围和功能就能够看出来服务是否做的太多。如果在描述中使用了“和”（“and”）或者“此外”（“in addition”）之类的词，很有可能就是此服务做的太多。</p>

<p> 服务的高内聚是一种良好的实践，其明确一个服务提供的操作之间须要是有关联的。如对于一个顾客服务，有以下操作：</p>

<ul>
<li>添加顾客</li>
<li>更新顾客信息</li>
<li>获取顾客信息</li>
<li>通知顾客</li>
<li>记录顾客评论</li>
<li>获取顾客评论</li>
</ul>


<p> 其中，对于前三个操作都是对顾客的CRUD操作，是相关联的。而后三者则无关。为了实现服务的高内聚，合理的应该是把此服务拆分成三个服务：顾客维护、顾客通知、顾客评论。</p>

<p> 如此，一开始以粗粒度的服务开始，然后逐渐拆分成细粒度的服务能够有利于对微服务的拆分。</p></li>
<li><p>分析数据库事务</p>

<p> 传统的关系型数据库都提供了ACID事务特性用于把多个更新操作打包成一个整体提交，要么都成功，要么都失败。而在微服务中，由于服务都是一个个分离的应用，是很难实现ACID的，一般都是实现BASE事务（basic avalability、soft state、eventual consistence）即可。但是无法避免的，仍然会有一些场景是需要ACID的。因此，当你不断的需要在BASE和ACID事务做判断、取舍的时候，很有可能就是服务粒度过细。</p>

<p> 如果业务常见无法接受最终一致性，那么最好就是讲服务粒度粗化一些，把多个更新操作放到一个服务中。</p></li>
<li><p>分析服务编排</p>

<p> 这里主要说的是服务之间的互相通信。由于对服务的调用都是一次远程调用，因此服务编排会非常大的影响微应用总体的性能。此外，它也会影响系统整体的健壮性和可靠性，越多的远程调用，那么越高的几率会有失败或者超时的请求出现。</p>

<p> 如果发现完成一次业务逻辑需要调用太多的远程服务，就说明服务的粒度可能太细了。这时候就需要将服务粗化。而合并细粒度服务还能够提高性能，提升总体的健壮性和可靠性，并且减少了了多个服务间的依赖，更利于测试、部署。</p>

<p> 此外，使用响应式编程技术异步并行调用远程服务也是一种提升性能和可靠性的方案。</p></li>
</ol>


<h2>无因的开发者陷阱-Developer Without a Cause</h2>

<p>此陷阱主要讲的是开发者或者架构师在做设计时很多时候是拍脑袋在做，没有任何合理的原因或者原因是错误的，也不会做取舍。而想要解决此问题，不仅仅是架构师，开发者也需要同时了解技术带来的好处以及折中。</p>

<p>了解业务驱动是避免此陷阱的关键一步。每一个开发者和架构师都应该清楚的了解下面这些问题的答案：</p>

<ul>
<li>问什么要使用微服务？</li>
<li>最重要的业务驱动是什么？</li>
<li>架构中的哪一点是最为重要的？</li>
</ul>


<p>假如易部署性、性能、健壮性、可扩展性是系统最看重的特性，那么对于不同的业务侧重点，微服务的粒度需求也是不同的。细粒度的服务能够达到更好的易测试性和易部署性，而粗粒度的服务则能够有更好的性能、健壮性以及可靠性。</p>

<h2>追随流行陷阱-Jump on the Bandwagon</h2>

<p>微服务是目前非常流行的架构理念，越来越多的公司也都在紧跟这个潮流纷纷转型微服务架构，而不管到底自己是否真的需要。为了避免此陷阱，需要首先了解微服务的优点和缺点。</p>

<p>优点：</p>

<ul>
<li>易部署：容易部署是微服务的一个很大的优点。毕竟相比起一个庞大的单体应用，一个小并且职责单一的微服务的部署非常简单并且带来的风险小很多。而持续部署技术则进一步放大了这个有点。</li>
<li>易测试：一个职责单一、共享依赖少是的测试一个微服务也是很容易的。而基于微服务做回顾测试与单体大应用相比也是很容易的。</li>
<li>控制变更：每个服务的范围和边界上下文使得很容易控制服务的功能变动。</li>
<li>模块化：微服务就是一个高度模块化的架构风格。这种风格也是一种敏捷方式的表达，能够很快的响应变化。一个系统模块化程度越高，那就越容易测试、部署和发布变更。一个服务粒度划分隔离的微服务系统是所有架构中模块化程度最高的架构形式。</li>
<li>可扩展性：由于每一个服务都是一个职责单一的细粒度服务，因此此种架构风格是所有架构分隔中可扩展性最高的。其非常容易扩展某一个或者某几个功能从而满足整体系统的需求。而得益于服务的容器化特性以及各种运维监控工具，服务能够自动化进行启动和关闭。</li>
</ul>


<p>缺点：</p>

<ul>
<li>组织变动：微服务需要组织在很多层面进行变动。研发团队需要包含UI、后端开发、规则处理、数据库处理建模等职位，从而使得一个小的团队能够具有实现微服务的所有技术。同时，传统的单体、分层应用架构的软件发布流程也需要更新为自动化、高效的部署流水线。</li>
<li>性能：由于服务都是隔离的，因此发起对服务的远程调用肯定是会影响性能的。服务编排、运行环境都是影响性能的很大因素。了解远程调用的延迟、需要与多少服务通信都了解性能需要掌握的信息。</li>
<li>可靠性：和性能一样。服务的远程调用阅读，那么失败的几率就越高，总体的可靠性就会越低。</li>
<li>DevOps：随着微服务架构而来的会是成千上百的服务。手动管理这么多的服务是很不现实的。这就对于自动化运维部署、协作提出了很高的挑战。需要使用非常多的操作相关的工具和实践，是一个非常复杂的工作。目前差不多有12种操作工具和框架使用在微服务架构中，其中每一种又包含了很多具体的工具和产品供选择。例如，有监控工具、服务注册、发现工具、部署工具等等。对于这些工具和框架的选择一般都会需要将近数月的研究、测试、权衡分析才能选出最适合的技术选型。</li>
</ul>


<p>了解了微服务的优缺点后，下一步则需要根据实际的业务来分析微服务是不是解决这些问题的最佳方案。可以采取以下问题：</p>

<ul>
<li>业务和技术的目标是什么？</li>
<li>使用微服务是为了完成什么？</li>
<li>目前和可预知的痛点是什么？</li>
<li>应用的最关键的技术特性是什么？（性能、易部署性、易测试性、可扩展性）</li>
</ul>


<p>回答这些问题再结合微服务的优缺点能够让你明确现在是否是使用微服务的适当时机。</p>

<p>除了微服务以外，还有其他7种比较普遍使用的架构供选择：</p>

<ul>
<li>基于服务的架构（Service-Baased）</li>
<li>面向服务的架构（Service-Oriened）</li>
<li>分层架构（Layered）</li>
<li>微内核架构（Microkernel）</li>
<li>基于空间的架构（Space-Based）</li>
<li>事件驱动架构（Event-Driven）</li>
<li>流水线架构（Pipeline）</li>
</ul>


<h2>静态合约陷阱-Static Contract</h2>

<p>微服务的消费方和服务提供方之间会有一个合约/协议用来规定输出输出数据的格式、操作名称等等。一般情况下这个合约是不变的。但是如果你没有使用版本号来管理服务接口，那么很容进入“静态合约”陷阱。</p>

<p>给合约打上版本标记不仅仅能够避免巨大的变动（服务提供方修改合约使得所有消费方也都得修改），还能够提供向后兼容性。这里有两种技术可以实现合约的版本号：</p>

<ul>
<li><p>在头部信息附加版本号</p>

<p>  <img src="http://www.rowkey.me/post_images/ms-anti/header-version.png" alt="" /></p>

<p>  如图，此种方式即在远程访问协议的头部添加版本信息。而如果远程协议使用的是REST，那么还可以使用vendor mime type（vnd）来指定合约的版本号。如下：</p>

<pre><code class="``">  POST /trade/buy
  Accept: application/vnd.svc.trade.v2+json
</code></pre>

<p>  服务接受到请求，能够通过正则等手段简单解析出其中的合约版本号再根据版本号做相应的处理。</p>

<p>  而如果使用消息队列，那么可以将版本号放置在属性部分(Property section)。JMS的一个例子如下：</p>

<pre><code class="``">  String msg = createJSON("acct","12345","sedol","2046251","shares","1000");
  jsmContext.createProducer()
      .setProperty("version",2)
      .send(queue,msg);
</code></pre></li>
<li><p>在合约本身中附加版本号</p>

<p>  <img src="http://www.rowkey.me/post_images/ms-anti/schema-version.png" alt="" /></p>

<p>  此种方式版本号独立于远程访问协议，与头部信息版本号相比，这也是其最大的优点。但与此同时，其缺点比较多。首先要从请求信息主体中解析版本号，会出现很多解析的问题。其次，合约的模式可能会非常复杂，使得很难做数据转换。最后，服务要引入对模式的验证逻辑。</p></li>
</ul>


<h2>我们到了吗陷阱-Are We There Yet</h2>

<p>微服务架构中，各个服务都是独立的个体，也就意味着所有客户端或者API层和服务之间的通信都是一次远程调用。如果对这些远程调用的耗时没有什么概念，那么就陷入了“Are We There Yet”陷阱。合理的做法需要去测试注入长尾延迟（95%、99%、99.%之外的请求延迟）、平均延迟等指标。很多时候即使是有很好的平均延迟，但是较差的长尾延迟会造成很大的破坏。</p>

<p>在生产环境或者准生产环境有助于去了解应用的真实性能。例如，一个业务请求需要调用四个服务，假设一个服务调用的延迟是100毫秒，那么加上业务请求本身的延迟，完成此次业务请求共需要500毫秒的延迟。</p>

<p>了解目前所用协议的平均延迟是一方面，另一方面则需要对比其他远程协议的延迟，从而在合适的地方使用合适的协议。如：JMS、AMQP、MSMQ。</p>

<p><img src="http://www.rowkey.me/post_images/ms-anti/comparing-protocol.png" alt="" /></p>

<p>如图，AMQP协议的性能是最好的。那么结合业务场景，就可以选择REST作为客户端与服务间的通信协议，AMQP做为服务之间的通信协议以提高应用的性能。</p>

<p>当然，性能并非在选择远程协议时唯一考虑的因素。下一节中也会考虑利用消息队列的一些额外功能。</p>

<h2>REST使用陷阱-Give It a Rest</h2>

<p>REST现在是微服务中用的最多的通信协议，包括服务之间的通信。而流行的开发框架如DropWizard、Spring Boot都提供了REST支持。但是如果只选择REST这一种协议，不去考虑其他诸如消息队列的优势，那么久陷入了“REST使用”陷阱。毕竟异步通信、广播、合并请求到一个事务这些需求，REST是很难满足的。</p>

<p>消息队列标准目前包括平台特定和平台无关两种。前者包括Java平台中的JMS和C#平台的MSMQ，后者则是AMQP。对于平台特定的消息标准JMS，其规范了API，因此切换broker实现（ActiveMQ、HornetQ）时无需修改API，但由于底层通信协议是不同的，集成的客户端或者服务端jar包需要随着修改。对于平台无关的消息标准，其规范了协议实现标准，并没有规范API。使得不同平台之间都可以互相通信，而不管实际产品是什么。如一个使用了RabbitMQ的客户端可以很容易地与一个StormMQ通信（假设使用的协议相同）。也就是其独立于平台的特性使得RabbitMQ成为微服务架构中最流行的消息队列。</p>

<ol>
<li><p>异步请求</p>

<p> 异步通信是消息队列适用的场景之一。服务消费者发起请求后无需等待服务方响应能够提高总体的性能，同时调用方无需担心调用超时或者使用断路器，从而提高了系统的可靠性。</p></li>
<li><p>广播</p>

<p> 将消息广播给多个service是消息队列的又一个适用场景。一个消息生产者向多个消息接受者发送消息，无需知道谁在接受消息以及如何处理它。</p></li>
<li><p>事务请求</p>

<p> 消息系统提供了对事务消息的支持：如果多个消息被发送到了在一个交易上下文的多个队列或者主题中时，那么直到消息发送者commit，服务才会真正的接受到相应的所有消息（在commit之前会一直保存在队列中）。</p>

<p> 因此对于服务消费者需要合并多个远程请求到一个事务中的场景可以选择事务消息。</p></li>
</ol>


<p><img src="http://www.rowkey.me/post_images/book-all.png" width="400"/></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java后端技术概览]]></title>
    <link href="http://www.rowkey.me/blog/2018/05/12/java-tech-overview/"/>
    <updated>2018-05-12T19:29:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2018/05/12/java-tech-overview</id>
    <content type="html"><![CDATA[<p>一个合格的Java后端工程师需要掌握哪些技能呢？扫描下面的二维码可以看到<a href="https://raw.githubusercontent.com/superhj1987/pragmatic-java-engineer/master/book/server-tech/media/java-skill-tree.png">Java后端技术概览图</a>。</p>

<p><img src="https://raw.githubusercontent.com/superhj1987/pragmatic-java-engineer/master/book/server-tech/media/tech-tree.png" alt="" /></p>

<!--more-->


<h2>软件开发的核心原则</h2>

<p>此处所说的是软件开发应该遵循的一些核心原则：</p>

<ul>
<li>Don&rsquo;t Repeat Yourself: 这是软件开发的一个基础原则，即不要做重复性劳动。也是现在所说的“极客文化”的一种。代码重复、工作重复在软件开发中都是不合理的存在。利用各种手段消除这些重复是软件开发的一个核心工作准则。</li>
<li>Keep it simple stupid：即KISS原则。在做软件设计的工作中，很多时候都不要想得过于复杂，也不要过度设计和过早优化，用最简单且行之有效的方案也就避免了复杂方案带来的各种额外成本。既有利于后续的维护，也利于进一步的扩展。</li>
<li>You Ain’t Gonna Need It: 即YAGNI原则。只需要将应用程序必需的功能包含进来，而不要试图添加任何其他你认为可能需要的功能。因为在一个软件中，往往80%的请求都花费在20%的功能上。</li>
<li>Done is better than perfect: 在面对一个开发任务时，最佳的一个思路就是先把东西做出来，再去迭代优化。如果一开始就面面俱到，考虑到各种细节，那么很容易陷入牛角尖而延误项目进度。</li>
<li>Choose the most suitable things: 这是在做方案选择、技术选型时候的一个很重要的原则。在面对许多技术方案、开源实现的时候，务必做到的是不能盲目求新，要选择最合适的而非被吹得天花乱坠的。</li>
</ul>


<h2>软件过程</h2>

<p>一个软件的生命周期中，除了开发还有很多其他步骤，也都是需要掌握的一些技术。</p>

<ul>
<li>项目管理：项目管理对于一个软件的开发是非常重要的，能够保证项目进度有条不紊地进行，在可控的时间内以一定的质量交付。瀑布开发模型、螺旋开发模型是传统的项目管理模型。在互联网的开发工作中，敏捷开发则是比较受推崇的开发方式。所谓敏捷开发即快速实现原型，然后快速迭代。Scrum是目前普遍流行的敏捷开发方式之一。</li>
<li>测试驱动开发：在平时的开发过程中，目前比较流行也是行之有效的一种方式就是Test Driven Develop，即测试驱动开发。此种方式的核心就是编写单元测试。简单来讲，就是先完成某一个功能的单元测试用例，然后在逐步消除测试用例的编译错误的过程中完成功能的开发。</li>
<li>持续集成：某一个软件功能完成开发之后，后续还有测试、预发布、部署等过程。整个过程称之为集成，而持续集成指的是无需人工干预可以不断地进行这个过程。Jenkins、Quick Build以及后起之秀Travis CI都是比较典型的持续集成工具。 此外，持续集成的子过程持续部署指的是将集成结果部署到不同的环境供用户使用，并且立即反馈部署结果，Rundeck是这方面用的比较多的软件。它提供了Web界面和命令行来执行shell命令和job工作流，能够自定义job步骤设置shell命令/job运行周期，可以在任意数量的服务器上批量执行不同的任务，降低对自动化的部署、执行、维护的工作难度。</li>
</ul>


<h2>日常开发</h2>

<p>日常开发指的是一些日常需要掌握的技能、工具等。</p>

<ul>
<li>编辑器：开发中现在用的比较多的编辑器包括Emacs、Vim和SublimeText。笔者用的最多的就是SublimeText，基本能够满足自己的开发需求，包括编写脚本代码、查看代码文件等。Vim和Emacs这两款编辑器相对SublimeText来说需要记住很多命令，有一定的上手门槛。</li>
<li>源码版本管理：代码的版本管理工具由CVS到SVN再到现在的Git，已经在事实上形成了以分布式版本管理为主的版本管理方案。基于Git，可以采用Git Flow做为源码管理模型。</li>
<li>项目工具：Github是一个第三方Git中央仓库，目前是世界最大的开源代码库，也能够做为私人的代码管理软件；Facebook开源的Phabrictor提供了非常强大的任务管理、Bug管理、测试、代码管理等，但其上手门槛相对较高；禅道是国人开发的一款项目管理工具，但是其免费版功能有限；以Tower.im为代表的第三方项目管理服务也是一个可选择的方案，风险在于数据都不再是私有的。</li>
</ul>


<h2>运行环境</h2>

<p>后端应用开发完成之后是需要部署到服务器上对外提供服务的。从最开始的直接在物理机上部署服务到后来的虚拟环境、云环境再到现在火热的容器，直至最近兴起的无服务器技术。都是为了让服务的运行环境能够更加便于建立、更容易维护、更容易扩展。</p>

<ul>
<li>Linux: 说到后端服务器肯定绕不过Linux。至少现在互联网的后端服务绝大多数都是部署在Linux的各种服务器版本中的。其中CentOS、Ubuntu以及Debian是用的比较多的版本。对于Linux，需要熟练掌握的就是很多常用Shell命令如ps、netstat、lsof、ss、df、dh等等。此外，很多性能分析命令如top、vmstat、iostat、sar等也需要熟练使用。</li>
<li>应用服务器：就Java来讲，很多时候开发的都是Web应用，以HTTP协议对外提供服务。除了对性能要求比较苛刻的情况下会自己构建HTTP服务之外，大部分情况是需要依赖于支持Java程序的应用服务器的。目前最为常用的有：Tomcat、Jetty。严格来讲，这两者只是Servlet容器，真正的JavaEE应用服务器如Jboss、Weblogic在互联网领域很少使用。当然，这些软件并没有提供URL重写、请求委托等Web服务器功能，还不足以担当完整Web服务器的角色。Nginx则是目前最为流行的Web服务器。</li>
<li>负载均衡：在高并发流量环境下，后端服务会以集群的模式对外提供服务。在集群的前面，需要负载均衡器将请求分配到集群的各个结点上。LVS是最为流行的四层负载均衡软件,HAProxy是另一个即支持四层又支持七层负载均衡的软件，Nginx则是七层负载均衡最为流行的解决方案。当然，性能最为好的负载均衡方案是以F5为代表的硬件负载均衡，但由于其昂贵的成本因此在互联网团队中很少使用。此外，这里需要补充的是为了保证同等角色的服务的高可用，如LVS经常作为流量的入口，因此会部署多个LVS结点互为主备防止一个挂掉的时候造成服务不可用。而实现互为主备的技术目前用的最多的就是Keepalived。</li>
<li>虚拟化：虚拟化技术是前几年经常用来做私有云的一种技术。即将自己的物理主机通过虚拟化技术分裂为多个虚拟主机，能够隔离资源。其中，VPS（虚拟专用服务器）的代表技术包括：微软的Virtual Server、VMware的ESX Server、SWsoft的Virtuozzo。此外，OpenStack提供的构建私有IIAS的功能、Cloud Foundry提供的构建私有平台运行环境以及Docker、Kunernetes带来的容器服务都是虚拟化技术的一种。</li>
</ul>


<h2>第三方服务</h2>

<p>虽然从根本上讲所有的软件服务都是可以自己开发的或者部署到自己服务器上的。但是受限于成本、周期或者其他客观因素，很多服务还是需要使用第三方的。</p>

<ul>
<li>IAAS：Infrastructure As A Service, 是云计算最开始的一种模式，现在基本上所有的云服务商都有IAAS的服务。其中，全球最强大的云服务提供商是亚马逊的AWS，国内的则当属阿里云。就目前来看，即使是强如AWS也会出现一些运维故障，因此国内的这些云计算提供商很多时候的服务健壮性、运维响应更是经常被人吐糟。就笔者自己的经历来看。2010年左右，盛大云的云服务其实做的还不错，但后来由于种种原因现在基本已经没啥份额了。国内除了阿里云，UCloud算是专注做云计算的一个比较靠谱的公司了。此外，还有一个青云，做的东西略显高大上，也是一个不错的选择。当然，现在这些云服务商早就不仅仅是IAAS了，也做了很多PAAS的服务。</li>
<li>PAAS：Platform As A Service，即只需要提交代码到指定的运行环境，其他的诸如代码打包、部署、IP绑定都由平台完成。除了可以使用Cloud Foundry构建自己的PAAS平台以外，现在最为流行的第三方PAAS服务有：新浪的SAE、百度的BAE以及Google的GAE。</li>
<li>域名：有个可以提供服务的应用后，那么域名也是一个必须的基础设施。一个好的域名不仅仅代表企业的形象，也能够更加方便用户的记忆与传播。目前购买域名可以通过国外的name.com、godaddy以及国内的万网等。有了域名之后下一步就得进行备案，域名提供商一般都提供了配套服务或者去找一些代理也可以办下来。此外，对于域名的解析，域名提供商一般会内置解析功能，也可以使用独立的DNS服务，如dnspod。</li>
<li>CDN: 内容分发网络，即就近请求的一种技术实现。服务提供方将会被大量访问的内容在全国的多个结点都做缓存，这样当用户访问时就能够就近选择，从而减少网络传输延时，提高访问速度。国内目前七牛和又拍都提供了不错的CDN服务，当然像阿里云、UCloud这种综合云服务商也都有CDN服务。</li>
<li>邮件发送：这个主要需要依赖邮件服务器，然后通过SMTP协议就可以实现发送。可以选择自己搭建，也可以选择诸如腾讯邮箱、网易邮箱等。</li>
<li>短信发送：使用短信发送验证码、营销短信是很常见的应用场景。由于短信是需要运营商支持的，所以这一块基本上都是需要依赖第三方代理的。市面上也有很多短信网关代理。</li>
<li>消息推送：在移动应用上，推送已经成为一个标配功能。目前个推应该是第三方推送服务中的佼佼者，而且由于其客户很多，在联盟唤醒上有很大的优势。</li>
<li>开放平台：通过开放平台，可以使用OAuth等协议获取用户在第三方平台上的信息实现第三方平台登录等。目前，微博、微信、QQ是最常见的第三方登录方式，基本上都是使用OAuth协议为第三方开发者提供服务的。</li>
<li>支付接口：支付接口是很多内置购买功能软件的必备组件。目前，接入最多的无非是支付宝和微信，都提供了开放平台供商家接入。当然，也有直接绑定银行卡支付的，此时需要走的就是银行或者银联的网关接口。</li>
</ul>


<h2>计算机基础科学知识</h2>

<p>对于像数据结构、算法、计算机网络、操作系统、计算机组成原理这些计算机科学基础知识，不管是后端还是其他领域都是必须的技能，也是所有软件开发的基础。扎实的计算机科学基础才能让你在学习、使用某种技术开发软件、调试软件、排查问题时能够心里有底、有据可循。</p>

<ul>
<li>数据结构：数据结构是组成程序的基础。经典的数据结构包括：字符串、数组、链表、哈希表、树（二叉树、平衡树、红黑树、B树）、堆栈、队列、图。</li>
<li>算法: 经典的排序和查找算法在平时的开发工作中经常会用到，如：冒泡排序、插入排序、选择排序、归并排序、快速排序、希尔排序、堆排序以及二分查找等。此外，在函数/方法的算法实现中要注意递归和迭代各自的优缺点。而衡量算法性能无外乎空间复杂度和时间复杂度。</li>
<li>业务相关算法：除了上面的基本算法之外，业务中还会经常涉及到一些更为复杂的算法，如：压缩算法、LRU缓存算法、缓存一致性、编译原理中的状态机等。此外，目前越来越火的机器学习中有很多算法也是在很多业务场景中有很大用途的，如：用于文本分词的结巴分词和中科院ICTCLAS；用于关键词提取的TF-IDF和TextRank；用于计算文本相似度的主题模型、Word2Vec、余弦相似度以及欧几里得距离；用于文本分类的朴素贝叶斯；用于推荐的聚类、协同过滤、用户画像、隐语义模型等。</li>
<li>计算机网络： TCP/IP协议是网络最根本的协议，其七层/四层协议栈的设计都是非常精华的东西，连接的建立、断开以及连接的各种状态的转换都是排查、解决网络问题的根本依据。从TCP/IP往上，HTTP协议是现在绝大多数后端应用对外提供的协议，发展到现在已经将要步入HTTP2.0时代，带来了持久连接、连接复用等令人振奋的新特性。此外，基于HTTP的HTTPS协议由于其安全性在逐渐的成为后端服务对外开放的主流协议。业务层面，基于HTTP协议的RESTful规范正成为对外接口的主流规范，而OAuth2.0协议也在成为开放平台对外的主流协议。除了HTTP之外，SMTP是另一个基于TCP/IP的应用协议，主要用在发送邮件上。</li>
<li>设计模式： 在软件开发中，前人的经验形成了很多经典设计模式供我们使用，能够使得软件的实现可服用、可扩展、可维护。经典的工厂模式、简单工厂模式、单例模式、观察者模式、代理模式、建筑者模式、门面模式、适配器模式、装饰器模式在日常的很多开发场景下都具有很重要的意义。</li>
</ul>


<h2>数据</h2>

<p>现在互联网的所有业务其实都是围绕数据来进行的。而数据传输、数据存储、数据分析处理都是关键的部分。</p>

<ul>
<li>高速缓存：目前用的最为广泛的缓存软件Redis能够支持丰富的数据结构，如：字符串、列表、有序集合等多种数据的存储。了解缓存实现的原理、内存淘汰的策略能够更好地使用缓存。此外由于缓存的成本较高，在使用缓存的时候一定要做好量化和存储优化工作。</li>
<li>数据库：掌握数据库的很大一个关键点就在于对索引的使用，可以说，正确地使用索引就基本等于掌握了数据库的使用。目前绝大多数据库都是使用B树做为索引的数据结构，目的就是为了利用磁盘顺序读写的特性。不同的数据库由于本身设计目的的不同，都有一些独特的优势，如：MongoDB天然支持sharding，但受限于NoSQL，在重事务、有关联关系的场景下并不适用；HBase使用LSM作为底层数据结构，牺牲了读性能来换取高速的写性能。</li>
<li>搜索引擎：搜索引擎主要应对全文检索以及多维度查询的业务场景。掌握搜索引擎使用的数据结构、集群方式、配置的关键点有助于更好地使用搜索引擎服务于业务应用。</li>
<li>消息队列：消息队列有两种角色：生产者和消费者，两种角色对于消息队列的需求也不一样。其中，对于消费者来说，消息消费的方式包括发布-订阅和队列两种。消息队列在语义保证上分为：At Most Once、At Least Once、Exactly Once三种模式，需要更具特定的业务场景选择合适的语义保证。此外，消息队列对于高可用、消息安全的保证决定了此消息队列的可靠性。</li>
<li>数据存储和分析：数据存储下来最终还是要用来做分析和处理的。数据的处理分为离线处理和实时处理。离线处理的优势在于能够处理大量数据，但是一般会有T+1的延迟，适用于计算量大但是对于结果允许有延时的场景。但对于离线数据分析，还有一个很关键的就是数据倾斜问题。所谓数据倾斜指的是region数据分布不均，造成有的结点负载很低，而有些却负载很高，从而影响整体的性能。因此，处理好数据倾斜问题对于离线数据处理是很关键的。而实时处理一般是流式处理方式，适用于数据能够转换为数据流，对于结果要求及时性的场景。对于实时数据分析，需要注意的就是实时数据处理结果写入存储的时候，要考虑并发的问题，虽然对于Storm的Bolt程序来说不会有并发的问题，但是写入的存储介质是会面临多任务同时读写的。通常采用的方案就是采用时间窗口的方式对数据做缓冲后批量写入。此外，基于Yarn、Mesos这种资源统一管理调度系统进行数据分析需要根据运行原理的不同进行适当的配置。</li>
<li>数据同步：数据仓库的数据来源除了直接的日志外还有一个很关键的就是业务数据库。从业务数据库到数据仓库的过程称为数据同步。有基于SQL的同步方案，也有基于MySQL binglog的增量同步方案。</li>
</ul>


<h2>Java</h2>

<p>对于Java方面的技能来说，主要有两个大的部分，包括Java编程和JVM。</p>

<p>先来看一下Java编程部分，这也是Java工程师最最基础的技能。</p>

<ul>
<li>IDE: 目前用的最多的Java IDE当属Eclipse和Intellij IDEA。前者是老牌IDE，逐步淘汰了Jbuilder以及Netbeans，占领了大部分Java IDE市场。后者则是后起之秀，由于其增量编译、智能分析代码等带来的性能提升，现在已经得到了大规模使用，大有取代Eclipse之势。</li>
<li>核心语法：目前用的最多的当属JDK6的Java语法。而到了Java7引入了try with resource、switch string、diamonds等语法。Java8则又引入了lambda、stream等语法。</li>
<li>集合类：集合类是Java语言中非常精华的部分，包括：HashMap、ArrayList、LinkedList、HashSet、TreeSet以及线程安全的ConcurrentHashMap、ConcurrentLinkedQueue等线程安全集合。了解他们的实现原理以及查询、修改的性能以及使用场景是非常必要的。</li>
<li>工具类：Google Guava、Apache commons、FastJson提供了很多JDK本身没有的工具类、集合等。此外，ASM字节码操作以及CGLIB代码生成能够提供更底层的java编程功能。</li>
<li>高级特性：抛开Java核心的基本编程，并发编程、泛型、网络编程、序列化RPC都属于java的高级编程特性。其中并发编程需要掌握Executors提供的各种并发工具、Java7带来的fork/join框架以及CountDownLatch、Semaphore、CyclicBarrier等同步工具；网络编程要区分好BIO、NIO以及AIO；序列化中除了JDK自带的序列化实现之外，Protobuf和Kryo是比较高效的第三方实现；RPC的实现中，Thrift、Hessian、Dubbo以及RMI则是比较常用的几个协议,其中的Hessian是基于Http协议的，Dubbo是基于TCP协议，而Thrift则同时支持。</li>
<li>JavaEE: JavaEE现在是Java应用最为普遍的一个领域。Servlet是JavaEE中最根本的组件之一。而Servlet3.0带来的异步Servlet提高了其处理请求的性能。</li>
<li>项目构建：目前用的最多的Java项目构建工具包括Maven和Gradle，提供了源码包依赖管理、编译、打包、部署等一系列功能。</li>
<li>编程框架：Spring是Java编程中避不开的一个框架，发展到现在除了Spring核心的IOC、AOP之外，SpringMVC、Spring Data、Spring Cloud、Spring Boot等等都给Java开发者们带来了开发上的便利，大大提高了开发效率；ORM框架MyBatis也是Java领域比较火的框架之一，实现了数据库记录到Java对象的映射操作；Jersey则提供了从客户端到服务端的一整套符合RESTful规范的开发框架。此外，Vert.x、Spring Flux这种非常适用于IO密集型应用的异步响应式编程框架也开始兴起。</li>
<li>测试：测试是任何编程都需要的一步。黑盒测试主要指的通常进行的功能测试，白盒测试则主要指的对代码功能、质量进行的测试。此外，关键的单元测试则是开发工程师需要着重注意的地方，“测试驱动开发”的理念也是值得推崇的开发方式。JUnit是目前Java中实现单元测试的主流方案。</li>
</ul>


<p>一般来说掌握上面所述的Java编程技能是能够应付大多编程工作的。但是如果在代码层面已经做到最大努力却还是达不到性能要求的时候，就需要在JVM虚拟机层面做一些努力了。可以说掌握JVM相关技术是Java开发进阶的一个关键步骤。</p>

<ul>
<li>虚拟机实现: Java的虚拟机实现除了我们常用的HotSpot外，还有JRockit、J9以及移动平台的Dalvkit、ART（Android4.4后引入）。我们通常锁描述的JVM优化绝大多是是针对HotSpot虚拟机来说的。</li>
<li>类加载机制：JVM的类加载机器遵循双亲委派原则，即当前类加载器需要先去请求父加载器去加载当前类，如果无法完成自己才去尝试进行加载。OSGI框架则打破了此机制，采用了平等的、网状的类加载机制，以实现模块化的加载方案。</li>
<li>运行时内存组成: 程序计数器、堆栈、方法区、堆、堆外内存，这些一起组成了JVM的运行时内存。</li>
<li>Java内存模型：Java的主内存+线程私有内存的模型是线程安全问题产生的根本。</li>
<li>GC原理和调优：与C、C++这些语言相比，GC是Java的优势，但因为GC的细节被JVM屏蔽了，在对内存、性能要求非常苛刻的情况下难以进行自由控制，某种程度这也是劣势。如果想在某些场景下发挥GC的最大性能，能做的就是对GC的各种参数做优化配置，如新生代和老年代的垃圾回收器选择、各种垃圾回收参数的配置等。此外，很多时候由于代码质量或者外部客观因素，造成了JVM频繁GC，需要使用相关的工具快速进行问题定位和解决。</li>
<li>性能调优和监控工具：JDK自带了很多强大的调优和监控工具，包括jmap、jstack、jcmd、jconsole、jinfo等。此外，btrace是一款非常强大的在线问题动态排查工具，能够无须重启Java进程，动态的插入一些代码逻辑，从而拦截代码执行逻辑打印日志，从而排查问题。</li>
</ul>


<h2>系统架构</h2>

<p>一个应用从0开始一般会经历单体应用、垂直应用到分布式服务架构的演化（具体的会随着业务的不同有所不同）。如下图所示：</p>

<p><img src="http://www.rowkey.me/post_images/javatech/arch.png" alt="" /></p>

<ul>
<li>单体应用：当应用规模、团队规模比较小的时候，只需要一个包括了所有功能的应用即可。减少部署结点，也减少了部署成本。此时，对数据库的ORM操作是架构实现的关键点。</li>
<li>垂直应用：当应用的用户规模越来越大，请求量越来越高的时候。单体应用增加结点带来的资源浪费会凸现出来，因为绝大多数接口请求量并没有特别大，根本没必要扩充到多个结点。此时，就可以将单体应用拆分成互不相关的几个应用，分别对外提供服务。此时，加速每个应用开发的MVC框架是架构实现的关键点。</li>
<li>分布式服务：当垂直应用越来越多，应用之间的交互不可避免。抽离核心业务单独部署，逐渐形成稳定的服务中心。而随着团队规模的相应扩大，服务会随着团队的增多变得越来越多，粒度也会变得越来越小,也就逐步形成了分布式服务的架构，而当粒度细到某种程度、服务数量多到一定程度则可以称之为微服务。即在设计好业务边界之后将原来的单体应用分解成一个个细粒度的服务，彼此之间通过某种方式进行通信。微服务架构的关键在于如何做好服务的治理、调度、维护工作。目前，Dubbo算是微服务架构中用的比较多的框架，但Dubbo仅仅解决了微服务架构中的一部分问题。Spring Cloud则基本上涵盖了微服务架构的各个方面。</li>
</ul>


<h2>部署架构</h2>

<p>对于Web应用来说，LVS+Nginx+Tomcat+MySQL+Redis即可构成一个简单通用的部署架构，如下图所示：</p>

<p><img src="http://www.rowkey.me/post_images/javatech/web-arch.png" alt="" /></p>

<ul>
<li>LVS作为最前置的结点，负责在网络第四层转发流量、负载均衡。</li>
<li>多个LVS使用Keepalived互为主备实现高可用。</li>
<li>Nginx作为反向代理，负责在网络第七层转发流量、负载均衡。此外，其做为高性能Web服务器，还可以负责静态页面/资源的访问。也可以通过Nginx lua应对一些高并发的动态场景。</li>
<li>Tomcat做为业务容器，主要的应用代码都在这里面。</li>
<li>Redis作为缓存，隔离高并发请求和后端数据库。</li>
<li>MySQL以主从模式对数据做持久化。</li>
</ul>


<p>其中，虚线部分是数据库层，采用的是主从模式。也可以使用Redis Cluster（Codis等）以及MySQL Cluster（Cobar等）来替换。</p>

<blockquote><p>本文节选自《Java工程师修炼之道》一书。</p></blockquote>

<p><img src="http://www.rowkey.me/post_images/book-all.png" width="400"/></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[架构简明指南]]></title>
    <link href="http://www.rowkey.me/blog/2018/04/25/arch-usage/"/>
    <updated>2018-04-25T19:29:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2018/04/25/arch-usage</id>
    <content type="html"><![CDATA[<p>之前的<a href="http://www.rowkey.me/blog/2017/08/24/arch/">《谈谈架构》</a>讲述了架构的概念、原则等等，这里择出其中的设计原则部分供大家随手参考。</p>

<p>《Clean Architecture》一书中对于软件架构目的的解释：</p>

<blockquote><p>The goal of software architecture is to miminize the human resources required to build and maintain the required system.</p></blockquote>

<p>即：软件架构的目的就是将构建和维护系统需要的人力成本降到最低。</p>

<p>因此，可以得出架构设计的关键思维就是判断和取舍（程序设计的关键思维是逻辑和实现），即如何选择技术、组合技术使得需要的人力资源最少。</p>

<!--more-->


<h2>架构原则</h2>

<p><img src="http://www.rowkey.me/images/blog_images/arch-spec.png" alt="" /></p>

<ul>
<li><strong>避免过度设计</strong>：最简单的方案最容易实现和维护，也可以避免浪费资源。但方案中需要包括扩展。</li>
<li><strong>冗余设计</strong>：对服务、数据库的做结点冗余，保证服务的高可用。通过数据库主从模式、应用集群来实现。</li>
<li><strong>多活数据中心</strong>：为了容灾，从根本上保障应用的高可用性。需要构建多活的数据中心，以防止一个数据中心由于不可控因素出现故障后，引起整个系统的不可用。</li>
<li><strong>无状态设计</strong>：API、接口等的设计不能有前后依赖关系，一个资源不受其他资源改动的影响。无状态的系统才能更好地进行扩展。如果非得有状态，则要么客户端管理状态，要么服务端用分布式缓存管理状态。</li>
<li><strong>可回滚</strong>：对于任何业务尤其是关键业务，都具有恢复机制。可以使用基于日志的WAL、基于事件的Event sourcing等来实现可回滚。</li>
<li><strong>可禁用/自我保护</strong>：具有限流机制，当上游的流量超过自身的负载能力时，能够拒绝溢出的请求。可以通过手动开关或者自动开关（监测异常流量行为），在应用前端挡住流量。</li>
<li><strong>问题可追踪</strong>：当系统出现问题时，能够定位请求的轨迹、每一步的请求信息等。分布式链路追踪系统即解决的此方面的问题。</li>
<li><strong>可监控</strong>：可监控是保障系统能够稳定运行的关键。包括对业务逻辑的监控、应用进程的监控以及应用依赖的CPU、硬盘等系统资源的监控。每一个系统都需要做好这几个层面的监控。</li>
<li><strong>故障隔离</strong>：将系统依赖的资源(线程、CPU)和服务隔离开来能够使得某个服务的故障不会影响其他服务的调用。通过线程池或者分散部署结点可以对故障进行隔离。</li>
<li><strong>成熟可控的技术选型</strong>：使用市面上主流、成熟、文档、支持资源多的技术，选择合适的而非最火的技术实现系统。</li>
<li><strong>梯级存储</strong>：内存->SSD硬盘->传统硬盘->磁带，可以根据数据的重要性和生命周期对数据进行分级存储。</li>
<li><strong>缓存设计</strong>：隔离请求与后端逻辑、存储，是就近原则的一种机制。包括客户端缓存（预先下发资源）、Nginx缓存、本地缓存以及分布式缓存。</li>
<li><strong>异步设计</strong>：对于调用方不关注结果或者允许结果延时返回的接口，采用队列进行异步响应能够很大程度提高系统性能；调用其他服务的时候不去等待服务方返回结果直接返回，同样能够提升系统响应性能。异步队列也是解决分布式事务的常用手段。</li>
<li><strong>前瞻性设计</strong>：根据行业经验和预判，提前把可扩展性、后向兼容性设计好。</li>
<li><strong>水平扩展</strong>：相比起垂直扩展，能够通过堆机器解决问题是最优先考虑的问题，系统的负载能力也才能接近无限扩展。此外，基于<strong>云计算</strong>技术根据系统的负载自动调整容量能够在节省成本的同时保证服务的可用性。</li>
<li><strong>小步构建和发布</strong>：快速迭代项目，快速试错。不能有跨度时间过长的项目规划。</li>
<li><strong>自动化</strong>：打包、测试的自动化称为持续集成，部署的自动化称为持续部署。自动化机制是快速迭代和试错的基础保证。</li>
</ul>


<h2>架构六步思考法</h2>

<blockquote><p>笔者对美团总架构师夏华夏一次分享提出的架构六步思考法的理解。</p></blockquote>

<p><img src="http://www.rowkey.me/post_images/arch-six-think.png" width="450"/></p>

<h2>数据设计原则</h2>

<ul>
<li>注意存储效率

<ul>
<li>减少事务</li>
<li>减少联表查询</li>
<li>适当使用索引</li>
<li>考虑使用缓存</li>
</ul>
</li>
<li>避免依赖于数据库的运算功能(函数、存储器、触发器等)，将负载放在更容易扩展的业务应用端</li>
<li>数据统计场景中，实时性要求较高的数据统计可以用Redis；非实时数据则可以使用单独表，通过队列异步运算或者定时计算更新数据。此外，对于一致性要求较高的统计数据，需要依靠事务或者定时校对机制保证准确性。</li>
</ul>


<h2>系统响应性能提升五板斧</h2>

<ul>
<li><strong>异步</strong>：队列缓冲、异步请求。</li>
<li><strong>并发</strong>：利用多CPU多线程执行业务逻辑。</li>
<li><strong>就近原则</strong>：缓存、梯度存储。</li>
<li><strong>减少IO</strong>：合并细粒度接口为粗粒度接口、频繁的覆盖操作可以只做最后一次操作。这里一个需要特别注意的地方: <strong>代码中尽量避免在循环中调用外部服务，更好的做法是使用粗粒度批量接口在循环外面只进行一次请求。</strong></li>
<li><strong>分区</strong>：频繁访问的数据集规模保持在合理的范围。</li>
</ul>


<p><img src="http://www.rowkey.me/post_images/book-all.png" width="400"/></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何学习后端技术？]]></title>
    <link href="http://www.rowkey.me/blog/2018/04/13/how-to-study-tech/"/>
    <updated>2018-04-13T19:29:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2018/04/13/how-to-study-tech</id>
    <content type="html"><![CDATA[<p>学习后端技术和学习其他的技术并没有什么大的不同。因此，题目换做如何学习技术也是讲的通的。概括来讲，有以下几点建议：</p>

<ul>
<li>扎实的计算机基础知识</li>
<li>知其然更要知其所以然</li>
<li>动手实践</li>
<li>频繁练习</li>
<li>持续学习</li>
<li>自我总结</li>
<li>学会规划</li>
</ul>


<!--more-->


<h2>扎实的计算机基础知识</h2>

<ul>
<li>数据结构和算法：程序是由数据和算法组成的，因此这两个东西是计算机软件的基础。诸如B树、哈希表、栈以及七大排序算法、查找算法这些，在很多软件的代码中都可以看得到。有时候，一个优秀的工程师和一个普通工程师的区别也就在于是否能够合理使用合适的数据结构和算法。</li>
<li>计算机操作系统：操作系统可以说是集大成于一身的一个软件程序。资源调度、任务调度、IO调度、进程通信等等，每一个设计都是很精华的，也是很多其他应用软件设计的思想来源。</li>
<li>计算机网络：目前只要有数据传输功能的程序绝大多数都是离不开网络的。网络七层或者四层协议栈的设计非常精妙。了解网络连接如何建立、断开以及每个连接状态的意义都有助于对程序网络问题的排查。</li>
<li>计算机组成原理：这是计算机最底层的设计，也是计算机一切的基础。了解这些有助于消除你对计算机的神秘感，毕竟符合冯诺依曼原理的计算机无非就是存储数据、程序按序运行。</li>
</ul>


<p>以上是计算机专业的一些比较普遍的基础知识课程。这里不得不说的一点是，虽然现在各大高校的计算机专业课程是比较落后的，但是这些基础课程，由于多少年也没有怎么变过，因此不管怎样都是需要扎实掌握的。也许上学的时候你感觉不到有多大的用处。但是进入实际的开发工作中，是否能够掌握扎实的基础知识往往决定了一个开发工程师的上限，这也是很多大的互联网公司无论是校招还是社招，都侧重于一些底层知识考察的原因。毕竟，你会使用什么东西只能决定你的下限，而你的基础知识和学习能力才决定了你的上限。</p>

<p>此外，其实很多平时开发中的一些技术都可以类比到一些基础知识的。比如，我们经常为了提高查询性能而使用的缓存技术，和为了兼容CPU和IO速度不匹配的而设计的CPU Cache就是同样的东西；操作系统中的进程间通信方式和服务之间的异步同步通信也是差不多的道理。诸如此类，其实计算机科学基础凝聚了很多精华的设计，无论是计算机硬件架构、计算机操作系统还是计算网络。</p>

<h2>知其然更要知其所以然</h2>

<p>经常遇到来面试的工程师，他们简历上写了很多项目，也用过很多技术，怎么看都是非常不错的候选人。但是面试一旦深入到原理或者是优化层面，很多工程师甚至是一些公司的资深架构师都会支支吾吾，答非所问或者说是没关注过。听到最多的解释就是业务压力太忙，没有时间去研究这个。其实，自我经历来看，业务忙是原因，但是没有时间却肯定是借口，毕竟阅读一个项目的源码虽然比较耗费时间，但是去网上看看已有的原理分析其实是花不了太多的时间的。归根结底，还是没有一种知其然更要知其所以然的基本意识。很多东西，你学会了使用会很兴奋，但是你有没有想过这么兴奋的功能是如何实现的呢？最简单的例子，Java中的HashMap，大家都在用，但是他到底是怎么实现的呢？很多人甚至都不知道这和数据结构课程上的哈希表是什么关系，更别说让他说出解决冲突的方式了。</p>

<p>这也可以映射到现在的一种现象：很多开发工程师工作了很久，看着经验丰富，但基本都是拿着一年的工作经验重复n年的。基本上每一份工作，每一个项目都在那里做重复劳动，而且也并不去考虑如何避免重复劳动这件事。</p>

<p>进一步的，除了遇到问题再去看源码、究底层，主动阅读经典类库、高质量开源项目的源码以及其他同事写的代码，学习其中好的架构、设计、编码风格以及类库的使用也是促进自身技术进步的一个非常有效的方式。</p>

<p>这也牵扯到了技术的广度和深度的问题。就我自己来看，对于刚刚毕业或者刚刚入职的工程师来说，首要的是深度问题，只有你在某一领域有了深入的研究和造诣了，你才能融汇贯通，迅速地扩大自己的知识面，在广度上做到突破。而对于有一定工作经验的工程师来说，虽然深度不是那么必须了，但是遇到的问题、新学到的东西还是刨根问底才好，否则一旦出现问题再去盲羊补牢会让你显得非常被动，也不利于自己的技术发展。毕竟，一个什么都做过、什么都用过却什么也不精的人可替代性太强了。</p>

<h2>动手实践</h2>

<p>学习领域有所谓721模型：个人的成长70%来自于岗位实践，20%来自向他人学习，10%来自于培训。虽然这种理论存在争议，但在笔者看来对于程序员来说按照实践、学习和培训的方式进行重要性排序是合理的。普遍公认的一种学习技术的最佳实践-“项目驱动型学习”，也就是这里说的动手实践。很多技术，只是看书，你会云里雾里，看了就忘。必须要经过你自己的实践或者项目中使用到了这种技术，你才能很快地掌握并熟练。此外，现在朋友圈、微博上都充斥各种所谓干货，很多人阅读大量的资料自以为收货满满，其实对于里面的东西根本就没有去实践过。甚至有时候就是感叹一下别人真厉害而已。真正的干货是需要自己消化的，消化的一种最好的模式就是实践，无论是对资料中的例子还是一笔带过的知识。</p>

<h2>频繁练习</h2>

<p>动手实践能够让你快速入门，但只有频繁练习才能让你熟练使用。</p>

<p>“一万小时”理论讲的是任何一个行业都至少需要一万小时的实践才能成为专家。先不去争论此理论是否正确，可以想想当你长时间不写代码或者不用某个技术后你再去做相关的开发，那种生涩陌生感想必是每个人都有体会的。可见对于研发这个角色，频繁练习是有多么的重要。</p>

<p>当然，这里的频繁练习并非指的重复劳动。应该是带着自己的思考去练习，多去想一下为什么这么做？有没有更好的方式？</p>

<h2>持续学习</h2>

<p>“活到老，学到老”这句话用在程序员这个职业上再合适不过。IT技术尤其是互联网开发中的技术，其迭代是非常迅速的。也许你今天学的，过不了几年就成了被抛弃的。虽然相比起前端技术，后端技术算是比较稳定的，但相比起其他行业，迭代速度还是非常快的，像Struts这种当年火的一塌糊涂的技术现在也成了过时的东西。因此，一定要对新事物、新技术具有敏感性，要不断地去涉猎业界最新的知识点，扩充自己的知识库。而学习新的知识的时候，与读一些书籍和网上的博文相比，直接阅读相关知识的官方文档是笔者推崇的方式，毕竟经过二次加工的书籍、博文很多时候由于写作者水平或者个人理解的问题会有错误或者偏离原作者的意思。而由于目前IT技术绝大多数都是源自欧美，欧美的技术水平也领先国内很多，因此英文对于IT技术从业者的要求也是比较高的，需要达到熟知各种计算机术语，通畅地阅读各类英文资料的水平才不至于在学习方面落后。</p>

<p>这里还需要提到一点就是要“逃离舒适区”。人对自己熟悉的东西都比较亲切，对自己熟练掌握的技术一般也能够自信地使用，然而当需要使用自己没接触过的技术时，很多人就望而却步、不敢尝试，进而也就丧失了学习新的知识、扩充自己知识库的机会。最好的方式应该是敢于“逃离舒适区”、敢于使用新的技术，这样才能让自己具有持续的学习兴趣，促进自己的持续进步。</p>

<h2>自我总结</h2>

<p>相信很多人在平常的工作中，经常会遇到一些问题，然后通过查阅网上资料、询问同事、翻看源码等手段解决了，当再次遇到类似的问题甚至是相同的问题时，还是一头雾水。先不提记忆力的问题，造成这种情形的很大一个原因就是没有去总结。当然，这里的总结不仅仅指的是把你平时遇到的问题记录下来，更深一层的是要找到问题发生的本质原因，如何避免发生同样的问题，从中有什么启发和收获。再进一步的则需要经常将自己一段时间内的知识收获组织成体系或者融入到自己的知识体系中，这样才能举一反三，遇到相同的问题可以有据可循。</p>

<p>而自我总结的方式包括记笔记、写博客、做分享。其中，比起记笔记来说，写博客、做分享是笔者更为推荐的方式。毕竟，和别人交流一方面能促使你对总结质量的把控，另一方面分享知识给别人带来的“荣誉感”反过来会产生某种正向反馈让你更加乐于总结和分享。</p>

<h2>学会规划</h2>

<p>平时和不少工程师聊过关于职业规划的事情，其中有些人对自己的职业道路有很清晰的认识，但更多的则是没有任何概念，只是觉得能挣钱养家就好。很明显前者是属于有规划的人，对于这种人来说，其努力是有目标的，因此走的路也会更踏实，更具有可持续性。</p>

<p>对于研发职位来说，学会规划是一个很关键的特质。而规划可以分为长期规划和短期规划。上面说的职业规划就是一种长期规划，需要高瞻远瞩的定下自己前进的方向。如在五年内成长为一个后端服务架构师就可以看做一个长期规划。笔者自己的长期规划如下：</p>

<ul>
<li>35岁之前只做能提高自己技术水平的事情，能够成为公认的某一个技术领域的专家。</li>
<li>绝不为了钱加入自己并不认同的企业或者团队。</li>
</ul>


<p>而对于短期规划来说，则是一些具体技能、晋升、学习方面的规划。如，笔者近一年的学习计划包括：</p>

<ul>
<li>学习机器学习技术，能够成为“调参工程师”。</li>
<li>加强自身的管理技能，能够带领部门有好的业绩。</li>
<li>完成《增长黑客》、《分布式系统概念与设计》等十本书的阅读。</li>
</ul>


<p>需要注意的是，对于这些短期规划，要设定的比较合理，具有可达性，也要设定好优先级，根据优先级逐步去完成。此外，规划不要定死，可以根据实际情况灵活调整。</p>

<h2>如何学习一门新技术</h2>

<p>上面主要讲述了宏观层面的如何学习技术，而具体到学习某一个新技术，其实也是有法可循的。如下图所示：</p>

<p><img src="http://www.rowkey.me/post_images/howtostudy/15127185777816.jpg" alt="" /></p>

<p>由于很多技术的模块非常多，源码也非常复杂，很多时候在看源码的时候会陷进去越看越不得章法，因此这里着重说明一下“看源码”的一个典型流程：</p>

<ol>
<li>阅读该技术的架构文档，了解其总体架构和组成。</li>
<li>根据总体架构，将源码文件以模块或者上下层级进行分类。</li>
<li>从未阅读过的模块中选择最独立（依赖性最小）的模块代码读起。</li>
<li>阅读此模块的功能介绍文档。</li>
<li>阅读此模块的源代码。</li>
<li>一边阅读一边整理调用关系（以表或者树的形式）。</li>
<li>转到第三步。</li>
</ol>


<h2>总结</h2>

<p>程序员是一个金字塔结构的职业体系，越往上，人越少也越难达到。如下图所示：
<img src="http://www.rowkey.me/post_images/howtostudy/15022677629156.jpg" alt="" /></p>

<p>一步步走到金字塔顶部需要不断的学习和进步，包括正确的态度、正确的方法以及持续的努力。本文所述只是笔者自己的体会，也是自己一直在践行的东西。除此之外，肯定还有很多其他优秀的方法和思想能够促进这个过程。</p>

<blockquote><p>本文节选自《Java工程师修炼之道》一书。</p></blockquote>

<p><img src="http://www.rowkey.me/post_images/book-all.png" width="400"/></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何成为一名合格的Java工程师?]]></title>
    <link href="http://www.rowkey.me/blog/2018/04/01/pje-release/"/>
    <updated>2018-04-01T19:29:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2018/04/01/pje-release</id>
    <content type="html"><![CDATA[<p>Java开发一直是当前互联网领域最火热的开发技能之一，Java工程师也一直是需求量非常大的开发职位。那么如何成为一名合格的Java工程师呢？一名合格的Java工程师又应该具有哪些技能呢？针对这些，笔者的新书《Java工程师修炼之道》做了一些经验性的阐述和讲解。</p>

<p><img src="http://www.rowkey.me/post_images/book.png" width="250"/></p>

<!--more-->


<p>写作此书的想法萌生于2015年，主要是在研发招聘过程中，尤其是校招，感受到了目前后端工程师教育的匮乏。对于一个后端工程师的技术体系，先不说学生，不少工作很长时间的人都没有一个清晰的认识。就打算写一本后端工程师技术体系书籍的想法，希望能够给选择后端这个方向的人一些指导，也算是对自己的一个阶段性总结。</p>

<p>2016年初，博文视点“永恒的侠少”（张春雨编辑）找到我，算是正式开始写作此书。历时一年多的时间，于2017年8月份交稿，中间历经许多次修改，《Java工程师修炼之道》终于出版。这本书是自己出的第一本书，所以写作的过程一直是如履薄冰的，一直害怕写成一本没有任何意义的烂书，因此一遍遍地去读，一遍遍地修正，也一遍遍地更新一些知识点，希望最后不要沦为一本鸡肋无味的技术书。</p>

<p>本书主要针对一名合格的Java工程师的必备技能做了大纲性的总结和阐述。内容主要来自于公司内的后端工程师学习计划、自己以前的一些博客文章和自己从业以来积累的知识库。包括了工程化、常用开发框架、数据存储、数据传输、Java编程高级知识、性能优化、安全技术等，基本涵盖了Java工程师需要掌握的绝大部分技能点。</p>

<p>本书可以看作一本Java工程师的入职指南，也可以看作一本串联Java后端技能点的参考手册，同样可以作为创业团队做技术选型的一个参考。通过精心编排的内容，刚入门的Java工程师能够体系化地学习相关开发技能，有经验的Java工程师则能够查漏补缺，进一步加强自身的Java技术体系。</p>

<p>其中的部分内容，会陆续在我的博客和公众号放出。</p>

<p>希望这本书会给想要学习Java后端开发的同学或者还未形成自己技术体系的Java工程师们带来帮助。</p>

<p><strong><em>需要注意的是，本书关于每一技能的知识点并没有讲述的很深，毕竟一方面确实没必要，每一个知识点都有更厉害的专家和更专业的书籍；另一方面，要面面俱到，这本书的厚度估计得翻三倍，自己确实没这精力。因此，本书并不适合对内容深度有要求的同学。</em></strong></p>

<p><strong>购买</strong>: <a href="https://item.jd.com/12325207.html">https://item.jd.com/12325207.html</a></p>

<p><img src="http://www.rowkey.me/post_images/book_jd.png" alt="" /></p>

<p><strong>目录</strong></p>

<blockquote><p>第一章 后端技术导言</p>

<p>1.1 后端基础设施</p>

<p>1.2 Java后端技术概览</p>

<p>1.3 如何学习后端技术</p>

<p>第二章 Java项目工程化</p>

<p>2.1 项目构建</p>

<p>2.2 代码版本控制</p>

<p>2.3 代码质量保证</p>

<p>第三章 开发框架</p>

<p>3.1 依赖注入</p>

<p>3.2 对象关系映射</p>

<p>3.3 日志</p>

<p>3.4 Web MVC</p>

<p>第四章 Spring</p>

<p>4.1 Spring核心组件</p>

<p>4.2 Spring数据操作框架</p>

<p>4.3 Spring Boot</p>

<p>4.4 Spring常用组件</p>

<p>4.5 总结</p>

<p>第五章 数据存储</p>

<p>5.1 关系型数据库-MySQL</p>

<p>5.2 非关系型数据库</p>

<p>5.3 缓存</p>

<p>5.4 搜索引擎-Elasticsearch</p>

<p>第六章 数据通信</p>

<p>6.1 RESTful架构风格</p>

<p>6.2 远程过程调用-RPC</p>

<p>6.3 消息中间件</p>

<p>第七章 Java编程进阶</p>

<p>7.1 Java内存管理</p>

<p>7.2 Java网络编程</p>

<p>7.3 Java并发编程</p>

<p>7.4 Java开发利器</p>

<p>7.5 Java新版本特性</p>

<p>7.6 总结</p>

<p>第八章 性能调优</p>

<p>8.1 调优准备</p>

<p>8.2 性能分析</p>

<p>8.3 性能调优</p>

<p>第九章 安全技术</p>

<p>9.1 Java加密</p>

<p>9.2 安全Http - HTTPS</p>

<p>9.3 Web安全</p></blockquote>

<p><strong>推荐</strong></p>

<blockquote><p>2013年，我和本书作者的接触是从基于网易的一个大型互联网应用合作开始的，我见证了从第一行代码到整个系统服务于亿级用户的过程，并且相信这种经历对开发者来说是一笔巨大的财富，其中大量的开发和实战经验都会在本书中得到充分的体现，相信读者能从书中直接领略到丰富的实战知识。在与本书作者的合作过程中，其对Java技术的热爱与追求孜孜不倦，对问题刨根问底，直到理解透彻、灵活应用，这些都令我印象深刻。这些年，我与本书作者一直保持沟通交流、相互学习，他将近十年的实战经验沉底于本书以实现对后端技术的探索、布道，非常值得开发者与近高窗卧听秋。</p>

<p>后端技术涉及内容非常广泛，Java语言也是互联网开发行业使用的主流语言，相信后续也将继续流行很长一段时间，而本书作者也一直从事Java后端开发工作。在本书中作者比较系统地从总体上描述了后端技术相关的理论知识，包括基础设施、网关服务及框架选型等基本原则，然后以实际经验进行示例说明，接着详细梳理了Java的后端技术，相信读者读完本书后会更全面地理解后端技术。互联网的业务建设需要不同角色的开发者共同协作完成，因此，系统工程化是开发者首先要共同遵守的规范或约定，包括代码规范、版本管理和代码质量检查等。</p>

<p>开发框架的选型进一步地为工程化提供了基础，也能加速推进互联网开发，尽管是否重复造轮子是一个恒久的话题，但是没有永远的银弹，只要在合适的时间里根据团队的能力选择合适的技术框架就好。一般来讲，目前常用的框架包括基本的依赖注入、AOP、事务管理、连接池管理、数据操作、日志服务等，在众多的框架中，本书作者选用目前在Java领域使用最广泛的Spring做深入的分析，详细地说明各组件的基础知识、基本原理和实际使用案例，最难得的是把较多开发者遇到的坑都用真实的示例进行了说明，可以帮助开发者快速地跳过这些伤心地带，同时也把最佳实践画龙点睛地带给开发者。</p>

<p>数据存储无疑是所有系统应用中非常重要的一环，应用的场景用例也和数据库的选型有极其重要的关系，开发者选择关系型数据库还是非关系型数据库是需要根据软件成本与人力成本来进行权衡的，比如是选择MySQL、Oracle等开源或商业的数据库。本书重点从数据库的基础知识、索引和表优化等方面以详尽的示例为更好地选择数据库的存储类型提供了更多的知识。</p>

<p>早期的关系型数据库一般能满足数据达到一定规模的企业的需求，而在互联网业务领域，特别是移动互联网领域内的元数据或者日志数据等，达到亿数量级别是很常见的，这时通常使用非关系型数据库，在非关系型数据库里使用非常多的有MongoDB、HBase等分布式数据库系统。作者在自身的企业开发实践中，得到了大量的使用经验和最佳实践。为了加速后端应用，缓存热数据是加速业务、提高业务性能、提升用户体验的重要手段，通过使用本地缓存、远程缓存进行数据加速、数据预热或提高数据的命中率，是开发者在应用开发的过程中常会遇到的场景。</p>

<p>“路漫漫其修远兮，吾将上下而求索”，后端技术每年都在不断发展，所用技术也有变化，近些年Java语言的发展速度不那么快了，但是总体是在不断前进发展的，本书作者带领的团队一直深耕此领域并希望通过本书为技术开发人员带来更多帮助。</p>

<p>&ndash; <strong>尧飘海，网易云基础服务（蜂巢）首席架构师</strong></p></blockquote>

<hr />

<blockquote><p>Hey！新来的读者，为了吸引你的注意力我真是煞费苦心，但最终还是没能写出一句特别吸引眼球的话来，毕竟写序的我不是标题党出生。此刻我真的非常能理解你拿到新书之后那渴望知识的心情，所以你恨不得一个字的“序”也不要看到，直接到达“最有价值”的知识点。但作为一名资深转业码农（对！你没看错，是“转业”，不是“专业”）还是想说一句，你先看完序，5分钟后到达知识的战场，会更稳！</p>

<p>相信你已经在看“序”了，那么我们来说点正经事。</p>

<p>你的知识体系的养成有3个关键阶段：看山是山、看山不是山、看山还是山。本书的适用人群是“看山不是山”的那些人，如果你恰好处于这个阶段，恭喜你！书钱没白花。</p>

<p>Java是一门非常容易入门的语言，初学者经过初期的学习之后基本能掌握DEMO级别的编程应用。相信读者你已经度过了这个阶段，但是Java庞大的体系可能会把你绕晕，又或者你还没看到Java的生态系统有多么复杂。此时，你需要本书。从事程序员这个工作，到比较高阶的时候，其实是不挑语言的，语言只是工具，而你可以在纷繁复杂中游刃有余。但几乎每一位高手都是先深入一个领域，再横向发展的。你可以不用着急后续的横向发展，先坚定自己学习Java的信心！因为，从广泛的应用场景、顶级的开源生态、未来可期的薪水和职位来说，Java都是非常不错的选择。</p>

<p>敲黑板，画重点！下面来解释一下，为什么本书面向的是“看山不是山”的人群。在度过Java的入门期之后，会有一个烦恼，那就是面对Java这么庞大的体系，我们究竟应该学习什么？选择方向，往往比努力更重要！是使用J2SE编写桌面程序？是使用J2ME编写嵌入式应用？还是使用J2EE编写企业级应用？这些是我们那个泛黄的年代特有的烦恼。而现在的烦恼可能是学Android？还是学Java后端？即便大方向你已经十分坚定，而且选择了Java后端编程，但因为复杂的知识体系和Google发布的各种教程文档，眼前看到的已经不再是清晰的山脉，而是一片迷雾。此时，你需要本书，因为它给你指明了努力的方向。</p>

<p>本书的结构、阐述的方式和大部分的“指南”书籍有较大的区别，本书是以笔记和要点的形式进行呈现的，用现在的话说就是捞干货。本书涵盖的知识，是以现代工程实践中的实际案例出发来组织的，所以知识点范围非常广泛，每一个点都对最关键的“Best Practice”简明扼要地进行了说明。你在阅读本书的时候需要一些相关经验，不然无法跟上作者的节奏，建议在有一定的知识准备后再阅读本书，这样你会受益匪浅。从另外一个角度看，在你有了一定的基础积累之后，本书可以帮助你全面地了解一个现代化的最先进的工程实践是怎样的。本书讲述了目前行业中最常用的，经过了实践的工程方案，这将是你快速进阶的最佳指引。</p>

<p>&ndash; <strong>孙建，随身云（中华万年历）联合创始人&amp;CEO</strong></p></blockquote>

<hr />

<blockquote><p>扎实的基础理论知识是内功底子，丰富的实践经验是招式。如本书作者所说，精妙的招式决定了你的武功下限，而深厚的内功底蕴会承载你所能企及的高度。那么，在后端技术栈中，内功与招式之间如何去关联起来，本书作者以其多年的钻研与实践结合心得，通过本书为你一一梳理。</p>

<p>&ndash; <strong>阙杭宁，网易云信CTO</strong></p></blockquote>

<hr />

<blockquote><p>作者是一位技术人,有多年的Java技术积累,是极少数真正热爱技术的人。在随身云架构师的工作让他有机会站在更高的层次进行系统架构的工作,这些实践经验和平时感悟都沉淀在作者的著作和博客中,相信每位Java工程师都能从中获取帮助。</p>

<p>&ndash; <strong>秦绪震，十露盘科技联合创始人，技术负责人</strong></p></blockquote>

<hr />

<blockquote><p>本书作者根据自身多年的JAVA后台开发经验, 提纲挈领的总结JAVA后台开发的各个关键技术点，这些知识点都是一个合格的JAVA工程师必须掌握的技能。它既可以作为新人的技术学习指南，也可以帮助老手对于自己的知识面进行查漏补缺，是一本非常好的技术指南。</p>

<p>&ndash; <strong>饶洵（蜚天），阿里巴巴技术专家</strong></p></blockquote>

<hr />

<blockquote><p>作为一个在后端摸爬多年的Java开发工程师，这本书让我温故而知新。书中介绍的Java相关的知识技能树，不仅涵盖了我个人多年的Java开发技术知识点，也对我所陌生的一些知识点进行了详解，让我突然有一种继续学习的冲动。</p>

<p>一个Java开发工程师的成长，不仅要对Java语言及其特性有深层次的理解，也需要掌握与Java相关的框架、生态及后端开发知识。这本书正是将后端开发工程师需要掌握的技能做了总结，对于提高开发技能有很好的指导作用。</p>

<p>我推荐这本书，对于具有一定Java基础和后端开发知识的读者来说，该书不仅具有仔细学习的价值，同时也是一本可以经常翻阅的工具书籍，对于Java开发工程师的成长和进阶有很大的指导作用。</p>

<p>一本好的技术书籍，不仅要仔细阅读、学习理解，还需要进行较多的实践，将所看所学进行应用，通过不断地实践，加深知识点印象，从而形成永久的记忆和技能。希望各位读者能够通过掌握书中的知识和技能，逐步成长为技术骨干和专家，从而创造更多的技术输出、产品输出，创造更多的财富。</p>

<p>&ndash; <strong>张小川，网易考拉海购架构师，供应链技术主管</strong></p></blockquote>

<p><strong>后续计划</strong></p>

<blockquote><p>此书一开始是计划有一章专门讲述大数据开发技术，毕竟现在越来越多的公司在构建自己的大数据平台，大数据技术也逐渐成了Java工程师的必备技能。但自己此方面经验较少，自认并没有达到可以向别人输出知识的程度，于是暂时搁置此部分。</p></blockquote>

<p>逐步把部分内容开源在笔者的<a href="https://github.com/superhj1987/pragmatic-java-engineer">Github（superhj1987）</a>中，并补充一些新的内容进来。</p>

<ul>
<li>Zookeepr本来是想放在大数据一章，现在会作为数据存储的一节补充进来。</li>
<li>异步响应式Web框架会补充在开发框架一章，以Vert.x为主，Spring Flux为辅。</li>
<li>Redis加入新版本的特性，并补充如何使用Redis实现分布式锁。</li>
<li>Kafka加入最新版本的特性，尤其是Kafka Streams和Exactly one语义。</li>
<li>Elastissearch基于5.0版本更新。</li>
<li>补充协程到并发编程中。</li>
<li>补充Netty到网络编程中。</li>
<li>使用Hystrix做资源隔离和限流会补充在Java开发利器中。</li>
<li>补充RxJava的使用在Java开发利器中。</li>
<li>补充Java10和Kotlin的部分到Java新版本特性。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[浅析区块链]]></title>
    <link href="http://www.rowkey.me/blog/2018/03/15/blockchain/"/>
    <updated>2018-03-15T19:29:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2018/03/15/blockchain</id>
    <content type="html"><![CDATA[<p>从去年开始，区块链突然如火如荼起来，相关的新闻席卷微博、朋友圈、科技论坛、门户网站等各大媒体。业界大佬们更是频频发言，有宣称不做区块链就会被时代淘汰的，有说坚决不碰区块链的。国家队也是频频出手，管制、定性、做应用，央行更是默默地把区块链专利数量做到了世界前列。面对众多纷杂的信息、众多的技术分析文章，很容易让人脑袋嗡嗡，怕不懂，更怕懂了啥也都做不了。于是决定梳理一下相关的信息，看看这区块链到底是什么东西。</p>

<p>开篇之前，先抛出笔者的一个观点：<strong>区块链最合适的应用场景只有虚拟资产,除了虚拟资产的其他场景都是在蹭概念或者不是真正意义上的区块链，而且只要有人参与的业务流程都无法满足区块链设计的初衷。</strong></p>

<!--more-->


<h2>区块链是什么</h2>

<p>说到区块链，需要先了解其产生的背景，这样才能理解为何如此设计区块链。区块链的出现是和“暗网”相关的。所谓“暗网”与我们常见的“互联网”相比，只有通过特殊的软件才能够访问，并且在暗网上基本都是些黑市交易，无法见光，参与这些交易的人都不想暴露真实的位置、个人信息。应对这种交易需求，才出现了比特币。所以说，区块链一开始是为了解决匿名交易的问题出现的，也就是比特币。这也是区块链的第一个阶段，即一套账本体系和货币发行机制；后来基于区块链技术，出现了以太坊，在改进比特币区块的基础上加入了智能合约机制，称之为区块链2.0；以太坊之后，类似以太坊的一些扩展应用，能够对于每一个互联网中代表价值的信息和字节进行产权确认、计量和存储，能够扩展到几乎任何领域，这是区块链的第三个阶段，区块链将完成价值的交换。目前处在区块链2.0阶段。</p>

<p>其实从本质上看，区块链和Git类似，每个节点都有一份数据的存储，不同的是区块链没有中央服务器这么个概念，就是一个分布式无中心数据库，其有效的通过数学的方式在数据库没有管理员的情况下对内容达成一致，并且不通过正式工资或是分得股权就能奖励那些帮助使数据库变得更有价值的人们，最终能够实现无争议无抵赖的匿名交易。概括来看，其特点如下：</p>

<ul>
<li>去中心化：互联网本来的意义就是平等开放，所以有一种言论就是区块链是回归互联网本来意义的希望。这一点是区块链天然的优势，所有节点都存有数据的副本即实现了“去中心化”。</li>
<li>无法篡改: 得益于区块之间的链式结构，可以保证数据无法篡改或者篡改的成本远大于收益。</li>
<li>公开透明：每个节点保存的信息相同，能够消除信息不对称，实现信息透明。</li>
</ul>


<p>与传统的关系型数据库用一张表或者多张独立的表存储数据，“区块链”使用多个“数据表”并且多个“数据表”形成前后衔接的链式结构，以防止数据被篡改（修改任何一个区块就破坏了链式结构）。总体的结构如下所示：</p>

<p><img src="http://www.rowkey.me/post_images/blockchain/bc.jpg" alt="" /></p>

<p>其中每一个“数据表”在区块链中被称为“区块”。格式如下：</p>

<p><img src="http://www.rowkey.me/post_images/blockchain/block.jpg" alt="" /></p>

<p>这是区块链技术基本都具有的一些头部信息，包括4字节的版本号、32字节的上一个区块的哈希值、32字节的Merkle根、4字节的时间戳（当前时间）、4字节的难度目标以及4字节的随机数。</p>

<ul>
<li>版本号：用于跟踪软件/协议的更新。如果新版本的软件不兼容旧版本的软件，那么就认为是发生了“分叉”。</li>
<li>上一区块头哈希值：存储的是链上上一个区块的哈希值，也是区块链设计的精髓所在。</li>
<li>Merkle根：又叫做梅克尔根，是一种用于完整性证明的数据结构，为了能够在区块头中体现出交易而做的一个计算，同时也是为了解决交易记录进行Hash计算的效率问题。</li>
<li>时间戳：该区块产生的近似时间。这个时间虽然是节点生成的但是其是否有效需要其他节点的认可（允许有一定程度的误差）。时间戳使得交易有先后，是防范双重支付攻击的一个关键设计。</li>
<li>难度目标：该区块工作量证明的算法的难度系数。系数越大，目标哈希值的0越多，计算的难度呈指数增长。</li>
<li>Nonce: 用于工作量证明算法的计数器。</li>
</ul>


<p>区块体的信息主要是交易列表。交易的数据结构因平台的不同而不同。比特币中就是简单的交易信息，以太坊则会存放智能合约。这里需要提到的是比特币中使用UTXO（未花费的交易输出，Unspent Transaction Output）实现支付系统的账户模型，并没有余额、钱包的概念，交易列表中的关键信息也是一些UTXO的组成,如此计算账户的余额则需要通过遍历整个交易历史来最终计算出每个账户的余额。UTXO的示例如下图所示：</p>

<p><img src="http://www.rowkey.me/post_images/blockchain/utxo.png" alt="" /></p>

<p>可见除了coinbase这种交易之外，其他的交易都至少有一个交易的输入且必须引用一个输出，而一笔交易的输入可以引用之前多笔交易的输出。此外，任何一笔交易的交易输入总量必须等于交易输出总量（支出与找零）。其一般结构如下：</p>

<p><img src="http://www.rowkey.me/post_images/blockchain/utxo-struct.png" alt="" /></p>

<p>使用UTXO的优势如下：</p>

<ul>
<li>私密性比较强，理论上可以为每一笔输出设置一个地址。</li>
<li>无需维护余额等状态值。</li>
<li>UTXO是独立数据记录，可以通过并行极大的提升区块链交易验证速度。</li>
<li>无需关心事务问题，只需要关心输出脚本即可。</li>
<li>能够清理过期交易，回收存储空间。</li>
</ul>


<p>而以太坊则使用了传统所理解的账户模型，主要是因为UTXO无法支持图灵完备的智能合约实现。</p>

<p>此外，还需要说一下“块高度”的概念。区块链网络的创世块（第一个区块）的块高度为0，如此每增加一个区块高度就+1，如第一个图所示，如果最左侧的块为创世块，那么最后一个区块的块高度就是2。</p>

<h2>区块链典型流程</h2>

<p>以<strong>比特币</strong>为例，区块链的一个典型交易流程：</p>

<ul>
<li>新的交易向全网所有节点广播，交易信息包括发UTXO输入、UTXO输出等关键信息。这里一个交易并不需要抵达全部的节点。只要交易信息能够抵达足够多的节点，那么他们将很快被整合进一个区块中。</li>
<li>每一个节点都将收到的交易信息经过验证无误后（使用解锁加锁脚本自动化验证）纳入一个区块中（被打包到块之前这些交易被存储在内存池中）。</li>
<li>每一个节点都尝试根据最新的区块的信息找到一个具有足够难度的工作量证明。</li>
<li>当一个节点找到了一个工作量证明，就创造一个新的区块（将接收到的交易纳入其中），并向全网进行广播。</li>
<li>当且仅当包含在该区块中的所有交易都是有效的且之前未存在过的，其他节点才认同该区块的有效性。</li>
<li>其他节点表示他们接受该区块，而表示接受的方法，是在跟随该区块的末尾制造新的区块以延长该链条，将被接受区块的随机散列值做为新区快的Prev随机散列值。</li>
</ul>


<h2>区块链技术架构</h2>

<p>其实从本质来看，区块链不能算是一个新的技术，更应该看做是一个新的技术框架，是基于很多成熟的技术而成的，而且不仅仅是技术，还有金融学，货币学，博弈学等。其技术架构如下图所示：</p>

<p><img src="http://www.rowkey.me/post_images/blockchain/arch.jpg" alt="" /></p>

<p>其中，区块的链式结构、UTXO以及智能合约是比特币发明人“中本聪”的原创发明。</p>

<h2>存储</h2>

<p>区块链在每一个节点会存储数据，并且需要持久化存储，存储方式和传统的应用一样，包括数据库和文件系统。</p>

<p>对于存储方式的选择, 区块链中并没有做相关的规定，而比特币和以太坊都使用LevelDB做为持久化存储方式。</p>

<h2>通信机制</h2>

<p>区块的通信是基于P2P技术,即不区分客户端和服务端的网络，和P2P下载是类似的原理。在区块链中其功能点包括：</p>

<ul>
<li>把需要存储的数据广播到所有节点上进行储存，也就是多播。</li>
<li>查询整个网络集群中所有节点的最新数据，如果自己节点的数据与大部分节点的数据不一致，则更新自身的数据与大部分节点存储的数据一致。这个功能也是防止数据被篡改的一个很重要的机制，是区块链核心的一个原则“少数派服从多数派”。当然这个也会引起51%攻击的问题。但区块链使用其他的机制极大杜绝了这种风险，下文会提到。</li>
</ul>


<h2>安全机制</h2>

<p>区块链同样使用了很多成熟的安全技术来保障其特点。</p>

<ul>
<li>哈希算法：⽤来对⼀段数据进行计算，得出⼀个摘要信息，通俗点说就是给一段数据⽣成⼀个固定大小的身份ID, 且其是不可逆的。区块链使用哈希做工作量证明、交易ID生成、区块之间的关联等。此外，区块头中的Merkle Root也是使用哈希算法做完整性证明的（比特币中使用double-SHA256哈希算法）。常用哈希算法包括MD5、SHA1、SHA256等。</li>
<li>数据加密：区块链使用了非对称加密算法。比特币中的钱包地址本质就是一对公钥私钥。此外，区块链利用公钥哈希加锁比特币的输入记录，阻止输出。</li>
<li>数字签名：同样基于非对称加密技术，用签名和公钥解锁自己的比特币输入记录，使用比特币。</li>
<li>零知识证明：所谓零知识证明即在不知道答案的情况下去验证给出的答案是否正确。这个过程完全靠机器验证，机器根据题目给出随机试验以验证答案是否正确。在某些区块链应用中如Zcash\ZCoin即使用了零知识证明来保证交易双方和交易金额的匿名性, 提供了绝佳的支付隐私。详细可见：<a href="https://mp.weixin.qq.com/s?__biz=MzIxMDY1ODQxMg==&amp;mid=2247486271&amp;idx=3&amp;sn=233f6c9b0f881d4a2fe4bb71c60ca2cc&amp;chksm=97607e3ca017f72a5393d46f0dd5985c07aa7aed8262c78cb0e8ae96c5f05727b0bde9a2a5b0&amp;mpshare=1&amp;scene=1&amp;srcid=0306YQQBdMN6j1B1IpuCgpCg%23rd">零知识证明（Zero-Knowledge Proof）原理详解</a>。</li>
</ul>


<p>此外，这里具体介绍一下是如何使用区块中的梅克尔树来做完整型证明的。每当产生一次交易，那么就与其他所有准备打包进区块的交易组成交易列表，通过Merkle Tree算法生成Merkle Root Hash，作为交易列表的摘要存到区块头中。比特币中使用的称之为二叉梅克尔树，而比如以太坊系统中使用的则是梅克尔-帕特里夏树。以二叉梅克尔树为例，流程可以概括为每相临的两条交易记录向上形成一个Hash值（如果仅有奇数个交易，则最后的交易会被复制一份以构成偶数个叶子节点），再与相邻的节点再往上形成Hash值，一直到树根形成所有交易记录的唯一Hash值，即Merkle根。如下图所示：</p>

<p><img src="http://www.rowkey.me/post_images/blockchain/merkle.jpg" alt="" /></p>

<p>如此，一方面可以在数据同步有问题的时候快速定位到出错的交易记录，另一方面在节点只是需要验证支付（不同于交易，如验证是否有人完成了对自己的一笔交易）的时候，仅下载链的区块头即可，实现“简化支付验证”（SPV），能够极大的节省传输数据量。SPV的流程如下：</p>

<ul>
<li>一个SPV节点会在节点间的通信链接上建立起布隆过滤器，限制只接受含有目标比特币地址的交易。</li>
<li>当节点探测到某交易符合布隆过滤器，它会以Merkle区块消息的形式向相邻节点索要包含区块头和一条连接目标交易与Merkle根的Merkle路径，如图中如果要验证交易1，那么则返回Hash2、Hash34即可。</li>
<li>SPV节点使用该路径找到与该交易相关的区块，验证对应区块中该交易的有无。</li>
</ul>


<h2>共识机制</h2>

<p>对于分布式系统来说，一个非常核心的问题就是如何让所有节点达成一致，也就是共识机制。在区块链出现之前，已经有了一些解决方案，这里称之为传统分布式一致性算法：</p>

<ul>
<li>Paxos算法：基于消息传递且具有高度容错特性，类似于议会投票的过程分为三种角色Proposer、Acceptor及Learner，主要就是Proposer发起投票，Acceptor进行投票的一个过程。具体可见：<a href="http://drmingdrmer.github.io/tech/distributed/2015/11/11/paxos-slide.html">可靠分布式系统基础Paxos的直观解释</a>。这里需要说明一点：Zookeeper使用的ZAB协议对Paxos做了一些改造，是一种类Paxos算法。</li>
<li>Raft算法：相比起Paxos算法，RAFT更加注重算法的落地性和可理解性，其核心思想是如果数个数据库初始状态一致，只要之后的进行的操作一致，就能保证之后的数据一致。分为Leader、Follower以及Candidate三种角色，基于Log进行数据同步。大体就是选举Leader，然后Leader生成Log，Follower进行同步的一个过程。详细可见:<a href="https://zhuanlan.zhihu.com/p/27207160">Raft协议详解</a>。</li>
</ul>


<p>对于不需要货币体系的联盟链或者私有链而言，所有的节点都是绝对信任的节点，考虑到对性能的要求，一般选择传统的一致性算法即可。但由于这些传统的方案仅仅是考虑到了节点会有网络故障或者宕机的问题，没有考虑到节点会作恶（篡改消息）的情况。因此，在比特币、以太坊这种区块链上并不适用。于是有了以下的分布式一致性算法：</p>

<ol>
<li><p>PBFT: 拜占庭容错，针对的是拜占庭将军问题而提出的一种一致性算法。分为三个阶段：预准备（pre-prepare）、准备(prepare)和确认(commit)。大体的流程就是节点之间互相转发消息，以其中相同的大多数作为最终答案。此算法的可靠度受制于结点的数量影响（N ≥ 3F + 1，总的结点数目必须大于有问题节点的数目的三倍），因此使用受限，在IBM的私有链Hyperledger中得到了使用。</p></li>
<li><p>PoW: Proof of Work,工作量证明。这个是比特币、莱特币等货币型区块链使用的共识机制。类似于现实中的毕业证、驾照等，来证明你具有某种能力。可以认为PoW彻底解决了分布式一致性的问题。其过程以比特币为例，如下：</p>

<ul>
<li>矿工在网络中拿到最新一个区块的头部信息，其中的Merkle根包含了交易记录的信息摘要；</li>
<li>将拿到的头部信息作为参数，将nonce值从零开始，去计算其双重SHA256值（<strong>SHA256(SHA256(区块头信息))</strong>）；</li>
<li>如果算出的答案不符合要求（前n位为0），则将nonce值增加一个单位，再算；</li>
<li>直到计算出符合难度目标的答案，就挖到一个区块（打包交易记录，其中优先记录手续费高的交易），即可将自己创建的区块广播出去，其他节点验证无误即保存到自己的区块链上。</li>
<li>如果同时有多个节点实现了工作量证明挖到了区块，那么整个网络集群采用少数服从多数原则，集群中大部分采用了哪个区块就选择此区块组成最新的账本，达到最终一致性。<strong>少数服从多数原则</strong>也是区块链防范攻击、保证数据安全性的一个核心的原则。</li>
<li>如果节点同步到了多个长度不同的区块链账本，那么选择其中最长的作为区块链账本，且在最长链之外挖矿，不会得到任何挖矿报酬。即“最长链规则”。</li>
</ul>


<p> 由最后两点可知，挖到一个区块时，并不能过早的高兴，一般说来后面再跟五个确认过的区块（加上自己的区块，叫做六次确认），才能确认自己创建的区块的确是有效的，记录的交易也才认为是有效的（此时交易接收方可以认为交易已经成功）。</p>

<p>这个思路牺牲了一部分一致性来保证区块链的健壮性，即使只有一个结点，区块链系统依旧可以运行。同时也保证了区块链的安全性，除非51%的结点被控制。但一方面如果想要控制这么多节点，不仅要具有很强的算力，还相当于重构一个区块链网络，另一方面区块链会给予实现工作量证明创建区块成功的节点以奖励（每一个区块的交易清单的第一条交易为“系统给区块创建者支付xx奖励”，被称做coinbase交易，此交易没有输入），在比特币中奖励包括一部分新造比特币（一开始一个区块奖励50个比特币，每隔21万个区块自动减半，4年时间比特币总量最终会稳定在2100万个），一部分是从区块所包含的交易中抽取的挖矿手续费。如此权衡收益和破坏的成本，基本可以杜绝这种51%攻击（博弈学的使用）等。</p>

<p>此外，还需要提到区块头中的难度目标这个值，此值与计算耗时是反比的，即此值越大，那么计算越容易。以比特币为例，为了控制每十分钟产生一个区块的速率，需要根据统计数据动态调整难度目标从而可以保证区块的生产速率。</p>

<p>比特币的PoW虽然很好的解决了分布式一致性问题，但其非常的耗费计算力，浪费电，并且这种纯粹靠CPU的计算会受到某些专用硬件的威胁，如ASIC芯片。而以太坊的POW算法叫做Ethash（最新版本为Dagger-Hashimoto），其特点是挖矿的效率基本与CPU无关，却和内存大小和内存带宽正相关，无法设计专用硬件来解答难题。</p></li>
<li><p>PoS: Proof of Stake，权益证明机制。是一种通过业务规则达成共识的方式。基本概念是产生区块的难度应该与用户在网络里所占的股权成比例。具体来说就是根据钱包里面货币的多少以及货币在钱包里存在的天数来合成一个单位（币天），然后根据币天的关系对计算机进行哈希计算降低（谁的钱包里的币天数越大谁拥有记账权的概率就越大）。如此，能够减少对计算资源的浪费，提高计算性能。但是它也是牺牲了一部分的共识，而且需要等待多个确认。与PoW类比于比力量大小，PoS就是比耐力大小。</p>

<p> PoS目前已经使用在以太坊中。</p></li>
<li><p>DPoS: Delegate Proof of Stake。是基于POS衍生出的更专业的解决方案，类似于董事会的投票机制，选举出n个记账节点，在节点中提案者提交的提案被这些记账节点投票决定谁是正确的。此机制性能比较高，但是其选出的delegate节点是能够作恶的。</p>

<p> EOS的底层框架石墨烯-<a href="https://github.com/cryptonomex/graphen">Graphene</a>使用DPoS做为共识机制。</p></li>
</ol>


<h2>上层应用</h2>

<ul>
<li>可编程合约/可编程资产：交易验证并不基于一个不变的模式，而是通过运行脚本语言来实现可编程资产以太坊。</li>
<li>激励机制：虚拟货币激励，比特币、以太币。</li>
<li>成员管理：为整个区块链网络提供身份管理、隐私、保密和可审计的服务。通过公钥基础设施和去中心化共识机制使得非许可的区块链变成许可制的区块链。多中心组网、私钥公钥生成等。</li>
</ul>


<p>这里需要提的是区块链中“地址”的含义。以比特币为例，地址本质上是一个私钥公钥对（ECDSA椭圆曲线算法），其存储和区块链和网络是没有关系的，可由用户的钱包软件生成并管理。而通常为了易于人们记忆，地址会在公钥的基础上做一个格式化转换。常用的格式包括：Base58Check（Base58+Checksum）、WIF压缩、130位和66位公钥。以最常用的Base58Check为例，可以概括为:<strong><em>Base58Check(RIPEMD160(SHA256(PubKey)))</em></strong>，其流程如下：</p>

<p><img src="http://www.rowkey.me/post_images/blockchain/bitcoin-address.png" alt="" /></p>

<p>而以太坊则是使用SECP256K1椭圆曲线算法生成公钥私钥对，再把公钥去掉04，剩下的进行KECCAK-256的哈希，得到长度64的16进制字串，丢掉前面24个，拿后40个，再加上&#8221;0x&#8221;，即为以太坊地址。</p>

<h2>性能问题</h2>

<p>目前区块链无法得到大规模应用的一个很大问题就是性能，比特币的每秒交易量只有3/秒，而以太坊也就30/秒。虽然EOS这个项目号称能达到几百万/S，然而分布式系统的本质让这个指标有点难以相信，而且这个数据也仅仅是建立在其几百个结点的基础上。</p>

<p>目前，提升区块链的方案主要有以下两种种：</p>

<ul>
<li>链外解决方案：即允许小型和频繁的交易发生在与主链并行并由主链背书的侧链实例上。只将比特币区块链用作大额交易的结算网络——小规模交易由区块链之外的支付中心处理（off-chain scaling，链外扩展）。</li>
<li>链上解决方案：直接修改区块链设计以支持高性能，如提高区块的容量、按照地址分片验证（以太坊）等。具体的可见：<a href="https://mp.weixin.qq.com/s?__biz=MzAwOTcyNzA0OQ==&amp;mid=2658972665&amp;idx=1&amp;sn=a3b8cc3538099530270910ae12267795">区块链性能提升：链上设计之道</a>。</li>
</ul>


<p>当然，如果使用私有链或者联盟链，其中的共识机制采取传统的分布式一致性算法或者高效的其他一致性算法也可以解决性能的问题。</p>

<h2>应用场景</h2>

<p>由于区块链本身的去中心化、不可篡改、安全等特性，需要第三方机构的应用场景都可以使用区块链技术。主流的应用场景如下：</p>

<ul>
<li>公正防伪</li>
<li>资产交易</li>
<li>信用体系</li>
<li>物品溯源</li>
<li>身份验证</li>
<li>文件存储</li>
<li>银行结算</li>
<li>版权控制</li>
</ul>


<h2>技术平台</h2>

<p>区块链的技术平台总体上可以分为公有链、联盟链和私有链，其大体的对比如下：</p>

<table>
<thead>
<tr>
<th>. </th>
<th> 公有链 </th>
<th> 联盟链 </th>
<th> 私有链</th>
</tr>
</thead>
<tbody>
<tr>
<td>参与者 </td>
<td> 任何人自由进出 </td>
<td> 联盟成员 </td>
<td> 个体或公司内部</td>
</tr>
<tr>
<td>共识机制 </td>
<td> PoW/PoW/DPoS  </td>
<td> 分布式一致性算法 </td>
<td> 分布式一致性算法</td>
</tr>
<tr>
<td>记账人 </td>
<td> 所有参与者 </td>
<td> 联盟成员协商确定 </td>
<td> 自定义</td>
</tr>
<tr>
<td>激励机制 </td>
<td> 需要 </td>
<td> 可选 </td>
<td> 不需要</td>
</tr>
<tr>
<td>中心化程度 </td>
<td> 去中心化 </td>
<td> 多中心化 </td>
<td> （多）中心化</td>
</tr>
<tr>
<td>特点 </td>
<td> 信用的自建立 </td>
<td> 效率和成本优化 </td>
<td> 透明和可追溯</td>
</tr>
<tr>
<td>承载能力（交易数/s） </td>
<td> 3-20万/s </td>
<td> 1000-1万/s </td>
<td> 1000-10万/s</td>
</tr>
<tr>
<td>典型场景 </td>
<td> 虚拟货币 </td>
<td> 支付、结算 </td>
<td> 审计、发行</td>
</tr>
<tr>
<td>代表项目 </td>
<td> 比特币、以太坊 </td>
<td> Hyperledger、腾讯TrustSQL </td>
<td></td>
</tr>
</tbody>
</table>


<h3>比特币</h3>

<p>比特币(使用C++开发)早于区块链走入人们的视野，并且很长时间内许多人都把比特币和区块链看做同一个东西。</p>

<p><img src="http://www.rowkey.me/post_images/blockchain/bitcoin.png" alt="" /></p>

<p>如图，是比特币的架构，可以看出比特币是基于区块链技术的副产品，是基于区块链的第一个应用，后来其他技术平台基本都是在比特币的基础上开发出来的。区块链可以类比为我们平时使用的JavaEE技术，比特币则是基于JavaEE开发的应用。无法基于比特币这个平台开发自己的应用。</p>

<h3>以太坊</h3>

<p><img src="http://www.rowkey.me/post_images/blockchain/ethereum.png" alt="" /></p>

<p>如上图所示，以太坊的架构由比特币演化而来，其诞生是为了解决比特币只适合加密数字货币场景，不具备图灵完备性，也缺乏保存实时状态的账户概念的问题，同时也是为了解决PoW机制带来的效率和资源浪费的问题。以太坊既是一个数字货币系统，也是一个智能合约的开发平台（类似AppStore这种应用开发平台，一个智能合约即一个应用）。可以把以太坊看做一个完全去中心化的电脑，使用此电脑需要用以太币支付费用（Gas）。</p>

<p>智能合约是以太坊最为核心的一个概念：提供了一个功能更强大的合约编程环境。一个合约类似一个合同，一旦写好即无法修改。每个节点都执行软件的一部分。类比于数据库中的触发器和存储过程，智能合约在区块链中是一个沙箱中的脚本（无法调用外部API），用于执行业务逻辑，也可以用于各种检查。开发智能合约使用的是Solidity语言。其是在Javascript语言基础上做的修改。合约代码会编译成字节码发布到以太坊网络，在EVM(Ethereum Virtual Machine)中执行。开发智能合约主要用到两个框架：</p>

<ul>
<li>Truffle Framework：Truffle提供了一整套部署测试的工具，可以方便和web3.js（以太坊提供的NodeJS SDK）结合使用。</li>
<li>dapphub: 提供了很多实用的合约，比如数学运算、权限验证等。</li>
</ul>


<p>其实比特币的交易也可以看做智能合约，只不过在比特币中就是⼀对锁定与解锁脚本（基于逆波兰表示法的基于堆栈的执行语言），受限只能实现转账交易。</p>

<p>使用以太坊发行数字代币（符合ERC20标准的智能合约）是非常简单的事情，官网提供了配套的代码和工具：<a href="https://www.ethereum.org/token">https://www.ethereum.org/token</a>，也可以参照这个指引：<a href="https://learnblockchain.cn/2018/01/12/create_token/index.html">一步步教你创建自己的数字货币（代币）进行ICO</a>。</p>

<p>这里还要说明一下ETC和ETH的区别。2016年6月区块链业界最大的众筹项目TheDAO遭到黑客攻击,导致300多万以太币资产被分离出TheDAO资产池。鉴于区块链的去中心、匿名的特征，资金根本无法追回，于是以太坊的发明人V神决定从块高度1760000开始把任何与The DAO和child DAO相关的交易认做无效交易，把以太坊做了一次分叉（区块链软件升级，但由于去中心化的问题并不能保证所有软件版本都升级上来），以此阻止攻击者在27天之后提走被盗的以太币。但此次分叉由于设计缺陷问题后来进行了回滚，最终是在区块高度1920000进行了一次分叉。而另外一些人由于不认同这种解决办法，而继续使用旧版本的以太坊软件，于是以太坊便发生了硬分叉（区块链软件升级，老版本不能够识别新的数据），原来的以太坊被叫做了ETC（以太经典）。至于这次攻击能够成功的原因主要是因为智能合约的逻辑有问题，具体的原因分析可见：<a href="http://ethfans.org/posts/114">从技术角度剖析针对THE DAO的攻击手法
</a>。</p>

<h3>EOS</h3>

<p>Enterprise Operation System，是由和V神齐名的BM大神发起的区块链项目，从名字上看其目的就是构建一个商业操作系统。由于其是一个ICO项目，且被某比特币大V进行了投资，因此受到的议论比较多。EOS的设计针对的是区块链性能太低满足不了很多应用场景以及在以太坊上进行操作需要支付费用等问题。</p>

<p>EOS号称自己能够达到每秒百万级的处理量，且具有高度自治，并能够为开发dApp的开发者提供底层模块，降低开发门槛。EOS也不收取任何费用，并能够通过并行链和DPOS的方式解决延迟和数据吞吐量的难题。</p>

<p>在EOS上编写智能合约支持C/C++/WebAssembly以及RESTFul接口(比较简单)。</p>

<h3>NEO</h3>

<p>小蚁区块链，开源，使用dBFT（delegated BFT，授权拜占庭容错机制）做为其共识机制。市值国内第一，全球第七，支持C#、Java、GO、Python、js等开发区块链应用。其目的是利用区块链技术和数字身份进行资产数字化，利用智能合约对数字资产进行自动化管理，实现“智能经济”。</p>

<p>目前，NEO提供了配套设施搭建私有链。</p>

<h3>联盟链和私有链</h3>

<p>市面上有一些联盟链和私有链技术平台，可以基于此做一些区块链应用开发。如下：</p>

<ul>
<li>腾讯TrustSQL: 腾讯主导的可信数据库区块链平台，<a href="https://trustsql.qq.com/">https://trustsql.qq.com/</a>。</li>
<li>百度区块链开放平台：百度主导的区块链平台，<a href="https://chain.baidu.com/">https://chain.baidu.com/</a>。</li>
<li>IBM HyperLedger，也被称作超级账本，又叫fabric，是一个面向商业的区块链系统开发框架（开发用的半成品基础设施）。</li>
</ul>


<h2>ICO</h2>

<p>提到区块链，ICO是不得不提的一个概念，类比于IPO，ICO是首次发币代售，提供了一种平等、低门槛的方式让普通民众参与到经济活动中，目前能够进行ICO的平台(能够方便发代币)主要是以太坊和比特股(Bitshares)。这种东西本意是好的，可以降低公司融资的成本，好的项目不会再看风投脸色，好的Idea也不会再胎死腹中，用户ICO获得的Token还可以带来实际的经济效益。但是由于缺乏IPO一样的管制，已经彻底沦为了收割智商的工具。</p>

<p>如上文所说，其实基于以太坊发行虚拟货币是非常简单的，如果你文采够好随便写个白皮书，洋洋洒洒描绘一个去中心化的蓝图，再找几个所谓业界大神站个台，好了，剩下的就等着数钱吧。当然，不排除有真心想做出一个项目的，但绝大多数都是些空气项目，发起人不过是发了个空气币，然后卷钱跑路。</p>

<p>说到ICO，虚拟货币交易所也是关键的角色，在这里可以流通法币和各种虚拟货币。有点令人不解的是，去中心化的区块链虚拟货币竟然需要一个中心化的“交易所”。黑客们攻击不了区块链，攻击一个中心化的交易所还是有许多路可寻的。最近频频发生的虚拟货币交易所被攻击的事情也算是对这种模式的一种讽刺。</p>

<h2>开发参考</h2>

<p>如果想实现自己的区块链平台或者了解区块链的实现，可以通过比特币、以太坊的代码学习，也可以参考以下资料:</p>

<ul>
<li><a href="https://www.ibm.com/developerworks/library/j-chaincode-for-java-developers/index.html">面向Java开发人员的区块链代码</a></li>
<li><a href="http://www.spring4all.com/article/811">用Java创建你的第一个区块链-part1</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=2653549361&amp;idx=1&amp;sn=019f54713891cf33ef3bef3b24773a96&amp;chksm=813a62a9b64debbfdd24a8507bb974048a4456e5b0a2d5f685fb3bdf40366a25764c5df8afec&amp;mpshare=1&amp;scene=1&amp;srcid=0226W0WdpzjJ9Qo6F3FJstO6%23rd">只用200行Go代码写一个自己的区块链！</a></li>
</ul>


<h2>小结</h2>

<p>区块链技术的出现以一种全新的思路解决了分布式一致性的问题，技术+博弈学+金融学的使用巧妙的构建了一个安全健壮的系统。这些思路给开发者在平时的学习工作中会有很多的思考和提示。而随着比特币价格的水涨船高和各种资本的追捧，区块链目前是被过度炒作的，大部分应用都是联盟量和私有链，已经违背了区块链设计的初衷。虽然的确是有应用场景，但笔者认为这和共享分布式数据库没有本质上的区别。此外，虽然区块链上的数据是无法篡改的，但是如果数据上链有人工参与的环节，那么这一步如何防止篡改呢？这也是我开篇观点产生的原因。</p>

<p>至于能用区块链做什么？在笔者看来，去研究区块链技术平台只有大公司、政府能做并推广起来，不过最后也只不过是“联盟链”、“私有链”。而对于创业公司或者个人来说，基于公有链、联盟链做之上的应用则更为合适，比如在以太坊/EOS上做一个养宠物的游戏^_^。</p>

<h2>参考资料</h2>

<ul>
<li><a href="http://8btc.com/topic-mastering-bitcoin.html">精通比特币</a></li>
<li><a href="http://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system">比特币白皮书:一种点对点的电子现金系统</a></li>
<li><a href="http://dataconomy.com/2015/10/wtf-is-the-blockchain-a-guide-for-total-beginners/">WTF IS THE BLOCKCHAIN? A GUIDE FOR TOTAL BEGINNERS</a></li>
<li><a href="http://blog.csdn.net/jeffrey__zhou/article/details/56672948">区块链共识机制浅谈</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzI3MzEzMDI1OQ==&amp;mid=2651818777&amp;idx=1&amp;sn=8cf64236f13e1196b28a2603744d4c0f&amp;chksm=f0dcdd65c7ab5473a239b47939d7586229122788c49fbac295c77627b4693a06b1ce8d73afdc&amp;mpshare=1&amp;scene=1&amp;srcid=0829NWygcU8u98YzRZ8TmQlN%23rd">白话区块链技术栈与应用</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzIzNzU4MTg5NQ==&amp;mid=2247484492&amp;idx=1&amp;sn=b37844e8ab32b5ce516ee92149f243d6&amp;chksm=e8c72764dfb0ae727b2a50da75ef1ded417ad3c303c47f61c666f8dd39e631f114ab350f2544&amp;mpshare=1&amp;scene=1&amp;srcid=0217E8nz8lHzcB3sBvSBAics%23rd">比特币的潜在激励</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==&amp;mid=2247487013&amp;idx=1&amp;sn=4675dd398a3458af9ba519557675e406&amp;chksm=e929332ade5eba3c142a36f89677d71bf1e1395967ace0b9e4ff3d18c6cffd604420709967fe&amp;mpshare=1&amp;scene=1&amp;srcid=03126HIJoomFmy2JpebnHa5m%23rd">如何用架构师思维解读区块链技术？</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[正则表达式简明指南]]></title>
    <link href="http://www.rowkey.me/blog/2018/03/10/regx/"/>
    <updated>2018-03-10T19:29:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2018/03/10/regx</id>
    <content type="html"><![CDATA[<p>公司使用的markdown解析类库一直有一些解析上的问题，最近给fix了。而markdown解析主要是对正则表达式的使用。中间恶补了一下相关知识，在此梳理一下。</p>

<h2>什么是正则表达式</h2>

<p>正则表达式就是用一个“字符串”来描述一个特征，然后去验证另一个“字符串”是否符合这个特征。简单的一个例子：用字符串&#8221;a&#8221;来验证字符串s是否是&#8221;a&#8221;，形如s.match(&ldquo;a&rdquo;)。概括来说有以下作用：</p>

<ul>
<li>验证字符串是否符合指定特征，比如验证是否是合法的邮件地址。</li>
<li>查找字符串，从一个长的文本中查找符合指定特征的字符串，比查找固定字符串更加灵活。</li>
<li>替换字符串，比普通的基于字符串的替换更灵活。</li>
</ul>


<!--more-->


<h2>基本规则</h2>

<h3>普通字符</h3>

<p>字母、数字、汉字、下划线、以及后续没有特殊定义的标点符号，都是&#8221;普通字符&#8221;。表达式中的普通字符，在匹配一个字符串的时候，匹配与之相同的一个字符。如：表达式 &ldquo;a&#8221;，在匹配字符串 &#8220;abcde&rdquo;             时，匹配到的内容是：&#8221;a&#8221;。</p>

<h3>转义字符</h3>

<p>一些不便书写的字符，采用在前面加 &ldquo;\&rdquo; 的方法。常见的如：</p>

<ul>
<li>\r: 回车</li>
<li>\n: 换行符</li>
<li>\t: 制表符</li>
<li>&#92;\: &ldquo;\&rdquo; 本身</li>
</ul>


<p>此外，还有其他再正则中有特殊用处的标点符号，在前面加 &ldquo;&#92;&#8221;后，代表该符号本身。如：^, $。如果要想匹配字符串中 &rdquo;^&ldquo; 和 &rdquo;$&ldquo; 字符，需要写成 &rdquo;\^&ldquo; 和 &rdquo;\$&ldquo;。如</p>

<ul>
<li>\^: 匹配^符号本身</li>
<li>\$: 匹配$符号本身</li>
<li>&#92;.: 匹配小数点.本身</li>
</ul>


<p>其匹配规则和普通字符串是一样的，如&#8221;\^&ldquo;匹配&#8221;a^bc&#8221;中的&rdquo;^&ldquo;。</p>

<h3>&lsquo;多种字符&#8217;匹配</h3>

<ul>
<li>\d：任意一个数字，0~9 中的任意一个</li>
<li>\w：任意一个字母或数字或下划线，也就是 A~Z,a~z,0~9,_ 中任意一个</li>
<li>\s：包括空格、制表符、换页符等空白字符的其中任意一个</li>
<li>.：小数点可以匹配除了换行符以外的任意一个字符</li>
</ul>


<p>如：表达式 &ldquo;\dtest\d&#8221;匹配&#8221;1test2&#8221;。</p>

<p>除了正则自带的&#8217;多种字符&#8217;匹配外，还可以通过中括号[]来自定义。</p>

<ul>
<li>使用[ ]包含一系列字符，能够匹配其中任意一个字符。</li>
<li>用 [^ ]包含一系列字符，则能够匹配其中字符之外的任意一个字符。</li>
</ul>


<p>如：[123]匹配 &ldquo;1&#8221;或&#8221;2&#8221;或&#8221;3&rdquo;;[^abc]匹配 &ldquo;a&#8221;、&#8221;b&#8221;、&#8221;c&rdquo; 之外的任意一个字符</p>

<p>这里需要注意的是，在使用[]时，只有会改变字符组含义的才需要转义，</p>

<ul>
<li>反斜线必须转义</li>
<li>方括号必须转义</li>
<li>「^」在首和「-」在中必须转义</li>
</ul>


<p>其他情况即使是特殊字符也不需要转义，如：</p>

<ul>
<li>[aeiou]</li>
<li>[$.*+?{}()|]</li>
<li>[abc^123-]</li>
</ul>


<h3>匹配次数</h3>

<p>&ldquo;次数修饰&#8221;放在&#8221;被修饰的正则表达式&#8221;后边，可以匹配多次。如：</p>

<ul>
<li>{n}: 表达式重复n次，比如： &ldquo;\d{2}&rdquo; 相当于 &ldquo;\d\d&#8221;。</li>
<li>{m,n}:表达式至少重复m次，最多重复n次，比如： &ldquo;a{1,3}&#8221;可以匹配 &#8220;a&#8221;或&#8221;aa&#8221;或&#8221;aaa&#8221;。</li>
<li>{m,}: 表达式至少重复m次，比如： &ldquo;\d{2,}&#8221;可以匹配               &#8220;12&rdquo;,&ldquo;123&rdquo;,&ldquo;12345678&#8221;。</li>
<li>?: 匹配表达式0次或者1次，相当于 {0,1}，比如： &ldquo;a[b]?&#8221;可以匹配&#8221;a&rdquo;,&ldquo;ab&#8221;。</li>
<li>+: 表达式至少出现1次，相当于 {1,}，比如： &ldquo;a+&#8221;可以匹配&#8221;a&rdquo;,&ldquo;aa&rdquo;,&ldquo;aaa&#8221;。</li>
<li>*: 表达式不出现或出现任意次，相当于 {0,}，比如：&#8221;ab*&ldquo;可以匹配                 &#8220;a&#8221;、&#8221;ab&#8221;、&#8221;abb&#8221;。</li>
</ul>


<h3>特殊符号</h3>

<ul>
<li>^: 与字符串开始的地方匹配，不匹配任何字符,这里如果使用(?m)模式，则匹配每一行的开始。如：&#8221;^aaa&#8221;无法匹配 &ldquo;xxxaaaxxx&#8221;，可以匹配&#8221;aaaxxx&#8221;。</li>
<li>$: 与字符串结束的地方匹配，不匹配任何字符，这里如果使用(?m)模式，则匹配每一行的结束。如：&#8221;aaa$&ldquo;无法匹配&#8221;xxxaaaxxx&rdquo;, 可以匹配&#8221;xxxaaa&#8221;。</li>
<li>\b：匹配一个单词边界，也就是单词和空格之间的位置，不匹配任何字符。它与 &ldquo;^&#8221;、&rdquo;$&ldquo; 类似，本身不匹配任何字符，但是它要求它在匹配结果中所处位置的左右两边，其中一边是 &rdquo;\w&#8221; 范围，另一边是             非&#8221;\w&#8221; 的范围。。如：&#8221;.\b.&ldquo;匹配&rdquo;@@abc&#8221;的&#8221;@a&#8221;。</li>
</ul>


<p>此外，还有一些符号可以影响表达式内部的子表达式之间的关系：</p>

<ul>
<li>|: 左右两边表达式之间&#8221;或&#8221;关系，匹配左边或者右边。</li>
<li>(): 在被修饰匹配次数的时候，括号中的表达式可以作为整体被修饰;取匹配结果的时候，括号中的表达式匹配到的内容可以被单独得到。如：&#8221;(ab\s*)+&ldquo;匹配&#8221;hi, ab ab ab&#8221;中的&#8221;ab ab ab&#8221;。</li>
</ul>


<h2>高级规则</h2>

<h3>贪婪与非贪婪匹配</h3>

<p>在使用修饰匹配次数的特殊符号时，有几种表示方法可以使同一个表达式能够匹配不同的次数，比如：&#8221;{m,n}&ldquo;, &rdquo;{m,}&ldquo;, &rdquo;?&ldquo;, &rdquo;*&ldquo;, &rdquo;+&ldquo;，具体匹配的次数随被匹配的字符串而定。这种重复匹配不定次数的表达式在匹配过程中，总是尽可能多的匹配。比如，文本 &#8220;axxxaxxxa&#8221;，&rdquo;(a)(\w+)&ldquo;，其中&rdquo;\w+&ldquo;会匹配&#8221;xxxaxxxa&#8221;，&rdquo;(a)(\w+)(a)&ldquo;则会匹配&#8221;xxxaxxx&#8221;。由此可见，&rdquo;\w+&ldquo; 在匹配的时候，总是尽可能多的匹配符合它规则的字符。虽然第二个举例中，它没有匹配最后一个 &#8220;a&#8221;，但那也是为了让整个表达式能够匹配成功。同样的，带 &rdquo;*&ldquo; 和 &rdquo;{m,n}&ldquo; 的表达式都是尽可能地多匹配，带 &rdquo;?&ldquo; 的表达式在可匹配可不匹配的时候，也是尽可能的<strong>匹配</strong>。这种匹配原则就叫作&#8221;贪婪&#8221;模式。</p>

<p>非贪婪模式则是指的<strong>在修饰匹配次数的特殊符号后再加上一个 &ldquo;?&rdquo; 号</strong>，可以使匹配次数不定的表达式尽可能少的匹配，使可匹配可不匹配的表达式，尽可能的<strong>不匹配</strong>。这种匹配原则也叫作 &ldquo;勉强&rdquo; 模式。如果少匹配就会导致整个表达式匹配失败的时候，与贪婪模式类似，非贪婪模式会最小限度的再匹配一些，以使整个表达式匹配成功。如，文本 &ldquo;axxxaxxxa&rdquo; ，&#8221;(a)(\w+?)&ldquo;，其中&rdquo;\w+&ldquo;只会匹配一个&#8221;x&#8221;。</p>

<h3>反向引用</h3>

<p>表达式在匹配时，表达式引擎会将小括号 &ldquo;()&rdquo; 包含的表达式所匹配到的字符串记录下来。在获取匹配结果的时候，小括号包含的表达式所匹配到的字符串可以单独获取。当用某种边界来查找，而所要获取的内容又不包含边界时，必须使用小括号来指定所要的范围。如：&#8221;&lt;div>(.*?)&lt;/div>&ldquo;即获取div标签内部的内容。</p>

<p>这里小括号包含的正则表达式所匹配到的字符串不仅仅是在匹配结束后才可以使用，在匹配过程中也可以使用。表达式后边的部分，可以引用前面括号内的子匹配已经匹配到的字符串。引用方法是 &ldquo;\&rdquo; 加上一个数字。&#8221;\1&#8221; 引用第1对括号内匹配到的字符串，&#8221;\2&#8221; 引用第2对括号内匹配到的字符串，以此类推，而如果一对括号内包含另一对括号，则外层的括号先排序号。换句话说，哪一对的左括号 &ldquo;(&rdquo; 在前，那这一对就先排序号。</p>

<p>例如：表达式 &ldquo;(&lsquo;|&rdquo;)(.*?)(\1)&ldquo; 在匹配 &rdquo; &#8216;Hello&rsquo;, &ldquo;World&rdquo; &ldquo; 时，匹配结果是：成功；匹配到的内容是：&rdquo; &lsquo;Hello&rsquo; &ldquo;。再次匹配下一个时，可以匹配到 &rdquo; &ldquo;World&rdquo; &ldquo;。</p>

<h3>预搜索</h3>

<p>如前面所讲&#8221;^&ldquo;、&rdquo;$&ldquo;、&rdquo;\b&#8221;字符有一个共同点，就是：它们本身不匹配任何字符，只是对 &ldquo;字符串的两头&rdquo; 或者 &ldquo;字符之间的缝隙&rdquo; 附加了一个条件。同样的，正则中提供了其他基于此原理的机制，来实现预搜索。</p>

<ul>
<li><p>正向预搜索：&#8221;(?=xxxxx)&ldquo;，&rdquo;(?!xxxxx)&#8221;</p>

<p>  格式：&#8221;(?=xxxxx)&ldquo;，在被匹配的字符串中，它对所处的 &#8220;缝隙&rdquo; 或者 &ldquo;两头&rdquo; 附加的条件是：所在缝隙的右侧，必须能够匹配上xxxxx这部分的表达式，不影响后边的表达式去真正匹配这个缝隙之后的字符。如： &ldquo;Mac (?=book|air)&rdquo; 在匹配 &ldquo;Mac pro, Mac air&rdquo; 时，将只匹配 &ldquo;Mac air&rdquo; 中的 &ldquo;Mac&#8221;。</p>

<p>  格式：&#8221;(?!xxxxx)&ldquo;，所在缝隙的右侧，必须不能匹配 xxxxx 这部分表达式。如：&#8221;hello(?!\w)&rdquo; 在匹配字符串 &ldquo;hello,helloworld&#8221;时，匹配 hello&#8221;。这里使用 &rdquo;(?!\w)&ldquo; 和使用 &rdquo;\b&#8221; 效果一样。</p></li>
<li><p>反向预搜索：&#8221;(?&lt;=xxxxx)&ldquo;，&rdquo;(?&lt;!xxxxx)&#8221;</p>

<p>  和正向预搜索类似，反向预搜索要求的条件是：所在缝隙的 &ldquo;左侧&#8221;，两种格式分别要求必须能够匹配和必须不能够匹配指定表达式，而不是去判断右侧。与 &#8220;正向预搜索&rdquo; 一样的是：它们都是对所在缝隙的一种附加条件，本身都不匹配任何字符。</p></li>
</ul>


<h2>其他通用规则</h2>

<ul>
<li><p>可以使用 &ldquo;\xXX&rdquo; 和 &ldquo;\uXXXX&rdquo; 表示一个字符（&#8221;X&#8221; 表示一个十六进制数）</p>

<ul>
<li>\xXX: 编号在 0-255 范围的字符，如： 空格可以使用 &ldquo;\x20&rdquo; 表示</li>
<li>\uXXXX: 任何字符可以使用 &ldquo;\u&rdquo; 再加上其编号的4位十六进制数表示，比如： &ldquo;\u4E2D&rdquo;</li>
</ul>
</li>
<li><p>在表达式 &ldquo;\s&#8221;，&rdquo;\d&#8221;，&#8221;\w&#8221;，&#8221;\b&#8221; 表示特殊意义的同时，对应的大写字母表示相反的意义</p>

<ul>
<li>\S: 匹配所有非空白字符</li>
<li>\D: 匹配所有的非数字字符</li>
<li>\W: 匹配所有的字母、数字、下划线以外的字符</li>
<li>\B: 匹配非单词边界，即左右两边都是 &ldquo;\w&rdquo; 范围或者左右两边都不是 &ldquo;\w&rdquo; 范围时的字符缝隙</li>
</ul>
</li>
<li><p>括号&#8221;()&ldquo;内的子表达式，如果希望匹配结果不进行记录供以后使用，可以使用 &rdquo;(?:xxxxx)&ldquo;格式。如：表达式 &rdquo;(?:(\w)\1)+&ldquo; 匹配 &#8220;a bbccdd efg&rdquo; 时，结果是 &ldquo;bbccdd&#8221;。括号 &rdquo;(?:)&ldquo; 范围的匹配结果不进行记录，因此 &rdquo;(\w)&ldquo; 使用 &rdquo;\1&#8221; 来引用。</p></li>
<li><p>常用的表达式属性设置包括：Ignorecase、Singleline、Multiline、Global</p>

<ul>
<li>Ignorecase: 默认情况下，表达式中的字母是要区分大小写的。配置为 Ignorecase 可使匹配时不区分大小写。有的表达式引擎，把 &ldquo;大小写&rdquo; 概念延伸至 UNICODE 范围的大小写。</li>
<li>Singleline: 默认情况下，小数点 &ldquo;.&rdquo; 匹配除了换行符（\n）以外的字符。配置为Singleline可使小数点可匹配包括换行符在内的所有字符。</li>
<li><p>Multiline: 默认情况下，表达式 &ldquo;^&rdquo; 和 &ldquo;$&rdquo; 只匹配字符串的开始1和结尾4位置。如：</p>

<p>  1xxxxxxxxx2\n
  3xxxxxxxxx4</p>

<p>  配置为 Multiline 可以使 &ldquo;^&rdquo; 匹配1外，还可以匹配换行符之后，下一行开始前3的位置，&#8221;$&ldquo; 匹配4外，还可以匹配换行符之前，一行结束2的位置。使用(?m)可以设置为Multiline模式。如&rdquo;(?m)^\n +&ldquo;。</p></li>
<li>Global: 主要在将表达式用来替换时起作用，配置为Global表示替换所有的匹配。</li>
</ul>
</li>
</ul>


<h2>提示</h2>

<ul>
<li>如果要求表达式所匹配的内容是整个字符串，而不是其中的一部分，可以在表达式的首尾使用 &ldquo;^&rdquo; 和 &ldquo;$&#8221;，比如：&rdquo;^\d+$&ldquo; 要求整个字符串只有数字。</li>
<li>如果要求匹配的内容是一个完整的单词，而不会是单词的一部分，那么在表达式首尾使用 &ldquo;\b&#8221;，如： 使用 &rdquo;\b(if|while|&hellip;)\b&#8221; 来匹配程序中的关键字。</li>
<li>表达式不要匹配空字符串。否则会一直得到匹配成功，而结果什么都没有匹配到。</li>
<li>能匹配空字符串的子匹配不要循环无限次。如果括号内的子表达式中的每一部分都可以匹配0次，而这个括号整体又可以匹配无限次，那么匹配过程中可能死循环。</li>
<li>&ldquo;|&rdquo; 的左右两边，对某个字符应该只有一边可以匹配，以防止&#8221;|&ldquo;两边的表达式因为交换位置而有所不同。</li>
<li>要合理选择贪婪模式与非贪婪模式，如.* 与 .*?的区别使用。</li>
</ul>


<hr />

<p>中华万年历技术团队长期求Java研发工程师，给你挑战<strong>亿级用户</strong>、<strong>千万日活APP</strong>开发的机会。感兴趣者可发送简历到<a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#x3a;&#x68;&#97;&#x6e;&#x67;&#x40;&#x65;&#x74;&#111;&#x75;&#x63;&#x68;&#46;&#99;&#x6e;">&#104;&#x61;&#x6e;&#103;&#64;&#101;&#116;&#111;&#117;&#x63;&#x68;&#46;&#99;&#x6e;</a>。要求如下：</p>

<p><img src="http://www.rowkey.me/images/blog_images/java_job.jpg" width="350" style="margin:0 auto;display:block"/></p>

<p>详见:<a href="https://m.zhipin.com/weijd/v2/job/0cdf0b4c4c3029521nN5392-FFc~">https://m.zhipin.com/weijd/v2/job/0cdf0b4c4c3029521nN5392-FFc~</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2017年读过的书]]></title>
    <link href="http://www.rowkey.me/blog/2018/02/06/2017books/"/>
    <updated>2018-02-06T19:29:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2018/02/06/2017books</id>
    <content type="html"><![CDATA[<p>2017年一共阅读了九本书，包括技术和管理，并且参加了一次“高价值管理人”的管理培训课程，在技术和管理方面都有了一定的学习，得到了一些进步。</p>

<!--more-->


<h2>技术</h2>

<ul>
<li><p>架构真经</p>

<blockquote><p>虽然是基于电商系统进行的讲解，但是其很多架构原则都是普适的。其中讲的很多东西都是自己在实践中做过的东西。经过理论的总结之后，确让自己有了更深的思考。强烈推荐架构入门者阅读此书。</p></blockquote></li>
<li><p>聊聊架构</p>

<blockquote><p>这本书还没出来之前，各路技术大神评价非常高。出来之后，很多人都在吐槽这本书在故弄玄虚。其实，就我来看，前几章确实有点哲学的感觉，但相信有架构经验的人是能够有共鸣的。架构的本质也的确和哲学有关系。这本书比较适合有一定架构经验的工程师来阅读，并不适合经验尚浅者。</p></blockquote></li>
<li><p>Java性能权威指南</p>

<blockquote><p>一本涵盖Java调优方方面面的书籍。从JVM内存、JIT到集合使用等等。虽然我们一直强调不能“过早优化”，但是对于一些应当普遍意识到的优化措施还是越早越好的，否则当产生了问题再来优化，成本反而会更大。强烈推荐Java工程师阅读此书。</p></blockquote></li>
<li><p>大数据之路-阿里巴巴大数据实践</p>

<blockquote><p>讲述阿里巴巴大数据平台的演化之路。这本书讲的很多东西虽然都是阿里自研的，并没有全部开源。但是很多软件的使用兼容了开源软件，尤其是一些诸如解决数据倾斜问题、去重指标计算的思路也是普遍适用的。对照一下，可以理出自己公司在大数据平台上哪些做的不错，哪些还没做，哪些需要优化。</p></blockquote></li>
<li><p>亿级流量网站核心技术</p>

<blockquote><p>本书作者是IT著名博主，自己上学时就看过他写的Spring系列。因此在此书出版之前就觉得应该是本好书。读完此书，学到了一些东西，比如Nginx+Lua/Openrestry在高并发、大流量场景下的使用、Consult的统一配置、使用Lua脚本做Nginx动态负载均衡等。但有点令人失望的是，很多东西都是一笔带过，尤其是穿插了大量类库的使用代码（自我觉得出版书籍一定要避免大量代码，完全是可以放到Github上，而且类库的使用代码完全是可以阅读官方文档的）。比较适合没有架构经验的人来了解一下大公司架构使用了哪些技能，有经验的则可以当做一本参考手册，查漏补缺。</p></blockquote></li>
<li><p>响应式微服务架构（Reactive-Microservices-Architecture）</p>

<blockquote><p>O&#8217;Reilly的系列电子书。讲述了在设计分布式系统时候的一些原则，在架构层面指导微服务的实现。</p></blockquote></li>
</ul>


<h2>管理</h2>

<ul>
<li><p>格鲁夫给经理人的第一课</p>

<blockquote><p>公司管理层统一学习的一本管理书籍。第一次系统地学习了管理方面的知识，印证了很多实践中已经在采取的方法的合理性，也让自己有了新的管理思路。强烈推荐给刚刚进入管理领域的人。</p></blockquote></li>
<li><p>技术管理之巅</p>

<blockquote><p>不同于其他管理书籍，此书着重于从技术Leader角度讲述如何管理研发人员，打造高效技术团队。其中如何量化研发人员的绩效指标给了自己不小的启发，后面也运用了起来。此外，如何建立研发职级体系、如何敏捷管理项目等等都是可以借鉴的地方。</p></blockquote></li>
<li><p>架构即未来</p>

<blockquote><p>《架构真经》的姊妹篇，早于《架构真经》，不仅仅讲述了技术架构的知识，更让我受用的是前面部分讲的“构建可扩展的组织架构”。对于诸如管理和领导、敏捷组织架构、问题和故障等等的概念讲解的非常透彻。而后面技术架构这一块则是对《架构真经》的一个引子。</p></blockquote></li>
</ul>


<h2>2018</h2>

<p>2018年需要花大量精力在技术管理和机器学习方面，暂定需要阅读的几本书如下：</p>

<ul>
<li><p>OKR: 源于英特尔和谷歌的目标管理利器</p>

<blockquote><p><strong><em>截止2018.02.06已经完成阅读。</em></strong>此书是公司管理层进行统一学习的一本书，不厚，花了三个晚上大约6个小时就读完了。讲述了什么是OKR、OKR的好处、如何使用OKR等等，推荐想要进行OKR实践的管理人员阅读。</p></blockquote></li>
<li><p>微服务反模式和陷阱（Microservices AntiPatterns and Pitfalls）</p></li>
<li>机器学习实战 &amp;&amp; 机器学习西瓜书</li>
<li>Tensorflow实战</li>
<li>深入分布式缓存</li>
<li>高性能MySQL</li>
<li>尽在双11，阿里巴巴技术演进与超越</li>
<li>Clean Architecture, A Craftsman&rsquo;s Guide to Software Structure and Design</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何快速尝出毒酒？- 用bit解决问题]]></title>
    <link href="http://www.rowkey.me/blog/2018/01/04/king-rec-pois-wine/"/>
    <updated>2018-01-04T19:29:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2018/01/04/king-rec-pois-wine</id>
    <content type="html"><![CDATA[<h2>问题</h2>

<p>国王有一百桶酒，比自己的生命还重要。结果有一天其中一桶被投了慢性毒药，喝了以后半个小时以后就会死掉。国王大怒，命令玩忽职守的侍卫去试毒。酒不能被混合，一个侍卫可以喝多桶酒，一桶酒也可以由多个侍卫喝，怎么样才能用最少的侍卫、在最短的时间知道哪桶是毒酒。侍卫可以理解为线程，即怎么样用最少的线程用最快的速度完成这个工作。</p>

<!--more-->


<h2>方案</h2>

<p>此问题是我在面试时经常用的一道题目，主要考察的是候选人能不能以计算机的思维考虑问题。</p>

<p>最简单的方案肯定是找100个人，每个人试一桶酒，那么用时30分钟，就可以判断出哪一桶就有毒。</p>

<p>再进一步的，可以使用分段法，把酒分成n份，先找n个侍卫试酒，可以定位出哪一段的酒有毒，再接着分段试酒。但这种方案，分段数目越少，试出毒酒的平均耗时就越长。</p>

<p>如果用计算机的思维来分析这个问题，那么首先考虑如何存储这100桶酒。100桶酒可以用二进制7个bit来表示（2<sup>7</sup>>100）。对应那一桶毒酒，其二进制表示中为1的位置如果能够可以定位出来，就可以定位出此桶毒酒。可以找7个侍卫编号1-7。对于每一桶酒的二进制表示（不足七位前面用0表示），从第一位到第七位，如果是1，则对应编号的侍卫喝此桶酒。这样，每个侍卫喝掉对应的酒。30分钟后，侍卫按照编号1-7，死掉的置为1，活着的置为0，如此，侍卫的一个序列如0000111就表示第七桶酒为毒酒。</p>

<h2>总结</h2>

<p>上述最后一种方案提现了在计算机中使用bit来解决问题的思路。当需要节省存储的时候，使用bit来做经常会有出其不易的效果。就比如最近很火的电影《天才枪手》中，主角们记忆选择题的答案A、B、C、D，完全可以使用位编码来表示四种答案:00-A 01-B 10-C 11-D，四个bit转换为一个十六进制数字，如此就可以节省一半的存储，记忆起来也会简单很多。此外，我们处理大数据去重/计数使用的Bitmap、BloomFilter，也都是一种使用bit节省存储的思路。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[技术琐话2018-01-01]]></title>
    <link href="http://www.rowkey.me/blog/2018/01/01/tech-talk/"/>
    <updated>2018-01-01T19:29:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2018/01/01/tech-talk</id>
    <content type="html"><![CDATA[<blockquote><p>日常的工作学习中，经常会看到好的知识点，对自己有提示的一句话，或者是自己突然想通了一件事情。决定以博客的形式记录下来，以“技术琐话”作为主题。</p>

<p>2018年以“技术琐话”开篇，主要是整理了一下自己以前一些零散的知识点。</p></blockquote>

<h2>技术感悟</h2>

<ul>
<li><p>阅读各种技术的使用/说明/示例/原理文档时，能不能快速吸收为自己的知识？能不能注意到细节关键点？是一个开发工程师优不优秀，能不能比别人更突出、更快成长起来的一个非常重要的地方。</p></li>
<li><p>你东西学得广了，别人就会攻击你不够深入；你东西学得够深了，别人就会攻击你知识面不广；你专精在技术时，别人就会说你管理不好；你花心力好好做管理之后，别人就会说你技术没有跟上；你研究方法论时，别人就会说你很虚；你专心做项目时，别人就会说你没有提炼方法，没有系统。&hellip; 想挑你毛病，总有办法。但你自己知道自己在干什么最重要，那些你的「缺点」其实可能不是缺点，而是一件事物的另一面。你选择这一面，自然会缺另一面。这是取舍点，不是优缺点。(from 微博<strong>@蔡学镛</strong>)</p></li>
</ul>


<!--more-->


<ul>
<li><p>来自硅谷的启示</p>

<p>  <img src="http://www.rowkey.me/images/blog_images/silicon-tech.jpg" alt="" /></p></li>
</ul>


<h2>技术点</h2>

<ul>
<li><p>在写Java代码的时候，如果匿名内部类里面传递变量，变量必须声明为final，而在Java8中，可以不用写这个final了，因为Java8引入了Effectively final 功能，由系统默认添加。<a href="http://t.cn/R5QgeVW">What is Effectively Final variable of Java 8</a></p></li>
<li><p>将Nginx中的一个配置指令proxyinterceptorerrors设置为true，可以捕获后端服务器返回的错误码进行处理，从而可以使用nginx自己的错误显示页面。 ​​​​</p></li>
<li><p>在Servlet开发中，request.setCharacterEncoding必须在所有filter最开始执行，否则只要调用过request相关方法去获取其参数等，再去设置编码是无效的。</p></li>
<li><p>Java中File类的listFiles和list方法最终调用的是FileSystem的本地接口，返回的文件列表顺序是没有保证的。Spring中的san某一basepackage下的类就是使用的此方法，因此加载的bean的顺序也是无法保证的。这一点需要特别注意。 ​​​​​​</p></li>
<li><p>Tomcat各个版本特性对比图</p>

<p>  <img src="http://www.rowkey.me/images/blog_images/tc.png" alt="" /></p></li>
<li><p>Java集合类对比图表</p>

<p>  <img src="http://www.rowkey.me/images/blog_images/java-collections.jpg" alt="" /></p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何实现延时触发/定时器]]></title>
    <link href="http://www.rowkey.me/blog/2017/12/28/delay-trigger/"/>
    <updated>2017-12-28T19:29:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2017/12/28/delay-trigger</id>
    <content type="html"><![CDATA[<h2>问题</h2>

<p>微信公众平台后台有一个功能即定时群发消息，如明晚的20:00群发一条图文消息。那么这种延时触发的逻辑如何实现呢？</p>

<!--more-->


<h2>方案一</h2>

<p><strong>每隔一定的时间扫描所有超时的事件</strong></p>

<p>这是最容易想到的一种方案。此方案最关键的两点是轮训的频率以及如何高效地获取超时任务。</p>

<ul>
<li>如果可以允许一秒左右的误差，每隔一秒轮训一次即可。</li>
<li>采用红黑树或者最小堆存储触发任务，按照触发时间戳排序。如此，每次扫描能够很快地获取超时的任务。实践中，一个很简单的方案就是使用Redis的SortedSet存储触发任务，这样只需要使用zrangeByScore获取超时的任务，再使用zremrangeByScore即可删除已经触发的任务。</li>
</ul>


<p>此种方案的缺点在于即使频率到达一秒，也可能会有一秒的误差。此外，轮训的方式在很多情况下并没有可触发的任务，会浪费资源。</p>

<h2>方案二</h2>

<p><strong>阻塞线程等待时间超时</strong></p>

<p>此方案思路来自于Nginx中定时器的实现（和Java中的DelayQueue原理类似）。任务的存储和上面的方案类似，采用最小堆或者红黑树即可。然后选择最近要被触发的任务的时间距离作为阻塞调用epoll_wait的超时（也可以使用其他可以设置超时的阻塞调用）。阻塞超时后，依次获取最小触发时间戳的任务，超时则执行。</p>

<p>此种方案的最大优点在于不会有空的任务检查周期。</p>

<h2>方案三</h2>

<p><strong>采用环形队列</strong></p>

<p>此方案详细可以见58沈剑的文章<a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651959961&amp;idx=1&amp;sn=afec02c8dc6db9445ce40821b5336736&amp;chksm=bd2d07458a5a8e5314560620c240b1c4cf3bbf801fc0ab524bd5e8aa8b8ef036cf755d7eb0f6">《1分钟实现“延迟消息”功能》</a>。大体的思路如下：</p>

<p>采用环形队列，3600个slot，每隔1秒扫描一个slot，检查当前slot里面的所有任务，检查其cycleNum是否为0, 为0则触发，否则cycleNum-1。添加定时事件时，根据扫描指针的当前slot的index和事件触发的时间，计算cycleNum和要放入的slot。</p>

<p>此种方案的本质是<strong>栅格化与预计算</strong>，相比起前两种方案，大大提升了每次获取可触发任务的效率。但同样存在每次查询任务有可能做无用功的问题。此外，需要特别处理添加任务和扫描任务的临界点的问题，否则也可能会有时间上的误差。</p>

<p><strong>PS: 这个方案原理是和时间轮(Netty中的HashedWheelTimer)一样的，多谢@imangry提示</strong></p>

<h2>方案四</h2>

<p><strong>延时消息队列</strong></p>

<p>目前，RabbitMQ、RocketMQ都支持延时消息队列，直接使用即可。但这种依赖消息队列的方案，如果要取消定时任务，则无法实现。其中，RabbitMQ的实现思路是基于TTL的，详细可见：<a href="http://www.cnblogs.com/haoxinyue/p/6613706.html">http://www.cnblogs.com/haoxinyue/p/6613706.html</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[技术琐话2017-11-26]]></title>
    <link href="http://www.rowkey.me/blog/2017/11/26/tech-talk/"/>
    <updated>2017-11-26T19:29:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2017/11/26/tech-talk</id>
    <content type="html"><![CDATA[<blockquote><p>日常的工作学习中，经常会看到好的知识点，对自己有提示的一句话，或者是自己突然想通了一件事情。决定以博客的形式记录下来，以“技术琐话”作为主题。</p></blockquote>

<ul>
<li><p>The interesting thing about performance is that if you analyze most programs, you find that they waste most of their time in a small fraction of code. If you optimize all the code equally, you end up with 90 percent of the optimizations wasted, because you are optimizing code that isn&rsquo;t run much. The time spent making the program fast, the time lost because of lack of clarity, is all wasted time.《重构》一书的一段话，也是不要过早优化的意思，即在不确定这段代码真的会被频繁调用、真的是系统的性能瓶颈之前，没必要花时间优化此处的性能。</p></li>
<li><p>这句话揭示了成为技术专家的一个关键特质: 理解一个系统应该如何工作并不能使人成为专家，只能靠调查系统为何不能正常工作才行。（From SRE ，by Brian Redman）</p></li>
<li><p>技术书籍的出版门槛越来越低，该如何识别是否是一本烂书呢？在我自己看来，英文书籍质量远远好于中文书籍，翻译的版本一般来说质量也不错，不过作为一个互联网从业的技术人员，能够直接阅读英文原版是最好不过的。而对于中文书籍，如果是以公司名义或者书的序多于3篇，是一本烂书的概率非常大，写推荐语、写序的人名头越大，并不代表这本书的质量有多好。此外，现在某sdn专家真的是门槛低到不行，挂这个名头出的书更要慎重选择。对于InfoQ推荐的书，倒是可以值得一读。</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring注解概览]]></title>
    <link href="http://www.rowkey.me/blog/2017/10/28/spring-annotations/"/>
    <updated>2017-10-28T19:29:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2017/10/28/spring-annotations</id>
    <content type="html"><![CDATA[<p>从Java5.0开始，Java开始支持注解。Spring做为Java生态中的领军框架，从2.5版本后也开始支持注解。相比起之前使用xml来配置Spring框架，使用注解提供了更多的控制Spring框架的方式。</p>

<p>现在越来越多的项目也都在使用注解做相关的配置，但Spring的注解非常多，相信很多注解大家都没有使用过。本文就尽量全面地概括介绍一下Spring中常用的注解。</p>

<!--more-->


<h2>一. 核心注解</h2>

<h3>@Required</h3>

<p>此注解用于bean的setter方法上。表示此属性是必须的，必须在配置阶段注入，否则会抛出BeanInitializationExcepion。</p>

<h3>@Autowired</h3>

<p>此注解用于bean的field、setter方法以及构造方法上，显式地声明依赖。根据type来autowiring。</p>

<p>当在field上使用此注解，并且使用属性来传递值时，Spring会自动把值赋给此field。也可以将此注解用于私有属性(不推荐)，如下。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@Component
</span><span class='line'>public class User {
</span><span class='line'>    @Autowired                               
</span><span class='line'>    private Address address;                   
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>最经常的用法是将此注解用于settter上，这样可以在setter方法中添加自定义代码。如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@Component
</span><span class='line'>public class User {
</span><span class='line'>     private Address address;
</span><span class='line'>    
</span><span class='line'>     @AutoWired
</span><span class='line'>   public setAddress(Address address) {
</span><span class='line'>      // custom code
</span><span class='line'>      this.address=address;
</span><span class='line'>   }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>当在构造方法上使用此注解的时候，需要注意的一点就是一个类中只允许有一个构造方法使用此注解。此外，在Spring4.3后，如果一个类仅仅只有一个构造方法，那么即使不使用此注解，那么Spring也会自动注入相关的bean。如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@Component
</span><span class='line'>public class User {
</span><span class='line'>    private Address address;
</span><span class='line'>    
</span><span class='line'>     public User(Address address) {       
</span><span class='line'>        this.address=address;
</span><span class='line'>     }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>&lt;bean id="user" class="xx.User"/&gt;</span></code></pre></td></tr></table></div></figure>


<h3>@Qualifier</h3>

<p>此注解是和@Autowired一起使用的。使用此注解可以让你对注入的过程有更多的控制。</p>

<p>@Qualifier可以被用在单个构造器或者方法的参数上。当上下文有几个相同类型的bean, 使用@Autowired则无法区分要绑定的bean，此时可以使用@Qualifier来指定名称。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@Component
</span><span class='line'>public class User {
</span><span class='line'>    @Autowired
</span><span class='line'>    @Qualifier("address1")
</span><span class='line'>    private Address address;
</span><span class='line'>    ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>@Configuration</h3>

<p>此注解用在class上来定义bean。其作用和xml配置文件相同，表示此bean是一个Spring配置。此外，此类可以使用@Bean注解来初始化定义bean。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@Configuartion
</span><span class='line'>public class SpringCoreConfig {
</span><span class='line'>    @Bean
</span><span class='line'>    public AdminUser adminUser() {
</span><span class='line'>        AdminUser adminUser = new AdminUser();
</span><span class='line'>        return adminUser;
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>@ComponentScan</h3>

<p>此注解一般和@Configuration注解一起使用，指定Spring扫描注解的package。如果没有指定包，那么默认会扫描此配置类所在的package。</p>

<h3>@Lazy</h3>

<p>此注解使用在Spring的组件类上。默认的，Spring中Bean的依赖一开始就被创建和配置。如果想要延迟初始化一个bean，那么可以在此类上使用Lazy注解，表示此bean只有在第一次被使用的时候才会被创建和初始化。此注解也可以使用在被@Configuration注解的类上，表示其中所有被@Bean注解的方法都会延迟初始化。</p>

<h3>@Value</h3>

<p>此注解使用在字段、构造器参数和方法参数上。@Value可以指定属性取值的表达式，支持通过#{}使用SpringEL来取值，也支持使用${}来将属性来源中(Properties文件、本地环境变量、系统属性等)的值注入到bean的属性中。此注解值的注入发生在AutowiredAnnotationBeanPostProcessor类中。</p>

<h2>二. Stereotype注解</h2>

<h3>@Component</h3>

<p>此注解使用在class上来声明一个Spring组件(Bean), 将其加入到应用上下文中。</p>

<h3>@Controller</h3>

<p>此注解使用在class上声明此类是一个Spring controller，是@Component注解的一种具体形式。</p>

<h3>@Service</h3>

<p>此注解使用在class上，声明此类是一个服务类，执行业务逻辑、计算、调用内部api等。是@Component注解的一种具体形式。</p>

<h3>@Repository</h3>

<p>此类使用在class上声明此类用于访问数据库，一般作为DAO的角色。</p>

<p>此注解有自动翻译的特性，例如：当此种component抛出了一个异常，那么会有一个handler来处理此异常，无需使用try-catch块。</p>

<h2>三. Spring Boot注解</h2>

<h3>@EnableAutoConfiguration</h3>

<p>此注解通常被用在主应用class上，告诉Spring Boot自动基于当前包添加Bean、对bean的属性进行设置等。</p>

<h3>@SpringBootApplication</h3>

<p>此注解用在Spring Boot项目的应用主类上（此类需要在base package中）。使用了此注解的类首先会让Spring Boot启动对base package以及其sub-pacakage下的类进行component scan。</p>

<p>此注解同时添加了以下几个注解：</p>

<ul>
<li>@Configuration</li>
<li>@EnableAutoConfiguration</li>
<li>@ComponentScan</li>
</ul>


<h2>四. Spring MVC和REST注解</h2>

<h3>@Controller</h3>

<p>上文已经提到过此注解。</p>

<h3>@RequestMapping</h3>

<p>此注解可以用在class和method上，用来映射web请求到某一个handler类或者handler方法上。当此注解用在Class上时，就创造了一个基础url，其所有的方法上的@RequestMapping都是在此url之上的。</p>

<p>可以使用其method属性来限制请求匹配的http method。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@Controller
</span><span class='line'>@RequestMapping("/users")
</span><span class='line'>public class UserController {
</span><span class='line'>    @RequestMapping(method = RequestMethod.GET)
</span><span class='line'>    public String getUserList() {
</span><span class='line'>        return "users";
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>此外，Spring4.3之后引入了一系列@RequestMapping的变种。如下：</p>

<ul>
<li>@GetMapping</li>
<li>@PostMapping</li>
<li>@PutMapping</li>
<li>@PatchMapping</li>
<li>@DeleteMapping</li>
</ul>


<p>分别对应了相应method的RequestMapping配置。</p>

<h3>@CookieValue</h3>

<p>此注解用在@RequestMapping声明的方法的参数上，可以把HTTP cookie中相应名称的cookie绑定上去。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@ReuestMapping("/cookieValue")
</span><span class='line'>      public void getCookieValue(@CookieValue("JSESSIONID") String cookie){
</span><span class='line'>
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>cookie即http请求中name为JSESSIONID的cookie值。</p>

<h3>@CrossOrigin</h3>

<p>此注解用在class和method上用来支持跨域请求，是Spring 4.2后引入的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@CrossOrigin(maxAge = 3600)
</span><span class='line'>@RestController
</span><span class='line'>@RequestMapping("/users")
</span><span class='line'>public class AccountController {
</span><span class='line'>    @CrossOrigin(origins = "http://xx.com")
</span><span class='line'>    @RequestMapping("/login")
</span><span class='line'>    public Result userLogin() {
</span><span class='line'>        // ...
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>@ExceptionHandler</h3>

<p>此注解使用在方法级别，声明对Exception的处理逻辑。可以指定目标Exception。</p>

<h3>@InitBinder</h3>

<p>此注解使用在方法上，声明对WebDataBinder的初始化(绑定请求参数到JavaBean上的DataBinder)。在controller上使用此注解可以自定义请求参数的绑定。</p>

<h3>@MatrixVariable</h3>

<p>此注解使用在请求handler方法的参数上，Spring可以注入matrix url中相关的值。这里的矩阵变量可以出现在url中的任何地方，变量之间用;分隔。如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// GET /pets/42;q=11;r=22
</span><span class='line'>@RequestMapping(value = "/pets/{petId}")
</span><span class='line'>public void findPet(@PathVariable String petId, @MatrixVariable int q) {
</span><span class='line'>    // petId == 42
</span><span class='line'>    // q == 11
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>需要注意的是默认Spring mvc是不支持矩阵变量的，需要开启。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;mvc:annotation-driven enable-matrix-variables="true" /&gt;</span></code></pre></td></tr></table></div></figure>


<p>注解配置则需要如下开启：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@Configuration
</span><span class='line'>public class WebConfig extends WebMvcConfigurerAdapter {
</span><span class='line'> 
</span><span class='line'>    @Override
</span><span class='line'>    public void configurePathMatch(PathMatchConfigurer configurer) {
</span><span class='line'>        UrlPathHelper urlPathHelper = new UrlPathHelper();
</span><span class='line'>        urlPathHelper.setRemoveSemicolonContent(false);
</span><span class='line'>        configurer.setUrlPathHelper(urlPathHelper);
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>@PathVariable</h3>

<p>此注解使用在请求handler方法的参数上。@RequestMapping可以定义动态路径，如:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@RequestMapping("/users/{uid}")</span></code></pre></td></tr></table></div></figure>


<p>可以使用@PathVariable将路径中的参数绑定到请求方法参数上。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@RequestMapping("/users/{uid}")
</span><span class='line'>public String execute(@PathVariable("uid") String uid){
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>@RequestAttribute</h3>

<p>此注解用在请求handler方法的参数上，用于将web请求中的属性(request attributes，是服务器放入的属性值)绑定到方法参数上。</p>

<h3>@RequestBody</h3>

<p>此注解用在请求handler方法的参数上，用于将http请求的Body映射绑定到此参数上。HttpMessageConverter负责将对象转换为http请求。</p>

<h3>@RequestHeader</h3>

<p>此注解用在请求handler方法的参数上，用于将http请求头部的值绑定到参数上。</p>

<h3>@RequestParam</h3>

<p>此注解用在请求handler方法的参数上，用于将http请求参数的值绑定到参数上。</p>

<h3>@RequestPart</h3>

<p>此注解用在请求handler方法的参数上，用于将文件之类的multipart绑定到参数上。</p>

<h4>@ResponseBody</h4>

<p>此注解用在请求handler方法上。和@RequestBody作用类似，用于将方法的返回对象直接输出到http响应中。</p>

<h3>@ResponseStatus</h3>

<p>此注解用于方法和exception类上，声明此方法或者异常类返回的http状态码。可以在Controller上使用此注解，这样所有的@RequestMapping都会继承。</p>

<h4>@ControllerAdvice</h4>

<p>此注解用于class上。前面说过可以对每一个controller声明一个ExceptionMethod。这里可以使用@ControllerAdvice来声明一个类来统一对所有@RequestMapping方法来做@ExceptionHandler、@InitBinder以及@ModelAttribute处理。</p>

<h3>@RestController</h3>

<p>此注解用于class上，声明此controller返回的不是一个视图而是一个领域对象。其同时引入了@Controller和@ResponseBody两个注解。</p>

<h3>@RestControllerAdvice</h3>

<p>此注解用于class上，同时引入了@ControllerAdvice和@ResponseBody两个注解。</p>

<h3>@SessionAttribute</h3>

<p>此注解用于方法的参数上，用于将session中的属性绑定到参数。</p>

<h3>@SessionAttributes</h3>

<p>此注解用于type级别，用于将JavaBean对象存储到session中。一般和@ModelAttribute注解一起使用。如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@ModelAttribute("user")
</span><span class='line'>
</span><span class='line'>public PUser getUser() {}
</span><span class='line'>
</span><span class='line'>// controller和上面的代码在同一controller中
</span><span class='line'>@Controller
</span><span class='line'>@SeesionAttributes(value = "user", types = {
</span><span class='line'>    User.class
</span><span class='line'>})
</span><span class='line'>
</span><span class='line'>public class UserController {}</span></code></pre></td></tr></table></div></figure>


<h2>五. 数据访问注解</h2>

<h3>@Transactional</h3>

<p>此注解使用在接口定义、接口中的方法、类定义或者类中的public方法上。需要注意的是此注解并不激活事务行为，它仅仅是一个元数据，会被一些运行时基础设施来消费。</p>

<h2>六. 任务执行、调度注解</h2>

<h3>@Scheduled</h3>

<p>此注解使用在方法上，声明此方法被定时调度。使用了此注解的方法返回类型需要是Void，并且不能接受任何参数。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@Scheduled(fixedDelay=1000)
</span><span class='line'>public void schedule() {
</span><span class='line'>
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@Scheduled(fixedRate=1000)
</span><span class='line'>public void schedulg() { 
</span><span class='line'>
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>第二个与第一个不同之处在于其不会等待上一次的任务执行结束。</p>

<h3>@Async</h3>

<p>此注解使用在方法上，声明此方法会在一个单独的线程中执行。不同于Scheduled注解，此注解可以接受参数。</p>

<p>使用此注解的方法的返回类型可以是Void也可是返回值。但是返回值的类型必须是一个Future。</p>

<h2>七. 测试注解</h2>

<h3>@ContextConfiguration</h3>

<p>此注解使用在Class上，声明测试使用的配置文件，此外，也可以指定加载上下文的类。</p>

<p>此注解一般需要搭配SpringJUnit4ClassRunner使用。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@RunWith(SpringJUnit4ClassRunner.class)
</span><span class='line'>@ContextConfiguration(classes = SpringCoreConfig.class)
</span><span class='line'>public class UserServiceTest {
</span><span class='line'>
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[有效解决问题]]></title>
    <link href="http://www.rowkey.me/blog/2017/10/20/solve-problems/"/>
    <updated>2017-10-20T19:29:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2017/10/20/solve-problems</id>
    <content type="html"><![CDATA[<p>来自于内部的一次培训，主要讲述了如何有效地解决问题，包括识别问题、描述问题、分析问题、找出方案、决策问题等。</p>

<!--more-->


<p><img src="http://www.rowkey.me/images/blog_images/solve_problem/arch-2.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/solve_problem/arch-3.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/solve_problem/arch-4.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/solve_problem/arch-5.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/solve_problem/arch-6.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/solve_problem/arch-7.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/solve_problem/arch-8.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/solve_problem/arch-9.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/solve_problem/arch-10.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/solve_problem/arch-11.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/solve_problem/arch-12.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/solve_problem/arch-13.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/solve_problem/arch-14.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/solve_problem/arch-15.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/solve_problem/arch-16.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/solve_problem/arch-17.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/solve_problem/arch-18.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/solve_problem/arch-19.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/solve_problem/arch-20.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/solve_problem/arch-21.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/solve_problem/arch-22.jpeg" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java9来了]]></title>
    <link href="http://www.rowkey.me/blog/2017/09/22/java9/"/>
    <updated>2017-09-22T19:29:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2017/09/22/java9</id>
    <content type="html"><![CDATA[<p>2017.9.21，Java9终于正式发布。其带来了诸如模块化、REPL环境、集合工厂方法等一系列有用的新特性。本文列出一些链接，可以通过阅读相关的内容来了解学习Java9。</p>

<h2>官方资料</h2>

<ul>
<li><a href="http://jdk.java.net/9/">JD9下载</a></li>
<li><a href="http://openjdk.java.net/projects/jdk9/">Java9新特性</a></li>
<li><a href="https://docs.oracle.com/javase/9/">Oracle的JDK文档</a></li>
<li><a href="http://mail.openjdk.java.net/pipermail/announce/2017-September/000230.html">Mark Reinhold的JDK9发布声明</a> [Mark Reinhold是Oracle的Java平台首席架构师]</li>
<li><a href="https://docs.oracle.com/javase/9/migrate/toc.htm#JSMIG-GUID-7744EF96-5899-4FB2-B34E-86D49B2E89B6">迁移到Java9的提示</a></li>
<li><a href="https://blogs.oracle.com/theaquarium/java-ee-8-is-final-and-glassfish-50-is-released">JavaEE 8和GlassFish发布</a></li>
</ul>


<h2>第三方资料</h2>

<ul>
<li><a href="https://dzone.com/articles/java-9-besides-modules">Java9中除了模块化的其他新特性介绍</a></li>
<li><a href="https://dzone.com/articles/java-9-and-intellij-idea">Java 9 and IntelliJ IDEA</a></li>
<li>Java9对旧版本应用的支持: <a href="https://dzone.com/articles/yes-you-can-java-9-for-the-legacy-developer">https://dzone.com/articles/yes-you-can-java-9-for-the-legacy-developer</a>、<a href="https://dzone.com/articles/the-legacy-developers-guide-to-java-9">https://dzone.com/articles/the-legacy-developers-guide-to-java-9</a></li>
<li>Java9模块化开发：<a href="https://dzone.com/articles/java-9-modularity-jigsaw">第一部分</a>、<a href="https://dzone.com/articles/java-9-modular-development-part-2">第二部分</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[译]Java中9个处理Exception的最佳实践]]></title>
    <link href="http://www.rowkey.me/blog/2017/09/17/java-exception/"/>
    <updated>2017-09-17T19:29:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2017/09/17/java-exception</id>
    <content type="html"><![CDATA[<p>在Java中处理异常并不是一个简单的事情。不仅仅初学者很难理解，即使一些有经验的开发者也需要花费很多时间来思考如何处理异常，包括需要处理哪些异常，怎样处理等等。这也是绝大多数开发团队都会制定一些规则来规范对异常的处理的原因。而团队之间的这些规范往往是截然不同的。</p>

<p>本文给出几个被很多团队使用的异常处理最佳实践。</p>

<!--more-->


<h2>1. 在Finally块中清理资源或者使用try-with-resource语句</h2>

<p>当使用类似InputStream这种需要使用后关闭的资源时，一个常见的错误就是在try块的最后关闭资源。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void doNotCloseResourceInTry() {
</span><span class='line'>    FileInputStream inputStream = null;
</span><span class='line'>    try {
</span><span class='line'>        File file = new File("./tmp.txt");
</span><span class='line'>        inputStream = new FileInputStream(file);
</span><span class='line'>        // use the inputStream to read a file
</span><span class='line'>        // do NOT do this
</span><span class='line'>        inputStream.close();
</span><span class='line'>    } catch (FileNotFoundException e) {
</span><span class='line'>        log.error(e);
</span><span class='line'>    } catch (IOException e) {
</span><span class='line'>        log.error(e);
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>上述代码在没有任何exception的时候运行是没有问题的。但是当try块中的语句抛出异常或者自己实现的代码抛出异常，那么就不会执行最后的关闭语句，从而资源也无法释放。</p>

<p>合理的做法则是将所有清理的代码都放到finally块中或者使用try-with-resource语句。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void closeResourceInFinally() {
</span><span class='line'>    FileInputStream inputStream = null;
</span><span class='line'>    try {
</span><span class='line'>        File file = new File("./tmp.txt");
</span><span class='line'>        inputStream = new FileInputStream(file);
</span><span class='line'>        // use the inputStream to read a file
</span><span class='line'>    } catch (FileNotFoundException e) {
</span><span class='line'>        log.error(e);
</span><span class='line'>    } finally {
</span><span class='line'>        if (inputStream != null) {
</span><span class='line'>            try {
</span><span class='line'>                inputStream.close();
</span><span class='line'>            } catch (IOException e) {
</span><span class='line'>                log.error(e);
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>public void automaticallyCloseResource() {
</span><span class='line'>    File file = new File("./tmp.txt");
</span><span class='line'>    try (FileInputStream inputStream = new FileInputStream(file);) {
</span><span class='line'>        // use the inputStream to read a file
</span><span class='line'>    } catch (FileNotFoundException e) {
</span><span class='line'>        log.error(e);
</span><span class='line'>    } catch (IOException e) {
</span><span class='line'>        log.error(e);
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>2. 指定具体的异常</h2>

<p>尽可能的使用最具体的异常来声明方法，这样才能使得代码更容易理解。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void doNotDoThis() throws Exception {
</span><span class='line'>    ...
</span><span class='line'>}
</span><span class='line'>public void doThis() throws NumberFormatException {
</span><span class='line'>    ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>如上，NumberFormatException字面上即可以看出是数字格式化错误。</p>

<h2>3. 对异常进行文档说明</h2>

<p>当在方法上声明抛出异常时，也需要进行文档说明。和前面的一点一样，都是为了给调用者提供尽可能多的信息，从而可以更好地避免/处理异常。</p>

<p>在Javadoc中加入throws声明，并且描述抛出异常的场景。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> * This method does something extremely useful ...
</span><span class='line'> *
</span><span class='line'> * @param input
</span><span class='line'> * @throws MyBusinessException if ... happens
</span><span class='line'> */
</span><span class='line'>public void doSomething(String input) throws MyBusinessException {
</span><span class='line'>    ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>4. 抛出异常的时候包含描述信息</h2>

<p>在抛出异常时，需要尽可能精确地描述问题和相关信息，这样无论是打印到日志中还是监控工具中，都能够更容易被人阅读，从而可以更好地定位具体错误信息、错误的严重程度等。</p>

<p>但这里并不是说要对错误信息长篇大论，因为本来Exception的类名就能够反映错误的原因，因此只需要用一到两句话描述即可。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>try {
</span><span class='line'>    new Long("xyz");
</span><span class='line'>} catch (NumberFormatException e) {
</span><span class='line'>    log.error(e);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>NumberFormatException即告诉了这个异常是格式化错误，异常的额外信息只需要提供这个错误字符串即可。当异常的名称不够明显的时候，则需要提供尽可能具体的错误信息。</p>

<h2>5. 首先捕获最具体的异常</h2>

<p>现在很多IDE都能智能提示这个最佳实践，当你试图首先捕获最笼统的异常时，会提示<strong><em>不能达到的代码</em></strong>。</p>

<p>当有多个catch块中，按照捕获顺序只有第一个匹配到的catch块才能执行。因此，如果先捕获IllegalArgumentException，那么则无法运行到对NumberFormatException的捕获。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void catchMostSpecificExceptionFirst() {
</span><span class='line'>    try {
</span><span class='line'>        doSomething("A message");
</span><span class='line'>    } catch (NumberFormatException e) {
</span><span class='line'>        log.error(e);
</span><span class='line'>    } catch (IllegalArgumentException e) {
</span><span class='line'>        log.error(e)
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>6. 不要捕获Throwable</h2>

<p>Throwable是所有异常和错误的父类。你可以在catch语句中捕获，但是永远不要这么做。</p>

<p>如果catch了throwable，那么不仅仅会捕获所有exception，还会捕获error。而error是表明无法恢复的jvm错误。因此除非绝对肯定能够处理或者被要求处理error，不要捕获throwable。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void doNotCatchThrowable() {
</span><span class='line'>    try {
</span><span class='line'>        // do something
</span><span class='line'>    } catch (Throwable t) {
</span><span class='line'>        // don't do this!
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>7. 不要忽略异常</h2>

<p>很多时候，开发者很有自信不会抛出异常，因此写了一个catch块，但是没有做任何处理或者记录日志。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>public void doNotIgnoreExceptions() {
</span><span class='line'>    try {
</span><span class='line'>        // do something
</span><span class='line'>    } catch (NumberFormatException e) {
</span><span class='line'>        // this will never happen
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>但现实是经常会出现无法预料的异常或者无法确定这里的代码未来是不是会改动(删除了阻止异常抛出的代码)，而此时由于异常被捕获，使得无法拿到足够的错误信息来定位问题。</p>

<p>合理的做法是至少要记录异常的信息。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void logAnException() {
</span><span class='line'>    try {
</span><span class='line'>        // do something
</span><span class='line'>    } catch (NumberFormatException e) {
</span><span class='line'>        log.error("This should never happen: " + e);
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>8. 不要记录并抛出异常</h2>

<p>可以发现很多代码甚至类库中都会有捕获异常、记录日志并再次抛出的逻辑。如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>try {
</span><span class='line'>    new Long("xyz");
</span><span class='line'>} catch (NumberFormatException e) {
</span><span class='line'>    log.error(e);
</span><span class='line'>    throw e;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这个处理逻辑看着是合理的。但这经常会给同一个异常输出多条日志。如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>17:44:28,945 ERROR TestExceptionHandling:65 - java.lang.NumberFormatException: For input string: "xyz"
</span><span class='line'>Exception in thread "main" java.lang.NumberFormatException: For input string: "xyz"
</span><span class='line'>at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
</span><span class='line'>at java.lang.Long.parseLong(Long.java:589)
</span><span class='line'>at java.lang.Long.(Long.java:965)
</span><span class='line'>at com.stackify.example.TestExceptionHandling.logAndThrowException(TestExceptionHandling.java:63)
</span><span class='line'>at com.stackify.example.TestExceptionHandling.main(TestExceptionHandling.java:58)</span></code></pre></td></tr></table></div></figure>


<p>如上所示，后面的日志也没有附加更有用的信息。如果想要提供更加有用的信息，那么可以将异常包装为自定义异常。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>public void wrapException(String input) throws MyBusinessException {
</span><span class='line'>    try {
</span><span class='line'>        // do something
</span><span class='line'>    } catch (NumberFormatException e) {
</span><span class='line'>        throw new MyBusinessException("A message that describes the error.", e);
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>因此，仅仅当想要处理异常时才去捕获，否则只需要在方法签名中声明让调用者去处理。</p>

<h2>9. 包装异常时不要抛弃原始的异常</h2>

<p>捕获标准异常并包装为自定义异常是一个很常见的做法。这样可以添加更为具体的异常信息并能够做针对的异常处理。</p>

<p>需要注意的是，包装异常时，一定要把原始的异常设置为cause(Exception有构造方法可以传入cause)。否则，丢失了原始的异常信息会让错误的分析变得困难。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void wrapException(String input) throws MyBusinessException {
</span><span class='line'>    try {
</span><span class='line'>        // do something
</span><span class='line'>    } catch (NumberFormatException e) {
</span><span class='line'>        throw new MyBusinessException("A message that describes the error.", e);
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>总结</h2>

<p>综上可知，当抛出或者捕获异常时，有很多不一样的东西需要考虑。其中的许多点都是为了提升代码的可阅读性或者api的可用性。</p>

<p>异常不仅仅是一个错误控制机制，也是一个沟通媒介，因此与你的协作者讨论这些最佳实践并制定一些规范能够让每个人都理解相关的通用概念并且能够按照同样的方式使用它们。</p>

<p>原文链接: <a href="https://dzone.com/articles/9-best-practices-to-handle-exceptions-in-java">https://dzone.com/articles/9-best-practices-to-handle-exceptions-in-java</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[译]Java中的十个"单行代码编程"(One Liner)]]></title>
    <link href="http://www.rowkey.me/blog/2017/09/09/java-oneliners/"/>
    <updated>2017-09-09T19:29:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2017/09/09/java-oneliners</id>
    <content type="html"><![CDATA[<p>本文列举了十个使用一行代码即可独立完成(不依赖其他代码)的业务逻辑，主要依赖的是Java8中的Lambda和Stream等新特性以及try-with-resources、JAXB等。</p>

<!--more-->


<ol>
<li><p>对列表/数组中的每个元素都乘以2</p>

<pre><code class="`"> // Range是半开区间
 int[] ia = range(1, 10).map(i -&gt; i * 2).toArray();
 List&lt;Integer&gt; result = range(1, 10).map(i -&gt; i * 2).boxed().collect(toList());
</code></pre></li>
<li><p>计算集合/数组中的数字之和</p>

<pre><code class="`"> range(1, 1000).sum();
 range(1, 1000).reduce(0, Integer::sum);
 Stream.iterate(0, i -&gt; i + 1).limit(1000).reduce(0, Integer::sum);
 IntStream.iterate(0, i -&gt; i + 1).limit(1000).reduce(0, Integer::sum);
</code></pre></li>
<li><p>验证字符串是否包含集合中的某一字符串</p>

<pre><code class="`">final List&lt;String&gt; keywords = Arrays.asList("brown", "fox", "dog", "pangram");
final String tweet = "The quick brown fox jumps over a lazy dog. #pangram http://www.rinkworks.com/words/pangrams.shtml";

keywords.stream().anyMatch(tweet::contains);
keywords.stream().reduce(false, (b, keyword) -&gt; b || tweet.contains(keyword), (l, r) -&gt; l || r);
</code></pre></li>
<li><p>读取文件内容</p>

<blockquote><p>原作者认为try with resources也是一种单行代码编程。</p></blockquote>

<pre><code class="`"> try (BufferedReader reader = new BufferedReader(new FileReader("data.txt"))) {
   String fileText = reader.lines().reduce("", String::concat);
 }

 try (BufferedReader reader = new BufferedReader(new FileReader("data.txt"))) {
   List&lt;String&gt; fileLines = reader.lines().collect(toCollection(LinkedList&lt;String&gt;::new));
 }

 try (Stream&lt;String&gt; lines = Files.lines(new File("data.txt").toPath(), Charset.defaultCharset())) {
   List&lt;String&gt; fileLines = lines.collect(toCollection(LinkedList&lt;String&gt;::new));
 }
</code></pre></li>
<li><p>输出歌曲《Happy Birthday to You!》 - 根据集合中不同的元素输出不同的字符串</p>

<pre><code class="`"> range(1, 5).boxed().map(i -&gt; { out.print("Happy Birthday "); if (i == 3) return "dear NAME"; else return "to You"; }).forEach(out::println);
</code></pre></li>
<li><p>过滤并分组集合中的数字</p>

<pre><code class="`"> Map&lt;String, List&lt;Integer&gt;&gt; result = Stream.of(49, 58, 76, 82, 88, 90).collect(groupingBy(forPredicate(i -&gt; i &gt; 60, "passed", "failed")));
</code></pre></li>
<li><p>获取并解析xml协议的Web Service</p>

<pre><code class="`">FeedType feed = JAXB.unmarshal(new URL("http://search.twitter.com/search.atom?&amp;q=java8"), FeedType.class);
JAXB.marshal(feed, System.out);
</code></pre></li>
<li><p>获得集合中最小/最大的数字</p>

<pre><code class="`"> int min = Stream.of(14, 35, -7, 46, 98).reduce(Integer::min).get();
 min = Stream.of(14, 35, -7, 46, 98).min(Integer::compare).get();
 min = Stream.of(14, 35, -7, 46, 98).mapToInt(Integer::new).min();

 int max = Stream.of(14, 35, -7, 46, 98).reduce(Integer::max).get();
 max = Stream.of(14, 35, -7, 46, 98).max(Integer::compare).get();
 max = Stream.of(14, 35, -7, 46, 98).mapToInt(Integer::new).max();
</code></pre></li>
<li><p>并行处理</p>

<pre><code class="`"> long result = dataList.parallelStream().mapToInt(line -&gt; processItem(line)).sum();
</code></pre></li>
<li><p>集合上的各种查询(LINQ in Java)</p>

<pre><code>List&lt;Album&gt; albums = Arrays.asList(unapologetic, tailgates, red);

//筛选出至少有一个track评级4分以上的专辑，并按照名称排序后打印出来。
albums.stream()
  .filter(a -&gt; a.tracks.stream().anyMatch(t -&gt; (t.rating &gt;= 4)))
  .sorted(comparing(album -&gt; album.name))
  .forEach(album -&gt; System.out.println(album.name));

//合并所有专辑的track
List&lt;Track&gt; allTracks = albums.stream()
  .flatMap(album -&gt; album.tracks.stream())
  .collect(toList());

//根据track的评分对所有track分组
Map&lt;Integer, List&lt;Track&gt;&gt; tracksByRating = allTracks.stream()
  .collect(groupingBy(Track::getRating));
</code></pre></li>
</ol>


<p>原文: <a href="https://github.com/aruld/java-oneliners/wiki">https://github.com/aruld/java-oneliners/wiki</a></p>

<hr />

<p><strong><em>补充 by 飒然Hang</em></strong>: 上述的<strong>单行代码编程</strong>确实能够减少代码的字符数，也经常能够给人以高大上的感觉，但是在Java编程中字符其实是非常廉价的，尤其是现在诸如Intellij等IDE已经具有自动补充/生成代码、重构等智能化功能。如果仅仅是为了减少字符的数量，那么没必要刻意去追求<strong>单行代码编程</strong>。让你的代码易于阅读才是最关键的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[译]更好地使用Java8中的方法引用]]></title>
    <link href="http://www.rowkey.me/blog/2017/09/02/java8-method-reference-work/"/>
    <updated>2017-09-02T19:29:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2017/09/02/java8-method-reference-work</id>
    <content type="html"><![CDATA[<p>在Java8中，使用方法引用非常简单，如String::isEmpty，但无法使用它否定的方法引用。本文内容即如何解决此问题使得我们能够更加全面地使用方法引用。</p>

<!--more-->


<p>首先看一个使用方法引用的例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Stream.of("A", "", "B").filter(String::isEmpty).count()</span></code></pre></td></tr></table></div></figure>


<p>上面代码的输出为1，即空字符串的数目。如果我们想要获取非空字符串的数目，就不能直接使用方法引用了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Stream.of("A", "", "B").filter(s -&gt; !s.isEmpty()).count()</span></code></pre></td></tr></table></div></figure>


<p>Java8中的Predicate，有predicate.negate()可以转换为断言的否定形式，但String::isEmpty却无法这么做(String::isEmpty.negate()或者!String::isEmpty)。因为方法引用并不是一个lambda或者函数接口，它能够被解析为一个或者多个函数接口。如，String::isEmpty至少可以被解析如下：</p>

<ul>
<li><code>Predicate&lt;String&gt;</code></li>
<li><code>Function&lt;String, Boolean&gt;</code></li>
</ul>


<p>为了解决上述的问题，我们可以通过某种机制显式地将方法引用转换为一个函数接口：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static &lt;T&gt; Predicate&lt;T&gt; as(Predicate&lt;T&gt; predicate) {
</span><span class='line'>    return predicate;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>通过使用一个静态方法，接受方法引用参数，返回一个函数接口，即可实现方法引用到函数接口的转换。接着，我们就可以使用方法引用来实现上面例子中的获取非空字符串的数目。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Stream.of("A", "", "B").filter(as(String::isEmpty).negate()).count();</span></code></pre></td></tr></table></div></figure>


<p>进一步还能使用各种组合的Predicate。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.filter(as(String::isEmpty).negate().and("A"::equals))</span></code></pre></td></tr></table></div></figure>


<p>由于一个方法引用可能会被解析为多种函数接口，因此如果我们实现很多参数不同的as方法，那么很容易造成混淆。更好的方式则是在方法名中加入函数参数的类型来区分。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import java.util.function.*;
</span><span class='line'>
</span><span class='line'>public class FunctionCastUtil {
</span><span class='line'>    public static &lt;T, U&gt; BiConsumer&lt;T, U&gt; asBiConsumer(BiConsumer&lt;T, U&gt; biConsumer) {
</span><span class='line'>        return biConsumer;
</span><span class='line'>    }
</span><span class='line'>    public static &lt;T, U, R&gt; BiFunction&lt;T, U, R&gt; asBiFunction(BiFunction&lt;T, U, R&gt; biFunction) {
</span><span class='line'>        return biFunction;
</span><span class='line'>    }
</span><span class='line'>    public static &lt;T&gt; BinaryOperator&lt;T&gt; asBinaryOperator(BinaryOperator&lt;T&gt; binaryOperator) {
</span><span class='line'>        return binaryOperator;
</span><span class='line'>    }
</span><span class='line'>    public static &lt;T, U&gt; BiPredicate&lt;T, U&gt; asBiPredicate(BiPredicate&lt;T, U&gt; biPredicate) {
</span><span class='line'>        return biPredicate;
</span><span class='line'>    }
</span><span class='line'>    public static BooleanSupplier asBooleanSupplier(BooleanSupplier booleanSupplier) {
</span><span class='line'>        return booleanSupplier;
</span><span class='line'>    }
</span><span class='line'>    public static &lt;T&gt; Consumer&lt;T&gt; asConsumer(Consumer&lt;T&gt; consumer) {
</span><span class='line'>        return consumer;
</span><span class='line'>    }
</span><span class='line'>    public static DoubleBinaryOperator asDoubleBinaryOperator(DoubleBinaryOperator doubleBinaryOperator) {
</span><span class='line'>        return doubleBinaryOperator;
</span><span class='line'>    }
</span><span class='line'>    public static DoubleConsumer asDoubleConsumer(DoubleConsumer doubleConsumer) {
</span><span class='line'>        return doubleConsumer;
</span><span class='line'>    }
</span><span class='line'>    public static &lt;R&gt; DoubleFunction&lt;R&gt; asDoubleFunction(DoubleFunction&lt;R&gt; doubleFunction) {
</span><span class='line'>        return doubleFunction;
</span><span class='line'>    }
</span><span class='line'>    public static DoublePredicate asDoublePredicate(DoublePredicate doublePredicate) {
</span><span class='line'>        return doublePredicate;
</span><span class='line'>    }
</span><span class='line'>    public static DoubleToIntFunction asDoubleToIntFunction(DoubleToIntFunction doubleToIntFunctiontem) {
</span><span class='line'>        return doubleToIntFunctiontem;
</span><span class='line'>    }
</span><span class='line'>    public static DoubleToLongFunction asDoubleToLongFunction(DoubleToLongFunction doubleToLongFunction) {
</span><span class='line'>        return doubleToLongFunction;
</span><span class='line'>    }
</span><span class='line'>    public static DoubleUnaryOperator asDoubleUnaryOperator(DoubleUnaryOperator doubleUnaryOperator) {
</span><span class='line'>        return doubleUnaryOperator;
</span><span class='line'>    }
</span><span class='line'>    public static &lt;T, R&gt; Function&lt;T, R&gt; asFunction(Function&lt;T, R&gt; function) {
</span><span class='line'>        return function;
</span><span class='line'>    }
</span><span class='line'>    public static IntBinaryOperator asIntBinaryOperator(IntBinaryOperator intBinaryOperator) {
</span><span class='line'>        return intBinaryOperator;
</span><span class='line'>    }
</span><span class='line'>    public static IntConsumer asIntConsumer(IntConsumer intConsumer) {
</span><span class='line'>        return intConsumer;
</span><span class='line'>    }
</span><span class='line'>    public static &lt;R&gt; IntFunction&lt;R&gt; asIntFunction(IntFunction&lt;R&gt; intFunction) {
</span><span class='line'>        return intFunction;
</span><span class='line'>    }
</span><span class='line'>    public static IntPredicate asIntPredicate(IntPredicate intPredicate) {
</span><span class='line'>        return intPredicate;
</span><span class='line'>    }
</span><span class='line'>    public static IntSupplier asIntSupplier(IntSupplier intSupplier) {
</span><span class='line'>        return intSupplier;
</span><span class='line'>    }
</span><span class='line'>    public static IntToDoubleFunction asIntToDoubleFunction(IntToDoubleFunction intToDoubleFunction) {
</span><span class='line'>        return intToDoubleFunction;
</span><span class='line'>    }
</span><span class='line'>    public static IntToLongFunction asIntToLongFunction(IntToLongFunction intToLongFunction) {
</span><span class='line'>        return intToLongFunction;
</span><span class='line'>    }
</span><span class='line'>    public static IntUnaryOperator asIntUnaryOperator(IntUnaryOperator intUnaryOperator) {
</span><span class='line'>        return intUnaryOperator;
</span><span class='line'>    }
</span><span class='line'>    public static LongBinaryOperator asLongBinaryOperator(LongBinaryOperator longBinaryOperator) {
</span><span class='line'>        return longBinaryOperator;
</span><span class='line'>    }
</span><span class='line'>    public static LongConsumer asLongConsumer(LongConsumer longConsumer) {
</span><span class='line'>        return longConsumer;
</span><span class='line'>    }
</span><span class='line'>    public static &lt;R&gt; LongFunction&lt;R&gt; asLongFunction(LongFunction&lt;R&gt; longFunction) {
</span><span class='line'>        return longFunction;
</span><span class='line'>    }
</span><span class='line'>    public static LongPredicate asLongPredicate(LongPredicate longPredicate) {
</span><span class='line'>        return longPredicate;
</span><span class='line'>    }
</span><span class='line'>    public static &lt;T&gt; LongSupplier asLongSupplier(LongSupplier longSupplier) {
</span><span class='line'>        return longSupplier;
</span><span class='line'>    }
</span><span class='line'>    public static LongToDoubleFunction asLongToDoubleFunction(LongToDoubleFunction longToDoubleFunction) {
</span><span class='line'>        return longToDoubleFunction;
</span><span class='line'>    }
</span><span class='line'>    public static LongToIntFunction asLongToIntFunction(LongToIntFunction longToIntFunction) {
</span><span class='line'>        return longToIntFunction;
</span><span class='line'>    }
</span><span class='line'>    public static LongUnaryOperator asLongUnaryOperator(LongUnaryOperator longUnaryOperator) {
</span><span class='line'>        return longUnaryOperator;
</span><span class='line'>    }
</span><span class='line'>    public static &lt;T&gt; ObjDoubleConsumer&lt;T&gt; asObjDoubleConsumer(ObjDoubleConsumer&lt;T&gt; objDoubleConsumer) {
</span><span class='line'>        return objDoubleConsumer;
</span><span class='line'>    }
</span><span class='line'>    public static &lt;T&gt; ObjIntConsumer&lt;T&gt; asObjIntConsumer(ObjIntConsumer&lt;T&gt; objIntConsumer) {
</span><span class='line'>        return objIntConsumer;
</span><span class='line'>    }
</span><span class='line'>    public static &lt;T&gt; ObjLongConsumer&lt;T&gt; asObjLongConsumer(ObjLongConsumer&lt;T&gt; objLongConsumer) {
</span><span class='line'>        return objLongConsumer;
</span><span class='line'>    }
</span><span class='line'>    public static &lt;T&gt; Predicate&lt;T&gt; asPredicate(Predicate&lt;T&gt; predicate) {
</span><span class='line'>        return predicate;
</span><span class='line'>    }
</span><span class='line'>    public static &lt;T&gt; Supplier&lt;T&gt; asSupplier(Supplier&lt;T&gt; supplier) {
</span><span class='line'>        return supplier;
</span><span class='line'>    }
</span><span class='line'>    public static &lt;T, U&gt; ToDoubleBiFunction&lt;T, U&gt; asToDoubleBiFunction(ToDoubleBiFunction&lt;T, U&gt; toDoubleBiFunction) {
</span><span class='line'>        return toDoubleBiFunction;
</span><span class='line'>    }
</span><span class='line'>    public static &lt;T&gt; ToDoubleFunction&lt;T&gt; asToDoubleFunction(ToDoubleFunction&lt;T&gt; toDoubleFunction) {
</span><span class='line'>        return toDoubleFunction;
</span><span class='line'>    }
</span><span class='line'>    public static &lt;T, U&gt; ToIntBiFunction&lt;T, U&gt; asToIntBiFunction(ToIntBiFunction&lt;T, U&gt; toIntBiFunction) {
</span><span class='line'>        return toIntBiFunction;
</span><span class='line'>    }
</span><span class='line'>    public static &lt;T&gt; ToIntFunction&lt;T&gt; asToIntFunction(ToIntFunction&lt;T&gt; ioIntFunction) {
</span><span class='line'>        return ioIntFunction;
</span><span class='line'>    }
</span><span class='line'>    public static &lt;T, U&gt; ToLongBiFunction&lt;T, U&gt; asToLongBiFunction(ToLongBiFunction&lt;T, U&gt; toLongBiFunction) {
</span><span class='line'>        return toLongBiFunction;
</span><span class='line'>    }
</span><span class='line'>    public static &lt;T&gt; ToLongFunction&lt;T&gt; asToLongFunction(ToLongFunction&lt;T&gt; toLongFunction) {
</span><span class='line'>        return toLongFunction;
</span><span class='line'>    }
</span><span class='line'>    public static &lt;T&gt; UnaryOperator&lt;T&gt; asUnaryOperator(UnaryOperator&lt;T&gt; unaryOperator) {
</span><span class='line'>        return unaryOperator;
</span><span class='line'>    }
</span><span class='line'>    private FunctionCastUtil() {
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>Stream.of("A", "", "B").filter(asPredicate(String::isEmpty).negate()).count();</span></code></pre></td></tr></table></div></figure>


<p>英文原文：<a href="https://dzone.com/articles/put-your-java-8-method-references-to-work">https://dzone.com/articles/put-your-java-8-method-references-to-work</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[谈谈架构]]></title>
    <link href="http://www.rowkey.me/blog/2017/08/24/arch/"/>
    <updated>2017-08-24T19:29:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2017/08/24/arch</id>
    <content type="html"><![CDATA[<p>之前开头的《架构设计原则》一文一直没有把坑填上。而最近在公司内部做了一次架构交流/培训，把架构的概念、架构的形式、架构设计原则都做了阐述，正好算是对此文的完成和补充。</p>

<p><a href="http://www.rowkey.me/arch-ppt/index.html" target="_blank">PPT观看</a></p>

<!--more-->


<p><img src="http://www.rowkey.me/images/blog_images/arch/arch-2.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/arch/arch-3.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/arch/arch-4.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/arch/arch-5.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/arch/arch-6.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/arch/arch-7.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/arch/arch-8.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/arch/arch-9.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/arch/arch-10.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/arch/arch-11.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/arch/arch-12.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/arch/arch-13.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/arch/arch-14.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/arch/arch-15.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/arch/arch-16.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/arch/arch-17.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/arch/arch-18.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/arch/arch-19.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/arch/arch-20.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/arch/arch-21.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/arch/arch-22.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/arch/arch-23.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/arch/arch-24.jpeg" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[译]在Java中提升函数以更好地“函数式”编程]]></title>
    <link href="http://www.rowkey.me/blog/2017/08/18/lift-functions/"/>
    <updated>2017-08-18T19:29:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2017/08/18/lift-functions</id>
    <content type="html"><![CDATA[<p>Java8中的Stream和Optional给我们带来了函数式编程的乐趣，但Java仍然缺少很多函数编程的关键特性。Lambda表达式、Optional和Stream只是函数式编程的冰山一角。这也导致了<a href="https://github.com/vavr-io/vavr">varvr</a>和<a href="https://github.com/functionaljava/functionaljava">functionlajava</a>这些类库的出现，他们都源于Haskell这个纯函数式编程语言。</p>

<p>如果想要更加地“函数式”编程，那么首先要注意的是不要过早的中断monad(一种设计模式，表示将一个运算过程通过函数拆解成互相连接的多个步骤。只要提供下一步运算所需的函数，整个运算就会自动进行下去, Optional、Stream都是monad)，比如，很多人经常会在还不需要的时候就调用了Optional.get()和Stream.collect()提前终止monad。本文主要讲述如何通过提升方法来使得代码更&#8221;函数式&#8221;。</p>

<!--more-->


<p>假设有一个接口可以对数字进行计算。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public interface Math {
</span><span class='line'>    int multiply(int a, int b);
</span><span class='line'>    double divide(int a, int b);
</span><span class='line'>    ..
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>我们要使用这个接口来对使用Optional做包装的数字做计算。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public interface NumberProvider {
</span><span class='line'>    Optional&lt;Integer&gt; getNumber();
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>接着我们来实现一个方法能够返回两个数字相除的结果，结果用Optional包装。如果这两个数字有一个为空则返回空Optional。如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public Optional&lt;Double&gt; divideFirstTwo(NumberProvider numberProvider, Math math) {
</span><span class='line'>    Optional&lt;Integer&gt; first = numberProvider.getNumber();
</span><span class='line'>    Optional&lt;Integer&gt; second = numberProvider.getNumber();
</span><span class='line'>    if(first.isPresent() && second.isPresent()) {
</span><span class='line'>        double result = math.divide(first.get(), second.get());
</span><span class='line'>        return Optional.of(result);
</span><span class='line'>    } else {
</span><span class='line'>        return Optional.empty();
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>上面的代码非常不优雅，有大量的代码都是在做Optional的包装和解包装。可以让上面的代码变得更加“函数式”，如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public Optional&lt;Double&gt; divideFirstTwo(NumberProvider numberProvider, Math math) {
</span><span class='line'>    return numberProvider.getNumber()
</span><span class='line'>           .flatMap(first -&gt; numberProvider.getNumber()
</span><span class='line'>                                     .map(second -&gt; math.divide(first, second)));
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这样代码少了很多，也优雅了很多。先调用第一个Optional的flatMap，再在lambda中调用第二个Optional的map，进一步可以抽取出一个提升方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public interface Optionals {
</span><span class='line'>    static &lt;R, T, Z&gt; BiFunction&lt;Optional&lt;T&gt;, Optional&lt;R&gt;, Optional&lt;Z&gt;&gt; lift(BiFunction&lt;? super T, ? super R, ? extends Z&gt; function) {
</span><span class='line'>        return (left, right) -&gt; left.flatMap(leftVal -&gt; right.map(rightVal -&gt; function.apply(leftVal, rightVal)));
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>如上，可知这个方法提升能够提升任何具有两个Optional参数、一个Optional结果的函数，使得被提升的函数具有Optional的一个特性：如果一个参数是空的，那么结果就是空的。如果JDK抽取flatMap和map到一个公共接口，如Monad，那么我们可以为Java Monad的每一个实例(Stream、Optional、自己的实现类)实现一个公共的提升函数。但现实是我们不得不为每一个实例都复制粘贴上面的代码。最终的divideFirstTwo代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import static com.ps.functional.monad.optional.Optionals.lift;
</span><span class='line'>...
</span><span class='line'>public Optional&lt;Double&gt; divideFirstTwo(NumberProvider numberProvider, Math math) {
</span><span class='line'>    return lift(math::divide).apply(numberProvider.getNumber(), numberProvider.getNumber());
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><strong>ps: 此文内容来自<a href="https://dzone.com/articles/lifting-functions-to-work-with-monads-in-java?edition=311409&amp;edition=0&amp;utm_source=Zone%20Newsletter&amp;utm_medium=email&amp;utm_campaign=java%202017-08-01">https://dzone.com/articles/lifting-functions-to-work-with-monads-in-java?edition=311409&amp;edition=0&amp;utm_source=Zone%20Newsletter&amp;utm_medium=email&amp;utm_campaign=java%202017-08-01</a>，加入了本人的理解和认知。</strong></p>
]]></content>
  </entry>
  
</feed>
