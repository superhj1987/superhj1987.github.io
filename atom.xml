<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[后端技术杂谈]]></title>
  <link href="http://www.rowkey.me/atom.xml" rel="self"/>
  <link href="http://www.rowkey.me/"/>
  <updated>2022-06-08T14:57:09+00:00</updated>
  <id>http://www.rowkey.me/</id>
  <author>
    <name><![CDATA[Mr.RowKey]]></name>
    <email><![CDATA[superhj1987@126.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[架构简明指南2022最新版]]></title>
    <link href="http://www.rowkey.me/blog/2022/06/04/arch-usage/"/>
    <updated>2022-06-04T11:29:34+00:00</updated>
    <id>http://www.rowkey.me/blog/2022/06/04/arch-usage</id>
    <content type="html"><![CDATA[<p>《Clean Architecture》一书中对于软件架构目的的解释：</p>

<blockquote><p>The goal of software architecture is to miminize the human resources required to build and maintain the required system.</p></blockquote>

<p>即：软件架构的目的就是将构建和维护系统需要的人力成本降到最低。</p>

<p>因此，可以得出架构设计的关键思维就是判断和取舍（程序设计的关键思维是逻辑和实现），即如何选择技术、组合技术使得需要的人力资源最少。</p>

<p>需要注意的一点是，脱离业务谈架构是不合理的，技术架构及其演进都是业务目标驱动的。</p>

<!--more-->


<h2>架构六步思考法</h2>

<blockquote><p>笔者对美团总架构师夏华夏一次分享提出的架构六步思考法的理解。</p></blockquote>

<p><img src="http://www.rowkey.me/post_images/arch-six-think.png" width="450"/></p>

<p>这里尤其需要注意的一点是在面对问题时，首先要试图将未知问题转化为已知问题，而不是创造新问题。</p>

<h2>架构手段</h2>

<p>架构的目的就是解决复杂度，主要包括高性能、高可用以及可扩展三方面。此外，分布式系统是架构工作中面对的典型复杂系统，对于其中常见的问题有一些常用应对手段。</p>

<h3>高可用</h3>

<blockquote><p>高可用=系统构建在多机=分布式系统</p></blockquote>

<ul>
<li>冗余：同城多活或者异地多活</li>
<li>降级：需要对各个关键节点建立降级预案。能够在超出预估流量时，保证大部分用户的服务是正常的。包括一个请求经过的多有节点。以轮训实现的直播系统为例：</li>
</ul>


<table>
<thead>
<tr>
<th>节点 </th>
<th> 手段 </th>
<th> 说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>客户端     </td>
<td> 拉取频率降级 </td>
<td> 服务端实时修改轮训时间</td>
</tr>
<tr>
<td>.        </td>
<td> 防雪崩策略 </td>
<td> 轮训出错后，自动指数级增大轮训时间</td>
</tr>
<tr>
<td>.        </td>
<td> 点赞消息合并 </td>
<td> 在客户端合并，减少服务端处理消息数目</td>
</tr>
<tr>
<td>Nginx      </td>
<td> 接口限流 </td>
<td> 针对接口，限制QPS</td>
</tr>
<tr>
<td>业务容器   </td>
<td> 拉取条数自动降级 </td>
<td> 可在线修改每种消息类型的返回条数</td>
</tr>
<tr>
<td>.        </td>
<td> 上行频率降级 </td>
<td> 可降级点赞、评论的频率限制</td>
</tr>
<tr>
<td>Kafka      </td>
<td>  容灾队列 </td>
<td> Kafka故障时写入容灾队列</td>
</tr>
<tr>
<td>消息处理BG </td>
<td> 自动丢弃消息 </td>
<td> 非重要消息可以视情况丢弃</td>
</tr>
<tr>
<td>.        </td>
<td> 处理延迟降级 </td>
<td> 根据延迟大小，采用加锁串行和不加锁并行处理策略</td>
</tr>
</tbody>
</table>


<ul>
<li>全链路业务监控：对请求链路上的所有结点都加入监控。包括客户端的APM、错误日志、JVM监控、QPS、状态码、延时、服务器资源的基础监控（带宽、CPU、内存、IO）等。示例如下：</li>
</ul>


<table>
<thead>
<tr>
<th>节点 </th>
<th> 监控内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>客户端     </td>
<td> APM</td>
</tr>
<tr>
<td>Nginx      </td>
<td> 错误码监控和报警；访问QPS、接口耗时分布、带宽</td>
</tr>
<tr>
<td>业务应用   </td>
<td> 错误日志、QPS、状态码、延时；JVM；依赖服务的QPS、状态码、延时</td>
</tr>
<tr>
<td>Kafka      </td>
<td> 消息堆积</td>
</tr>
<tr>
<td>消息处理BG </td>
<td> 错误日志；JVM；消息处理数目，消息处理延时</td>
</tr>
<tr>
<td>基础资源   </td>
<td> 带宽、CPU利用率、内存、磁盘</td>
</tr>
</tbody>
</table>


<h3>高性能</h3>

<blockquote><p>分布式系统的副产品</p></blockquote>

<ul>
<li>数据库集群</li>
<li>缓存架构</li>
<li>负载均衡</li>
<li>NoSQL：不局限于关系型数据库，在合适的场景下选择NoSQL数据库会带来性能的提升</li>
<li>异构索引：分区情况下，为提升未按拆分键进行查询的场景的性能，通过构建异构索引表。先通过查询异构索引表得到目标记录的主键，然后再根据记录主键查询，从而避免全库全表扫描</li>
</ul>


<p><strong>低延迟方案</strong>[系统响应性能提升]</p>

<ul>
<li><strong>异步</strong>：队列缓冲、异步请求。</li>
<li><strong>并发</strong>：利用多CPU多线程执行业务逻辑。</li>
<li><strong>就近原则</strong>：缓存、梯度存储。</li>
<li><strong>减少IO</strong>：合并细粒度接口为粗粒度接口、频繁的覆盖操作可以只做最后一次操作。这里一个需要特别注意的地方: <strong>代码中尽量避免在循环中调用外部服务，更好的做法是使用粗粒度批量接口在循环外面只进行一次请求。</strong></li>
<li><strong>分区</strong>：频繁访问的数据集规模保持在合理的范围。</li>
</ul>


<p><strong>高吞吐方案</strong></p>

<ul>
<li>分层调用：接入层、逻辑层、数据层，通过Proxy或者Router对逻辑层做集群管理</li>
<li>异步并发</li>
</ul>


<h3>可扩展</h3>

<ul>
<li>分层架构/简洁架构：单向依赖，职责清晰。</li>
<li>SOA：面向服务架构，服务粒度较大。</li>
<li>微内核：可插拔式架构，适用于客户端。</li>
<li>微服务：适用于复杂的大型系统，细粒度服务。</li>
</ul>


<p><strong>系统扩展思路</strong></p>

<ul>
<li>通过克隆扩展->高可用</li>
<li>通过拆分不同的东西来扩展->垂直扩展</li>
<li>拆分类似的东西来扩展->水平扩展</li>
</ul>


<h3>分布式系统</h3>

<ol>
<li><p>海量请求问题</p>

<p> 本质即如何达到高吞吐、低延迟、高可用，上文已经讲述。</p></li>
<li><p>大量服务器管理</p>

<ul>
<li>故障恢复和可扩展性：分布式目录服务、消息队列服务、分布式事务系统</li>
<li>运维便利性：自动部署工具、集中日志分析系统、全链路监控</li>
</ul>
</li>
<li><p>开发效率</p>

<ul>
<li>复杂通信编程：微服务框架、异步编程工具</li>
<li>大量模块分工：Iaas/Paas/Saas云服务</li>
</ul>
</li>
</ol>


<h2>架构原则</h2>

<p><img src="http://www.rowkey.me/images/blog_images/arch-spec.png" alt="" /></p>

<ul>
<li><strong>避免过度设计</strong>：简单的架构就是最好的架构。最简单的方案最容易实现和维护，也可以避免浪费资源。但方案中需要包括扩展。</li>
<li><strong>冗余设计</strong>：对服务、数据库的做结点冗余，保证服务的高可用。通过数据库主从模式、应用集群来实现。</li>
<li><strong>多活数据中心</strong>：为了容灾，从根本上保障应用的高可用性。需要构建多活的数据中心，以防止一个数据中心由于不可控因素出现故障后，引起整个系统的不可用。</li>
<li><strong>无状态设计</strong>：API、接口等的设计不能有前后依赖关系，一个资源不受其他资源改动的影响。无状态的系统才能更好地进行扩展。如果非得有状态，则要么客户端管理状态，要么服务端用分布式缓存管理状态。</li>
<li><strong>可回滚</strong>：对于任何业务尤其是关键业务，都具有恢复机制。可以使用基于日志的WAL、基于事件的Event sourcing等来实现可回滚。</li>
<li><strong>可禁用/自我保护</strong>：具有限流机制，当上游的流量超过自身的负载能力时，能够拒绝溢出的请求。可以通过手动开关或者自动开关（监测异常流量行为），在应用前端挡住流量。限流算法包括：令牌桶（支持突发流量）、漏桶（匀速流量）、计数器以及信号量（限制并发访问的数量）。此外永远不要信赖第三方服务的可靠性，依赖于第三方的功能务必有服务降级措施以及熔断管理，如：对于每一个网络操作，都需要设置超时时间，超过这个时间就放弃或者返回兜底响应。</li>
<li><strong>问题可追踪</strong>：当系统出现问题时，能够定位请求的轨迹、每一步的请求信息等。分布式链路追踪系统即解决的此方面的问题。</li>
<li><strong>可监控</strong>：可监控是保障系统能够稳定运行的关键。包括对业务逻辑的监控、应用进程的监控以及应用依赖的CPU、硬盘等系统资源的监控。每一个系统都需要做好这几个层面的监控。</li>
<li><strong>故障隔离</strong>：将系统依赖的资源(线程、CPU)和服务隔离开来能够使得某个服务的故障不会影响其他服务的调用。通过线程池或者分散部署结点可以对故障进行隔离。此外，为不同的用户提供单独的访问通道，不仅仅能够做故障隔离，也有利于做用户权限控制。</li>
<li><strong>成熟可控的技术选型</strong>：使用市面上主流、成熟、文档、支持资源多的技术，选择合适的而非最火的技术实现系统。如果面对自研和开源技术的选择，需要考虑契合度：如果功能需求契合度很高，那么选择开源即可；如果开源技术是需求的子集或者超集，那么要衡量吃透这个开源技术的成本和自研的成本那个高。</li>
<li><strong>梯级存储</strong>：内存->SSD硬盘->传统硬盘->磁带，可以根据数据的重要性和生命周期对数据进行分级存储。</li>
<li><strong>缓存设计</strong>：隔离请求与后端逻辑、存储，是就近原则的一种机制。包括客户端缓存（预先下发资源）、Nginx缓存、本地缓存以及分布式缓存。</li>
<li><strong>异步设计</strong>：对于调用方不关注结果或者允许结果延时返回的接口，采用队列进行异步响应能够很大程度提高系统性能；调用其他服务的时候不去等待服务方返回结果直接返回，同样能够提升系统响应性能。异步队列也是解决分布式事务的常用手段。</li>
<li><strong>前瞻性设计</strong>：根据行业经验和对业务量的预判，提前把可扩展性、后向兼容性、容量预警设计好。以防止超过系统容量后造成各种问题影响服务。</li>
<li><strong>水平扩展</strong>：相比起垂直扩展，能够通过堆机器解决问题是最优先考虑的问题，系统的负载能力也才能接近无限扩展。此外，基于<strong>云计算</strong>技术根据系统的负载自动调整容量能够在节省成本的同时保证服务的可用性。</li>
<li><strong>小步构建和发布</strong>：快速迭代项目，快速试错。不能有跨度时间过长的项目规划。</li>
<li><strong>自动化</strong>：打包、测试的自动化称为持续集成，部署的自动化称为持续部署。自动化机制是快速迭代和试错的基础保证。</li>
</ul>


<h2>技术选型原则</h2>

<ol>
<li>是否是生产级别、成熟的产品。<strong>生产级、可运维、可治理、成熟稳定</strong>的技术是首选。技术是有生命周期的，需要保持对新技术的敏感度，但切忌不要在技术的早期就开始使用。版本号、用的公司数量、文档完善度、运维支持能力（日志、命令行、控制台、故障检测恢复能力）都是成熟度的体现。</li>
<li>新技术的引入一定要坚持<strong>少即是多</strong>的原则，能不引入新技术尽量不要引入新技术。毕竟新技术的引入既有学习成本，又有维护成本。并且对于一个公司来说技术栈越多，那么学习和维护成本就越高，技术栈知识无法共享，技术体系无法建立，会严重影响研发效率和业务规模化能力。如果到了必须要引入的地步，一定要有严格的技术评审流程。</li>
<li>在引入一项新技术之前，要充分调研<strong>了解新技术的先决条件</strong>，不能盲目引入。对于确实需要引入但是目前还不满足先决条件的，需要做好阶段性规划，先打好基础，再适时引入新技术。</li>
<li><strong>不要盲目跟风大公司</strong>。很多时候适合大公司的技术并不适合小公司。毕竟大公司有充足的人力、资源和时间，这是小公司无法相比的。</li>
<li><strong>技术是带有文化特性的</strong>。在国外流行的技术，在国内未必流行。在选型的时候，尽量采用在国内有文化基础，已经落地开花的技术。此外，不同公司流行的技术文化也不相同，需要考虑自己公司的业务模式、已有技术生态和开发人员技能等。</li>
<li><strong>使用能掌控的技术</strong>。需要根据业务规模、团队规模和人员水平，经过综合评估对技术进行分析，以决定是否引入。</li>
<li>对于关键技术一定要找到<strong>合适的人</strong>来使用和研发。交给不合适的人，不仅无法解决问题，反而会制造更多的问题。</li>
<li><strong>抵制技术的宗教信仰</strong>，技术没有绝对的好坏优劣，只有合适与不合适、使用场景等。</li>
<li><strong>实践出真知</strong>。对新技术的引入一定要在仔细研究其文档的基础上跑样例、做压力测试，甚至通读其源码，经过一些试点项目验证后再逐渐扩大使用规模。</li>
<li>对于某些复杂、重量级技术的落地是有生命周期的，务必要<strong>通盘考虑，制定落地计划，分阶段推进</strong>技术的落地（引入、定制改造、小规模试点再到逐步扩大生产规模）。</li>
<li><strong>自研、开源、购买</strong>的选择。如果不是最擅长也提供不了差异化竞争优势的技术在成本允许的情况下直接采用开源或者购买即可；处在关键链路上的核心技术，一定要有定制或者自研的能力。此外，创业公司尽量采用开源技术或者购买云服务，而随着公司业务规模的增长，那么逐渐需要有定制和自研能力。</li>
</ol>


<p>此外，对于开源技术还需要注意：</p>

<ol>
<li><strong>是否是一线互联网公司落地产品</strong>。例如阿里开源的很多软件都是其在内部经过生产环境验证过的，形成了闭环的。而很多第三方软件服务商则仅仅是开源，并没有自身的需求，因此需要社区一起使用反馈从而形成闭环，这也就意味着你要和他一起踩坑形成闭环。</li>
<li><strong>是否有背书的大公司或者组织</strong>。例如Google一开始推出的K8S并不具有优势，然而由于Google的强大号召力和背书能力，因此促使大批用户使用从而形成了闭环，使得K8S目前基本垄断了容器PAAS市场。同样的，Apache下的开源项目绝大多数也是可以值得信赖的。</li>
<li><strong>开源社区是否活跃</strong>。Github上的stars的数量是一个重要指标，同时会参考其代码和文档更新频率（尤其是最近几年），这些指标直接反应开源产品的生命力。</li>
</ol>


<h2>数据设计原则</h2>

<ul>
<li>注意存储效率

<ul>
<li>减少事务</li>
<li>减少联表查询</li>
<li>适当使用索引</li>
<li>考虑使用缓存</li>
</ul>
</li>
<li>避免依赖于数据库的运算功能(函数、存储器、触发器等)，将负载放在更容易扩展的业务应用端</li>
<li>数据统计场景中，实时性要求较高的数据统计可以用Redis；非实时数据则可以使用单独表，通过队列异步运算或者定时计算更新数据。此外，对于一致性要求较高的统计数据，需要依靠事务或者定时校对机制保证准确性。</li>
<li>索引区分度法则：辨识度超过20%的属性，如果有查询需求，就应该建立索引。</li>
<li>对于数值型数据，可以使用保序压缩方式在保证顺序不变的前提下减少字符串长度。如：进行36进制转化即一种保序压缩方式。</li>
<li>大量数据的去重计数如果允许误差可以选择基数估计算法（Hyperhyperlog、Loglogcount）或者布隆过滤器。</li>
</ul>


<h2>系统稳定性原则</h2>

<ul>
<li>灰度发布，尽量减少影响的范围</li>
<li>慢查询review</li>
<li>防御式编程，不要相信任何人和服务：自动熔断，手动降级</li>
<li>SOP(标准操作流程)：工具化、自动化</li>
<li><strong>例行巡检！！！</strong>：DB、调用链、P90响应时间</li>
<li>容量规划：见下面“容量规划”部分</li>
</ul>


<p>SOP示例：</p>

<table>
<thead>
<tr>
<th>需求管理 </th>
<th> 项目开发 </th>
<th>  测试  </th>
<th>  发布上线 </th>
<th> 监控报警 </th>
<th> 故障处理</th>
</tr>
</thead>
<tbody>
<tr>
<td>Task管理、技术评审、<strong>上下游依赖变化review</strong> </td>
<td> 分支管理、交叉代码Review、代码规范、日志规范、代码静态检查 </td>
<td> 单元测试、冒烟测试、回归测试、办公室测试、线上压测 </td>
<td> 线上发布、验证业务效果 </td>
<td> 业务指标监控、系统监控dashboard </td>
<td> 第一时间向上级反馈、及时周知业务方：问题、影响范围、解决方案、预计恢复时间、线上服务降级</td>
</tr>
</tbody>
</table>


<h2>系统容量规划</h2>

<p>需要对系统/关键模块做好评估、量化，以防止超出容量时不至于压垮服务器，仍然能够服务于大部分用户。</p>

<p><img src="http://www.rowkey.me/post_images/capacity-plan.png" alt="" /></p>

<ol>
<li>根据流量模型、历史数据、预测算法预估未来某一个时间点的业务量：QPS、每日数据量等。</li>
<li>评估单点最大承载量（数据库的单点承载数据量、应用服务器的单点承载并发量）【通过性能测试】，根据业务量计算需要部署的结点数目，做1.5倍部署（DID原则）。</li>
<li>性能压测验证整个系统的负载能力。</li>
<li>设计达到容量预估值时的预警、限流、快速恢复措施以及后续扩展方案。</li>
</ol>


<p>PS: 在容量预估中，机器数目的计算遵循DID原则：20倍设计、3倍实施/实现、1.5倍部署。即需要部署1.5倍的可承载预估业务流量的机器数目。</p>

<h2>架构隐患分析</h2>

<h3>FEMA方法分析表格</h3>

<ul>
<li>功能点：用户角度</li>
<li>故障模式：系统会出现的故障，量化描述</li>
<li>故障影响：功能点会受到什么影响</li>
<li>严重程度：对业务的影响程度。致命/高/中/低/无</li>
<li>故障原因：故障出现的原因</li>
<li>故障概率：某个具体故障原因发生的概率</li>
<li>风险程度：综合考虑严重程度和故障概率，严重程度 × 故障概率</li>
<li>已有措施：故障发生时的应对措施。包括检测告警、容错、自恢复等。</li>
<li>规避措施：降低故障发生概率而做的事情，包括技术手段和管理手段。</li>
<li>解决措施：此问题的彻底解决办法</li>
<li>后续规划：后续改进计划，包括技术手段、管理手段，可以是规避措施，也可以是解决措施。风险程度越高的隐患解决的优先级越高</li>
</ul>


<h3>FEMA方法分析示例</h3>

<table>
<thead>
<tr>
<th>功能点 </th>
<th> 故障模式 </th>
<th> 故障影响 </th>
<th> 严重程度 </th>
<th> 故障原因 </th>
<th> 故障概率 </th>
<th> 风险程度 </th>
<th> 已有措施 </th>
<th> 规避措施 </th>
<th> 解决措施 </th>
<th> 后续规划</th>
</tr>
</thead>
<tbody>
<tr>
<td>登录 </td>
<td> 用户中心MySQL响应时间超过5秒 </td>
<td> 用户登录缓慢 </td>
<td> 高 </td>
<td> MySQL中有慢查询 </td>
<td> 高 </td>
<td> 高 </td>
<td> 慢查询监测 </td>
<td> 杀死慢查询进程；重启MySQL </td>
<td> 无 </td>
<td> 优化慢查询语句</td>
</tr>
<tr>
<td>刷新资讯列表 </td>
<td> Redis无法访问 </td>
<td> 当Redis无法访问，那么基于Redis的画像、内容等都无法响应，会影响100%的用户 </td>
<td> 高 </td>
<td> Redis服务宕机 </td>
<td> 低 </td>
<td> 中 </td>
<td> 无 </td>
<td> 无 </td>
<td> 无 </td>
<td> 依赖于UCloud的Redis服务会有风险，需要自建Redis分摊风险</td>
</tr>
</tbody>
</table>


<h2>架构重构的原则</h2>

<p>一个系统的架构是随着业务而不断演化的，因此不可避免地会留下很多技术债。如果一味地不去管，那么总有一天技术债会爆发出来造成意想不到的破坏。因此很多时候对架构的重构是必须的。其需要遵循的原则如下：</p>

<ul>
<li>确定重构的目的和必要性：为了业务需要；有无其他备选方案</li>
<li>定义“重构完成”的界限</li>
<li>渐进式重构</li>
<li>确定当前的架构状态</li>
<li>不要忽略数据</li>
<li>管理好技术债务</li>
<li>远离那些虚荣的东西</li>
<li>做好面对压力的准备</li>
<li>了解业务</li>
<li>做好面对非技术因素的准备</li>
<li>能够掌握代码质量</li>
</ul>


<h2>架构改造实施模式</h2>

<ul>
<li>拆迁者模式：根据业务需求，对架构进行重新设计，也就是一次性重写所有代码。此种模式成本大，不能很好地支撑持续交付，架构改造风险也较大。</li>
<li>绞杀者模式：保持遗留系统不变，新的功能重新开发为新的系统/服务，逐渐替代掉遗留系统。适用于庞大难以更改的遗留系统。</li>
<li>修缮者模式：将旧的待改造的部分/模块进行隔离（通过增加中间层解决，中间层可以是抽象类、接口等），通过迭代，在原有遗留系统内部对其进行逐步改造，改造的同时要保证与其他部分仍能协同工作。</li>
</ul>


<h2>在线数据迁移</h2>

<p>在线数据迁移指将正在提供线上服务的数据，从一个地方迁移到另一个地方，迁移过程中服务不受影响。这种场景是系统演进过程中都会出现的问题，包括业务演进的需要和性能扩展的需要。典型的步骤如下：</p>

<p><img src="http://www.rowkey.me/post_images/data-mig.png" alt="" /></p>

<ol>
<li>上线双写：在业务系统里写代码，同时向新旧数据存储写入数据。此步骤完成后，需要进行一致性验证，包括存储维度和业务维度。前者指对比原数据存储和新数据存储中的数据对比，后者指从用户看到的数据维度进行对比。</li>
<li>历史数据迁移：将历史数据从旧存储迁移到新存储。包括离线和在线两种。离线是编写批量处理程序或者依靠数据存储的同步机制从旧存储查询历史数据（开启双写以前的数据）插入到新存储中。在线指的是依赖数据存储的同步机制在线同步数据，如MySQL的binlog、MongoDB的OpLog。此过程，建议在部分数据迁移后就进行一致性验证，通过后再全量数据迁移。</li>
<li>切读：通过灰度的方式逐渐切换请求到新系统上，灰度可以通过在代码中埋入开关来逐步的放大读新系统的请求量。一般的流程：预发布/Tcpcopy环境(验证代码运行正常)->办公室环境/线上环境uid白名单（内部用户，验证功能正常）->线上环境百分比0.1%、1%、%10%（进一步验证功能正常以及性能和资源压力）->线上环境全量。此过程建议持续一到两周。</li>
<li>清理：数据迁移验证通过后，清理业务系统的双写代码和开关代码等逻辑代码、旧存储的数据和配套系统以及旧的资源等。</li>
</ol>


<p>某些情况下，可以先做历史数据搬迁，然后再写入新数据。需要谨慎的处理搬迁这段时间里产生的新数据，一般使用 queue 缓存写入的方式，称为“追数据”。</p>

<p>此外，如果是单一功能的在线数据迁移，可以参考Redis Cluster数据重分配的实现机制。</p>

<ol>
<li>离线程序迁移数据，并维护数据迁移状态：未迁移、迁移中、迁移完成。</li>
<li>业务代码做统一控制。发生数据读写时，如果数据状态是迁移中，那么阻塞等待至迁移完毕再执行后续操作；如果数据的状态是迁移完成或者是新数据则直接执行后续逻辑；如果数据状态是未迁移，那么就主动发起迁移或者等待离线迁移完成。</li>
</ol>


<h2>其他</h2>

<ul>
<li>系统设计流程四部走：识别复杂度->设计备选方案->评估和选择备选方案->详细方案设计</li>
<li>讨论技术方案时，以是否合理为依据，而不要以工作量少为依据。</li>
<li>对遗留系统进行垂直分离成本比较大时，可以考虑直接clone项目部署单独的集群，用服务地址分隔开，不同的接口走不同的服务地址。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[阅文笔记202205]]></title>
    <link href="http://www.rowkey.me/blog/2022/05/04/article-notes/"/>
    <updated>2022-05-04T11:29:34+00:00</updated>
    <id>http://www.rowkey.me/blog/2022/05/04/article-notes</id>
    <content type="html"><![CDATA[<p>记录在阅读公众号、博客上一些好的文章时的笔记和心得。</p>

<!--more-->


<h2>一.《张一鸣：为什么 BAT 挖不走我们的人才？》</h2>

<p><a href="https://mp.weixin.qq.com/s?__biz=MzI3MzEzMDI1OQ==&amp;mid=2651821900&amp;idx=1&amp;sn=04fd5b9295c4a69b3fee3bbc38b53209">https://mp.weixin.qq.com/s?__biz=MzI3MzEzMDI1OQ==&amp;mid=2651821900&amp;idx=1&amp;sn=04fd5b9295c4a69b3fee3bbc38b53209</a></p>

<blockquote><p>人成功了就会到处说自己多厉害，张一鸣自然有他的独到之处，但是这些东西可能也就适用于头条。</p></blockquote>

<ul>
<li>流程的好处与坏处：没有流程会乱，流程太多会束缚</li>
<li>优秀的人只需要原则即可</li>
<li>员工激励

<ul>
<li>最好的ROI，找优秀的人，干优秀的事</li>
<li>把更多的激励放到事后，放到年终，把更多的激励换成与个人贡献相关而不是与投资眼光相关。</li>
<li>公平理性按照岗位职级和绩效考核定薪酬</li>
</ul>
</li>
<li>好的特质：满足感</li>
</ul>


<h2>二. 《没有被了解的API？一个老码农眼中的API世界》</h2>

<p><a href="https://mp.weixin.qq.com/s?__biz=MzAwOTcyNzA0OQ==&amp;mid=2658975476&amp;idx=1&amp;sn=6b912551bddce66214a80987042fe963">https://mp.weixin.qq.com/s?__biz=MzAwOTcyNzA0OQ==&amp;mid=2658975476&amp;idx=1&amp;sn=6b912551bddce66214a80987042fe963</a></p>

<blockquote><p>文章有点难懂，不过API的设计和实现确实是一个值得好好思考的事情。</p></blockquote>

<ul>
<li>API设计的经验性原则

<ul>
<li>功能的完整性</li>
<li>调用的简单性</li>
<li>设计的场景化：预期的场景用例</li>
<li>有无策略性的设置：  使用回调、虚函数、代理或模板等来实现调用者的策略设置</li>
<li>面向用户的设计：调用者编写函数名</li>
<li>不推卸责任

<ul>
<li>害怕设置策略，函数参数多达十个</li>
<li>牺牲可用性来提高效率</li>
</ul>
</li>
<li>清晰的文档化

<ul>
<li>最不适合编写文档的人是API的实现者</li>
<li>最不适合编写文档的时间是在实现之后</li>
<li>确保文档是完整的，特别是关于错误处理的文档</li>
</ul>
</li>
<li>API的人体工程学

<ul>
<li>一致性问题：相同顺序放置特定类型的参数；统一的错误处理</li>
</ul>
</li>
</ul>
</li>
<li>性能约定

<ul>
<li>分类

<ul>
<li>恒定的性能</li>
<li>通常的性能</li>
<li>可预期的性能</li>
<li>未知的性能</li>
</ul>
</li>
<li>按性能划分API</li>
<li>API的性能变化</li>
<li>API调用失败时的性能</li>
<li>确保API性能的经验方法

<ul>
<li>谨慎地选择API和程序结构：考虑性能约定</li>
<li>在新版本发布时提供一致的性能约定</li>
<li>防御性编程</li>
<li>API公开的参数调优</li>
<li>测量性能以验证假设</li>
<li>使用日志检测和记录异常</li>
</ul>
</li>
<li>API设计的文化认知

<ul>
<li> API的有意识训练</li>
<li> API设计人才的流失</li>
<li> 开放与控制</li>
</ul>
</li>
</ul>
</li>
</ul>


<h2>三. 《疫情下技术的应对之道-成本篇》</h2>

<p><a href="https://mp.weixin.qq.com/s?__biz=MzUxMTEwODc5OA==&amp;mid=2247483665&amp;idx=1&amp;sn=663a412b14cff8d39a86f0c2db7c25b8">https://mp.weixin.qq.com/s?__biz=MzUxMTEwODc5OA==&amp;mid=2247483665&amp;idx=1&amp;sn=663a412b14cff8d39a86f0c2db7c25b8</a></p>

<blockquote><p>最近公司也在做技术成本优化，这篇文章系统化地阐述了优化措施，给了自已一些思路。</p></blockquote>

<ul>
<li>考虑降本介入的时机：业务发展平稳期</li>
<li>统一思想：多部门配合，顶层推动，明确衡量标准，统一制定目标，分解KPI，分阶段落实</li>
<li>制定可量化的指标。目标一定要和业务结合起来。【这一点我之前忽视了，单单去追求价格了，其实应该和业务结合了】

<ul>
<li>电商：每订单IT成本</li>
<li>视频：用户在线时长与IT成本比值</li>
<li>游戏：收入流水与IT成本比值</li>
</ul>
</li>
<li>制定目标后，纵向可以看每单位成本是否呈下降趋势。横向可以和具有相同业务模式的公司横向对比。</li>
<li>多维度分析钱花到哪里去了

<ul>
<li>支出构成，构成的比例是否合理

<ul>
<li>自建IDC：服务器、网络设备、机柜电力费用、专线、带款、备件</li>
<li>公有云：cache、DB、带宽、ECS（云硬盘、EIP）</li>
</ul>
</li>
<li>供应商和分类维度

<ul>
<li>哪个类型的供应商支出最高</li>
<li>哪家供应商支出最高</li>
</ul>
</li>
<li>部门和应用维度

<ul>
<li>哪个部门支出最高</li>
<li>哪个应用支出最高</li>
</ul>
</li>
<li>成本优化原则

<ul>
<li>该节省的节省，该花钱的花钱，控制成本不能以牺牲稳定性为代价，切忌过度优化</li>
<li>抓大放小，从供应商、业务、资源等多个角度去看，哪里花钱多就先从哪里着手</li>
</ul>
</li>
<li>优化实施

<ul>
<li>买便宜的东西。如在成本上升期指定采购框架，阶梯定价等</li>
<li>买合适的东西。制定标准，做相对最优的选择</li>
<li>用好已经在线的资源。提高已有资源的使用率</li>
<li>基于虚拟化、容器技术提高资源切分颗粒度，资源调度的能力，提升部署密度</li>
<li>架构优化，基础组件平台化、池化部署。提高资源复用程度，避免重复建设</li>
</ul>
</li>
<li>基于工具化、智能化、可视化，保证成本优化能持续地、低成本地进行，要成为日常技术运营工作的一部分，一个常态。</li>
</ul>
</li>
</ul>


<h2>四. 《如果只定一个指标，研发的考核指标应该是什么？》</h2>

<p><a href="https://mp.weixin.qq.com/s?__biz=MzIzNzg5MTcxNA==&amp;mid=2247484101&amp;idx=1&amp;sn=c58aa0f94e5fce08ff0ba9a46427a4df">https://mp.weixin.qq.com/s?__biz=MzIzNzg5MTcxNA==&amp;mid=2247484101&amp;idx=1&amp;sn=c58aa0f94e5fce08ff0ba9a46427a4df</a></p>

<blockquote><p>我自己的看法是如果不能衡量一个事物的所有方面，那么就不要衡量。但这篇文章在作者自己的场景下确实有它的适用之处</p></blockquote>

<ul>
<li>研发团队考核指标：是否完成JIRA上分配的关键任务，所有任务都是以两周为周期进行安排，基本完成记3分，彻底完成记5分，彻底完成而且有测试例验证，记8分。一个周期至多三个关键任务，一个季度按照总得分发放季度奖金。</li>
<li>理由

<ul>
<li>简单的原则：指标要简单</li>
<li>软件研发的核心问题是进度保证</li>
<li>鼓励团队最先去解决能提升公司价值和竞争力的问题</li>
<li>借助CICD等自动化工具保证代码质量。侧重于看测试结果、性能报告，以结果来驱动优化、驱动质量的提升</li>
<li>实事求是，一切都要有无可辩驳、可以查证的记录。任务全公司透明。</li>
<li>追求卓越。卓越用数字量化，用数字说话。</li>
</ul>
</li>
<li>任何任务，产出或提交产物需要定义清楚，软件研发的提交物应该明确包括API与测试用例。</li>
</ul>


<h2>五. 《美团张川：做了8年平台，我总结了平台的5道坎》</h2>

<p><a href="https://mp.weixin.qq.com/s/bwcJGpR2iwai-LJY0sMoew">https://mp.weixin.qq.com/s/bwcJGpR2iwai-LJY0sMoew</a></p>

<blockquote><p>对平台的阐述确实有独到之处：能做大的平台都需要动态不平衡。低频需求靠广告，高频需求靠补贴。</p></blockquote>

<ul>
<li>动态不平衡形成真正的平台

<ul>
<li>双边平台</li>
<li>不会产生单个用户和单个服务提供者在一段时间内多次达成同一个交易的过程</li>
<li>陷阱：表面看上去是动态不平衡，实际上是平衡的

<ul>
<li>初始不平衡，结尾平衡：家教、美容美发->标准化服务、拆细服务</li>
<li>平台专家: 专家和普通服务者差距不大的服务，专家服务标准化</li>
</ul>
</li>
</ul>
</li>
<li>标准化决定平台大小

<ul>
<li>判断服务是否可以标准化：服务的体验可以一致化，客户的评价可以标准化</li>
<li>把不标准化的服务变成标准化的服务;在不标准化的服务上形成平台</li>
<li>把复合型的服务拆解开来，变成一些可以标准化的分步骤</li>
<li>不做交易的平台，做信息的平台</li>
</ul>
</li>
<li>高频打低频是误解

<ul>
<li>高频不能带动低频，或者说高频带动低频不太明显：高频带动中频，形成巨大的用户平台，然后优化低频体验</li>
<li>高频服务靠补贴，低频服务靠长期广告</li>
<li>多个低频可以聚集成高频</li>
<li>低频服务很难出现好的产品经理</li>
</ul>
</li>
<li>供给端的效率高，平台价值大

<ul>
<li>短期看需求，长期看供给</li>
<li>两个方向

<ul>
<li>供给是不是可以大批量供给，并且接近于无限供给</li>
<li>是不是平台提高了供给端的效率，让供给端能赚到钱</li>
</ul>
</li>
<li>三个关键点

<ul>
<li>供给的快和慢</li>
<li>“供大于求，供不应求”</li>
<li>没有稳定供给的市场，不会是一个巨大无比的市场</li>
</ul>
</li>
</ul>
</li>
<li>商业模式：剃须刀还是电冰箱

<ul>
<li>剃须刀（LTV，生命周期总价值）vs   电冰箱（CAC，用户获取成本）</li>
<li>关注NPS（净推荐值），客户推荐的概率。在低频业务里面降低CAC（获客成本），在高频业务中提升LTV（生命周期总价值）</li>
</ul>
</li>
</ul>


<h2>六. 《翻译漫谈 - 地道中文怎么写？英中翻译要避免哪些坑？》</h2>

<p><a href="https://mp.weixin.qq.com/s?__biz=MzU3NjkxNTQ0Ng==&amp;mid=2247483696&amp;idx=1&amp;sn=14b59459ae953d12b68da3ca43708ab3">https://mp.weixin.qq.com/s?__biz=MzU3NjkxNTQ0Ng==&amp;mid=2247483696&amp;idx=1&amp;sn=14b59459ae953d12b68da3ca43708ab3</a></p>

<blockquote><p>所谓的英式中文，每次读到真的是觉得很别扭。本文则讲述了如何避免这些情况。</p></blockquote>

<ul>
<li>与字对字翻译有关的问题

<ul>
<li>避免不必要的主谓语分离，不要在中文中使用类似「As a&hellip;, he is&hellip;」的句式。</li>
<li>避免在翻译「When/After&hellip;, &hellip;」时，用「当……，……」的句式。</li>
<li>「while」「though」的翻译</li>
<li>很多情况下，「you」「your」都不必要翻译成「你/您」「你/您的」</li>
<li>翻译「such as…」「…like…」 以及写作中文的时候，除非后面举例的内容很长，否则请避免使用「……，比如……、……、……。」的句式</li>
<li>在使用/翻译术语时避免生搬英文字面意思，而是要通过调研市场以及中文语言环境，找到最合适的地道中文词</li>
</ul>
</li>
<li>与中英文语法/表达习惯有关的问题

<ul>
<li>避免泛泛地使用「……之一」，列举确定数量的事物之一时除外</li>
<li>partly because of」不要翻译成「部分原因在于」或者任何带有「部分」的形式</li>
<li>尽量少用被动句式，因为地道的中文里并没有太多被动语态</li>
<li>尽量避免「万能动词＋抽象名词」的句式</li>
<li>复数的处理：  中文并没有单复数变化，我们会在名词前加上「许多」或是数量，甚至不加修饰只透过前后文来强调复数，而不是加上「们」</li>
<li>中文写作时要避免受到英文习惯的影响：  英文经常会用设问句式来启发用户阅读后文，而中文会更多使用清晰肯定的陈述句。</li>
</ul>
</li>
<li>好的翻译Tips

<ul>
<li>目标语言（target language）语感（即直接、迅速地感悟语言文字的能力）好，知道什么样的句子/表达是好的/不好的，知道什么样的内容需要对应什么样的语言风格，写作有逻辑，用词丰富</li>
<li>源语言（source language）语感好，能分清句子（尤其是长句/复杂句）结构、拆分意群</li>
<li>善用工具，包括辞典、搜索引擎、计算机辅助工具（CAT）等等，寻找最准确、最适合所译内容的词汇和表达</li>
<li>不做字对字的翻译，译文没有翻译腔，即在理解源语言文本所蕴含意思的基础上，摆脱源语言的句子结构、表达习惯，灵活运用目标语言，准确恰当地表达原文含义</li>
</ul>
</li>
</ul>


<h2>七. 《聊聊数据库的未来，写在 PingCAP 成立五周年前夕》</h2>

<p><a href="https://mp.weixin.qq.com/s?__biz=MzI3NDIxNTQyOQ==&amp;mid=2247491223&amp;idx=1&amp;sn=e5cb7dd392e54228f6897d0d7b74551f">https://mp.weixin.qq.com/s?__biz=MzI3NDIxNTQyOQ==&amp;mid=2247491223&amp;idx=1&amp;sn=e5cb7dd392e54228f6897d0d7b74551f</a></p>

<blockquote><p>网红数据库TiDB的创始人写的关于数据库的未来。总体就是数据库越来越智能，无须再担心分库、分表的问题 ​</p></blockquote>

<ul>
<li>Single Source of Truth：  数据贯穿在应用逻辑各个角落，系统中对于任意数据的存取都应该是可以不加限制的</li>
<li>数据是架构的中心

<ul>
<li>系统=业务逻辑x数据</li>
</ul>
</li>
<li>以分布式数据库为统一中心的架构

<ul>
<li>整个架构的中心是一个场景覆盖度足够广，且具有无限的水平伸缩能力的存储系统。大部分数据的流动被限制在这个数据库内部，这样应用层就可以几乎做到无状态，因为这个中心的数据库负责了绝大部分状态，每个应用可以通过自己的缓存来进行加速。</li>
<li>缓存层需要离业务层更近</li>
<li>HTAP
<img src="http://www.rowkey.me/post_images/htap.jpg" alt="" /></li>
</ul>
</li>
<li>未来

<ul>
<li>弹性调度会是未来的数据库的核心能力</li>
<li>下一个阶段是智能</li>
</ul>
</li>
</ul>


<h2>八. 《GSA管理导图：神秘的战略突破之钥》</h2>

<p><a href="https://mp.weixin.qq.com/s/iZCTGcc5BXiNSMp-ZDnKHQ">https://mp.weixin.qq.com/s/iZCTGcc5BXiNSMp-ZDnKHQ</a></p>

<ul>
<li>日常运营管理：持续改善现状

<ul>
<li>关注当下的事</li>
</ul>
</li>
<li>战略管理：持续寻求突破点

<ul>
<li>关注未来的事</li>
<li>根据洞察，对未来的机会做出假设，提前做好准备，将洞察转化为企业经营的绩效，推动企业持续突破，获得增长。</li>
</ul>
</li>
<li>GSA管理导图：聚焦G成果略目标，选定最合适的S策略目标（路径），透过高效的A活动目标（行动），最终推动战略落地。选择合适的S及管控A，有效的推动G落地。

<ul>
<li>G代表Goal，我们称之为成果目标：具有突破性，制定成果目标需要有强大的洞察力及坚定力，成果目标是一种滞后性的目标。

<ul>
<li>一年做三件事</li>
<li>战略规划的产出就是战略目标，制定战略目标需要非常聚焦（少于三个），需要具有突破性（改变企业运行的常态），需要有强大的洞察力（对未来的假设），更需要团队的共识（先相信，才能看见，举国之力办大事）</li>
</ul>
</li>
<li>S代表Strategy，我们称之为策略目标：路径选择，要完成（G）成果目标最高效的路径，追求成果的路径有多种。策略目标是一种引领性的目标。

<ul>
<li>谋定而后动</li>
<li>作用

<ul>
<li>它能够让我们在采取行动之前，引导我们好好思考，什么路线是最有效的</li>
<li>整合公司的资源</li>
</ul>
</li>
<li>制定策略目标是GSA管理导图中最具挑战性的工作，需要强大的业务专业能力</li>
</ul>
</li>
<li>A代表Action，我们称之为活动目标：应该如何活动，得以让目标在选定的路径上迅速推进。需要强大的专业力及创新力来制定活动目标，活动目标是一种超引领性的目标，也是唯一可以管控的目标，更需要根据G和S的情况做出快速灵活的修正。

<ul>
<li>关键高频可控</li>
<li>是唯一可以管控的目标</li>
<li>高频的活动</li>
<li>关键的，具有最大的杠杆力来推动策略目标达成</li>
</ul>
</li>
</ul>
</li>
<li>GSA：1:2:4

<ul>
<li>GSA三类目标的数量比例最好是1:2:4</li>
</ul>
</li>
</ul>


<h2>九. 《“元宇宙”概念引爆科技创投界 它将颠覆人类社会？》</h2>

<p><a href="http://finance.sina.com.cn/tech/csj/2021-04-08/doc-ikmxzfmk5587495.shtml">http://finance.sina.com.cn/tech/csj/2021-04-08/doc-ikmxzfmk5587495.shtml</a></p>

<p>Metaverse元宇宙：一个平行于现实世界的虚拟世界，拥有现实世界的一切形态。</p>

<p>特点:</p>

<ul>
<li>持续性：这个世界能够永久存在，不会停止</li>
<li>实时性：能够与现实世界保持实时和同步，拥有现实世界的一切形态</li>
<li>兼容性：它可以容纳任何规模的人群以及事物，任何人都可以进入</li>
<li>经济属性：存在可以完整运行的经济系统，可以支持交易、支付、由劳动创造收入等</li>
<li>可连接性：数字资产、社交关系、物品等都可以贯穿于各个虚拟世界之间，以及可以在“虚拟世界”和“真实世界”间转换</li>
<li>可创造性：虚拟世界里的内容可以被任何个人用户或者团体用户来创造</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我的2021]]></title>
    <link href="http://www.rowkey.me/blog/2022/02/13/my2021/"/>
    <updated>2022-02-13T11:29:34+00:00</updated>
    <id>http://www.rowkey.me/blog/2022/02/13/my2021</id>
    <content type="html"><![CDATA[<p>迟来的关于2021年的总结。整个2021年还是处在新冠疫情的笼罩之下，反反复复，工作和生活都或多或少收到了一些影响。穿插其中的，有工作上的开始和突破，有生活上的失望与惊喜，也有自己内心的或喜或悲。整体上说，过去的2021年还是处于自身的期望之中的。</p>

<!--more-->


<h2>工作</h2>

<h3>游戏</h3>

<p>对于自己来说，如果用一个词来概括2021年游戏方面的工作，应该是“突破”。接着2020年底的工作，团队终于在2月份算是组建成功，但实际上一直到8月份，不管是在游戏方向还是团队战斗力上都一直处于一个不稳定的状态。期间发生了一些事，也挺让我感触和无奈的。后续在经历了人员的变动和游戏方向的屡屡尝试后，最重确定了游戏品类，之后营收数据迅速得到了提升。12月底的数据让大家看到了实现盈利的希望，团队也终于有了信心和凝聚力。希望2022年在利润上实现更一步的突破。</p>

<p>通过一年的游戏业务的工作，有一点最令我感悟的问题就是职能部门负责人与业务负责人的不同。之前看美团的前COO干嘉伟说过“从职能管理到业务管理，这是一个非常大的跨越。哪怕你是一个非常有经验的职能管理者，管过几千人的团队，也不意味着你就可以顺理成章地孵化出一个5个人的独立业务，二者的能力要求完全不一样。”现在总结起来，职能部门负责人的关注点主要在于团队专业能力的提升，对于自身的要求，专业能力占了很大比重，对于营收、增长、变现这些方面关注是比较少的。而对于业务负责人来说，需要关注从产研到变现的全流程，并通过数据和经验做出判断和决策，需要的能力更加综合。</p>

<h3>技术团队</h3>

<p>由于2021年自身的主要精力都放在了游戏业务上，对于技术团队的管理工作，主要是方向和总体把控上。鉴于整体经济形式和公司业务的状况，整个2021年还是围绕降本增效在进行。</p>

<h3>降本</h3>

<ul>
<li>大数据上云：完成了大数据迁移至华为云，并回收了之前的物理主机，给公司带来了一笔现金流。</li>
<li>提高资源利用率：持续监测优化，提高了业务和大数据CPU、磁盘、数据库使用率，节省了客观的云服务成本。</li>
<li>替代第三方服务：新业务使用友盟推送，减少了推送服务的使用成本。</li>
<li>华为云政府补贴：完成了云服务到华为云的全量迁移，并争取到了政府可观的云服务补贴。</li>
</ul>


<h3>增效</h3>

<p>在提高效能这方面，今年有明显进展的包括以下：</p>

<ul>
<li>DevOps平台：2021年eone平台继续优化，最终实现了对K8S、游戏客户端、Python等的支持。并进一步开发了域名管理、资源管理等。基本实现了公司所有业务的接入，大大节省了运维团队的精力的成本，提高了产品的交付效率。</li>
<li>Flutter技术：在游戏业务实现了产品的交付，基本证明了开发与推广的可行性。</li>
</ul>


<h2>学习</h2>

<p>2021年自己主要一直在学习游戏业务方面的知识，也比较零散，看了游戏专业相关的几本书也没看完，主要还是在和游戏行业的前辈的交流沟通中学习。除此之外的书籍，完成阅读的就比较少了。</p>

<ul>
<li><p>极客时间<a href="https://time.geekbang.org/column/intro/100062901">《乔新亮的CTO成长复盘》</a></p>

<blockquote><p>彩食鲜CTO乔新亮的成长复盘课程。作者也是自己大学的学长，职业生涯经历了从程序员到管理者再到CTO的转变，待过大公司、也去过小公司。他的这些经历和对经历的复盘对我来说，是非常有参考价值的。通过这个课程确实学到了不少干货。值得走技术路线的朋友们学习。</p></blockquote></li>
<li><p>极客时间<a href="https://time.geekbang.org/column/intro/100095401">《超级访谈：对话张雪峰》</a></p>

<blockquote><p>饿了么CTO张雪峰的一次访谈整理出来的课程。我自己是抱着CTO到底需要做什么来学习的。看完之后，有些地方是能印证自己目前在做的，也有很多地方是自己还有很大差距的。自以为，这个课程适合目前处于CTO或者技术总监岗位上的人，可以对照后产生自己的认知。</p></blockquote></li>
<li><p>极客时间<a href="https://time.geekbang.org/column/intro/100025001">《从0开始学增长》</a></p>

<blockquote><p>作者是前宜人贷用户增长团队负责人，《破茧成蝶》系列图书作者。自己是独立负责业务后，想学习一下增长方面的知识所以在极客时间找了课程来学。所以评价这本书，只能以一个初学者的角度。综合看来，作者讲述了其在增长领域多年经验总结出来的方法论。课程里提到的增长的概念、差异性洞察、北极星指标、增长闭环、一级方向（高级洞察）、二级机会（用户增长地图）、三级增长（精益增长闭环）、四级成果（增长链）等等，有一些在我们实际业务中也做了尝试并取得了一定的效果。</p></blockquote></li>
<li><p><a href="https://book.douban.com/subject/26464679/">游戏分析的艺术</a></p>

<blockquote><p>这本书是一本针对于游戏业务的数据分析书籍，作者来自于TalkingData、西山居。基于通用的数据分析方法，讲述了针对游戏的一些数据分析指标和方法，包括数据分析的思路、报表组织结构等等。对于数据分析初学者、游戏业务从业者，都有不小的参考和学习价值。</p></blockquote></li>
<li><p><a href="https://book.douban.com/subject/35260706/">极简市场营销</a></p>

<blockquote><p>这本书是公司CEO推荐公司所有管理层阅读的一本书籍。这里的市场营销主要是讲述的传统行业如消费品的市场运营。是一本理论和实际都兼具的书籍。作者基于传统的市场营销理论扩展出了市场洞察、客户细分和目标用户选择、定位、品牌、市场营销4P、促销组合、黑客增长的框架。同时也讲述了市场营销工作的考核与组织架构，具有实际参考价值。</p></blockquote></li>
<li><p><a href="https://book.douban.com/subject/27153484/">穷爸爸富爸爸</a></p>

<blockquote><p>挺老的一本书。算是财商教育的启蒙书籍。全书围绕穷人为钱工作，富人让钱为自己工作来讲述。其阐述的通过投资产生的收益来消费，而不是直接消费、如何减少税收等理念确实值得思考。但其中的很多操作方法却也是建立在有足够认知的情况下的，书值得读，但妄想一下子开了窍赚钱可能性也不大。</p></blockquote></li>
<li><p><a href="https://book.douban.com/subject/30267664/">深度思维</a></p>

<blockquote><p>今年我最推荐的一本书。里面讲了几大深度思维模式，包括延长逻辑思维链、换位思维、可视化思维、流程思维、生态思维、系统思维、大势思维、兵法思维。其中延长逻辑思维链这一点，在平时的工作上确实感受颇深，具有这一思维的人大都是做事靠谱的管理角色。非常值得阅读学习的一本书！</p></blockquote></li>
<li><p><a href="https://book.douban.com/subject/33379779/">美国陷阱</a></p>

<blockquote><p>华为孟晚舟事件时此书的作者在媒体上给与过自身经历的分享。通过作者所在的法国阿尔斯通集团公司的电力业务如何被美国通用电气公司收购切身讲述了美国如何通过自身的霸权地位来打击美国企业竞争对手，实现自己经济战争的胜利的。</p></blockquote></li>
</ul>


<p>以上是已经完成阅读的书籍，自己目前待读的书籍列表如下，每一分类优先级自上至下降低。2021年规划完成其中12-24本的阅读。</p>

<h3>业务&amp;管理</h3>

<ul>
<li>数据化决策</li>
<li>经济学思维</li>
<li>牛奶可乐经济学</li>
<li>内向者沟通圣经</li>
<li>用图表说话</li>
<li>精益创业</li>
<li>一网打尽：贝佐斯与亚马逊时代</li>
<li>领导者的大脑</li>
<li>科学分钱：学习华为分钱方法</li>
<li>卓有成效的管理者</li>
<li>领导梯队：全面打造领导力驱动型公司</li>
<li>回归本源看绩效</li>
<li>别让猴子跳回背上</li>
</ul>


<h3>技术</h3>

<ul>
<li>极客时间《许世伟的架构课》</li>
<li>分布式系统概念与设计</li>
<li>大数据日知录</li>
<li>数据密集型系统设计</li>
<li>程序员的三门课</li>
<li>程序员修炼之道</li>
</ul>


<h3>企业</h3>

<ul>
<li>创新者的窘境</li>
<li>良性增长</li>
<li>闪电式扩张</li>
<li>定位：有史以来对美国营销影响最大观念</li>
<li>刷新：重新发现商业与未来</li>
<li>公司进化论</li>
<li>方舟：数字经济创新史</li>
<li>超级版图：全球供应链、超级城市与新商业文明的崛起</li>
</ul>


<h3>个人</h3>

<ul>
<li>学会提问</li>
<li>直击本质：洞察事物底层逻辑的思考力</li>
<li>模型思维</li>
<li>结构性思维：让思考和表达像搭积木一样有序省力</li>
<li>金字塔原理</li>
<li>社会性动物</li>
<li>智慧的疆界：从图灵机到人工智能</li>
<li>资本论</li>
<li>全球通史</li>
<li>乡土中国</li>
<li>置身事内：中国政府与经济发展</li>
<li>价值：我对投资的思考</li>
<li>看懂世界格局的第一本书：大国博弈</li>
<li>大国战略：世界是如何被统治的</li>
<li>异类</li>
<li>中国城市大洗牌</li>
</ul>


<h2>生活</h2>

<p>2021年生活的改变还是挺大的。在权衡了各种利弊之后，选择了常驻南京公司来推进游戏业务，家也从北京搬回了杭州，住进了已经装修好三年的房子里了。一方面是新房子装修好后就没住过，另一方面对于未来定居在杭州还是南京，暂时还无法做出决策，因此暂时也就开始了南京和杭州周末来回跑的双城记。有点累，但即使就周末住在自己房子里的时间，也是完全不同于租房的感觉。值得一提的是，由于南京的人才安居政策的吸引，在年底购买了南京的新房，虽然后面被这个政策给坑了一下，但基本上也确定了后面定居南京的打算。</p>

<p>今年也是女儿三周岁上幼儿园的一年，在经历了chongwen幼儿园的三观刷新和打击后，还是选了和chongwen有渊源的崇艺幼儿园。从这半个学期来看，女儿还是挺喜欢这个学校的。交到了好朋友，也学会了不少英文。课余还自学了平衡车、拍球。希望她能一路开心、茁壮成长。</p>

<h2>总结</h2>

<p>以上是2021年的总结，做的事情挺多，收获也不少，总体还算满意。希望2022年疫情能够尽快消失或者有一个崭新的解决办法吧。</p>

<ul>
<li>实现游戏的毛利和净利的突破，业务线能够自负盈亏，并能够开始长线的游戏方向。</li>
<li>借助新的业务线推进Flutter等跨平台开发技术在公司的使用。</li>
<li>继续监控技术成本，控制成本支出，提高性价比。</li>
<li>能够在海外或者Web3.0业务上有突破，哪怕是入门。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[做游戏业务以来的一些感悟]]></title>
    <link href="http://www.rowkey.me/blog/2021/08/13/game/"/>
    <updated>2021-08-13T11:29:34+00:00</updated>
    <id>http://www.rowkey.me/blog/2021/08/13/game</id>
    <content type="html"><![CDATA[<p>今天看了一下自己的博客，发现已经四个月没有写过文章了。其实自己准备中的东西还有几篇，但从去年年底开始负责游戏业务以来，一直处于一个学习的状态，身上的压力也一直没有降下来。对于游戏这个行业，自己完全是一个新手，各种方法论、行业趋势、游戏开发的各种概念对我来说都是完全陌生的领域。这期间学习了不少游戏行业从研发到运营到发行的知识，但到现在也没有一款可以拿得出手的游戏，所以这方面的东西也没法拿出来输出给别人。没有得到过证明的东西，如果误导别人那就是大错特错了。不过，大半年的学习，总归还是有一些基本的概念和教训是可以总结一下的。</p>

<!--more-->


<h2>游戏行业现状</h2>

<p>目前国内的游戏公司做的游戏概括起来有以下两大类（来自于App Annie的分类）。</p>

<ol>
<li>硬核游戏，也叫做重度游戏。细分的话又包括RPG、赛车、射击、动作、策略、运动等。这部分游戏基本都是大厂在做，推广方式是重运营的，也结合买量。变现方式也基本都是游戏内充值。</li>
<li>休闲游戏。相比起硬核游戏，可以叫做中轻度游戏。细分的话又包括模拟经营、益智解谜、阶级、超休闲等。这类游戏大厂也有涉猎，但以中小公司居多。这类游戏的开发人力、开发周期等等都是小于硬核游戏的。面向的玩家也偏大众一些。推广方式也主要是以买量为主。变现方式一般是通过游戏内广告。</li>
</ol>


<p>进一步的如果通过变现方式来区分，又可以分为</p>

<ol>
<li>IAP游戏，即付费充值游戏。在游戏版号政策出现之前，游戏都可以做成付费充值的。目前，则只有拥有游戏版号的游戏才能这么做。</li>
<li>IAA游戏，即广告变现游戏。目前对游戏的监管还没有要求所有游戏都要有版号。通过游戏内广告进行变现的游戏是目前没有版号的公司的方式。这类游戏本质上也成了一个流量生意。</li>
</ol>


<p>还值得一提的是，去年疫情期间，接着18、19年网赚类APP（趣头条、惠头条、刷宝）的势头，网赚类游戏也有了一波红利期。到现在的游戏榜单上，网赚类游戏也一直稳定在头部，下滑趋势并不明显。算是一个新起的游戏品类。这类游戏在游戏的玩法上叠加了一层提现逻辑，能够一定程度的提高游戏留存，通过分享还能降低获客成本。</p>

<p>此外，还有一个超休闲游戏的概念。这类游戏源自国外Vodoo、Crazylabs等公司，玩家上手门槛极低，一局游戏的时长也非常短，基本也都是IAA类游戏。这类游戏的开发成本、周期都很低，一般都是刚开始做游戏的公司选择的品类。但这类游戏能够成功的关键在于极低的获客成本，所以抓热点、玩法创意都极其重要。</p>

<h2>自己在做的</h2>

<p>由于对游戏行业完全是个门外汉，所以决定做之前，和很多游戏行业的前辈请教了很多东西。综合多方面的考虑和建议，选择了超休闲游戏做为一开始的尝试。陆陆续续出了三四款超休闲游戏，没有什么水花，后来又转换方向为中度休闲模拟经营类游戏。</p>

<p>整个过程是伴随着教训的，一些坑不管别人怎么说，该踩的还是要踩。</p>

<h2>得到的教训</h2>

<ol>
<li>选择做超休闲游戏确实是成本低的最佳选择。但是决定这类游戏成功的关键自己又把握不住，那么成本低也没有意义。这是一开始自己非常错误的一个决策。</li>
<li>使用应用APP的项目迭代方式是不适合游戏尤其是第一个版本的开发节奏的。游戏这种内容型APP，内容是最关键的，如果内容不够充实，那么推广起来是没有任何意义的。这就好比电影或者一本书，可以出续篇，但是已有的东西再去改，带来的效果就不是那么有意义了。</li>
<li>做适合团队基因的游戏是最合适的。鉴于一些招人的客观原因，选择某个品类游戏，然后去找合适的人是非常困难的。那么可以试着先把团队搭建成功，再去做适合团队基因的游戏会是一个更好的选择。</li>
<li>自己不懂的东西要交给懂得的人来做，即使付出昂贵的成本。这比用小的成本招来不懂的人来做要好的多。不懂的人做不出东西来，那么整个团队的价值就是浪费的。懂得人来做，即使成本贵很多，但是团队的价值会覆盖掉这些成本。</li>
<li>做决断尤其是对人要果断。不能因小失大，时间成本和机会成本是非常大的。</li>
</ol>


<h2>结语</h2>

<p>不破不立，相比之前做研发，现在走出了自己的舒适区，压力很大，但是斗劲十足，也好久没有这种兴奋感了。虽然一直说自己更喜欢写代码、做架构，但是现在的工作状态更让自己有活力。希望后面的结果会越来越好吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[阿里巴巴管理三板斧]]></title>
    <link href="http://www.rowkey.me/blog/2021/03/31/ali-manage/"/>
    <updated>2021-03-31T11:29:34+00:00</updated>
    <id>http://www.rowkey.me/blog/2021/03/31/ali-manage</id>
    <content type="html"><![CDATA[<p>去年年底受阿里云的邀请参加了一次湖畔大学的参观学习活动，其中有一堂管理的课程《阿里集团管理三板斧》，讲师是阿里的新商业学院院长-正雄。这堂课让我在市面上公开的一些阿里的管理认知上对其有了进一步的了解和启发。以下是在课堂上的一些笔记。</p>

<!--more-->


<ul>
<li>湖畔大学三板斧

<ul>
<li>上三板：使命、愿景、价值观</li>
<li>下三板：组织、人才、KPI</li>
</ul>
</li>
<li>业务三板斧：针对事情

<ul>
<li>揪头发：抓重点</li>
<li>照镜子：自我反思</li>
<li>闻味道：发现问题</li>
</ul>
</li>
<li>管理三板斧：针对人</li>
<li><p>整体观：业务 组织 文化 三位一体</p>

<p>  <img src="http://www.rowkey.me/post_images/ali-manage/whole.jpg" alt="" /></p>

<ul>
<li>平常人做非凡事 -> 非凡人平常心做非凡事</li>
<li>永续经营

<ul>
<li>业务战略 时代背景</li>
<li>组织能力 文化土壤</li>
</ul>
</li>
</ul>
</li>
<li>领导力梯队
  <img src="http://www.rowkey.me/post_images/ali-manage/team.jpg" alt="" /></li>
<li>腿部三板斧
  <img src="http://www.rowkey.me/post_images/ali-manage/leg.jpg" alt="" />

<ul>
<li>结果和过程都要：为过程鼓掌，为结果复盘

<ul>
<li>没有过程的结果是垃圾</li>
<li>没有结果的过程是放屁</li>
</ul>
</li>
<li>奖优罚劣：No Surprise</li>
<li>绩效目标 &lt; 5条

<ul>
<li>业务指标</li>
<li>产品</li>
<li>团队</li>
<li>个人</li>
</ul>
</li>
</ul>
</li>
<li>腰部三板斧
  <img src="http://www.rowkey.me/post_images/ali-manage/waist.jpg" alt="" />

<ul>
<li>超越伯乐：职能部门不招应届生</li>
</ul>
</li>
<li>头部三板斧：眼光、胸怀、看未来的能力
  <img src="http://www.rowkey.me/post_images/ali-manage/head.jpg" alt="" /></li>
<li>业务、组织、文化三位一体
  <img src="http://www.rowkey.me/post_images/ali-manage/integration.jpg" alt="" /></li>
<li><p>数字化变革时代的理念变迁</p>

<p>  <img src="http://www.rowkey.me/post_images/ali-manage/trans.jpg" alt="" /></p></li>
<li><p>终局思维</p></li>
</ul>


<h3>自己的收获</h3>

<p>从自己彻底做好管理角色的认知到转变3年多了，曾经对于管理这件事会武断的认为所有人都需要同样的管理技能。后来逐渐意识到不同的管理层级需要的认知和知识是大不一样的。通过这次课程，也印证了这件事，所谓腿部、腰部、头部也就指的是基层管理者、中层管理者和高层管理者，也就是所谓的领导力阶梯。此外，阿里从“常人做非凡事”转变到现在的“非凡人平常心做非凡事”，也是一个公司从创业团队到大公司的转变过程所需要的观念的改变。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我的2020]]></title>
    <link href="http://www.rowkey.me/blog/2021/01/13/my2020/"/>
    <updated>2021-01-13T11:29:34+00:00</updated>
    <id>http://www.rowkey.me/blog/2021/01/13/my2020</id>
    <content type="html"><![CDATA[<p>最近因为新业务的事情一直没有写文章，发现已经4个月没有产出。年初给自己定的每个月至少产出一篇文章的目标算是啪啪打自己脸了。不过虽然2021年已经过去大半个月了，2020年的总结还是要补上的。</p>

<!--more-->


<p>2020年整体的印象就是疫情了，从年初武汉疫情的愈演愈烈，到年底的死灰复燃，新冠这个事情感觉就没消停过。上半年由于疫情和各种因素的影响，公司在组织和业务上都发生了很大的变动。对我自己负责的部分来说，整年的一个目标就是降低技术成本，而与降本经常被一起提的增效在业务目前的形势下，则显得没那么重要了。从全年来看，整个技术团队在技术成本上有了明显的降低，提高效能的交付流水线、代码分析平台、DevOps平台、Flutter上也都有明显的进展和效果。总体来看，整个技术团队的成绩还是在期望中，但是鉴于目前公司的形式和状况，很多事情的优先级和重要性则还需要进一步的调整和优化。</p>

<p>还是按照工作、学习和生活三个方面来总结我自己的2020年。</p>

<h2>工作</h2>

<p>如上面所说，今年工作上主要围绕降低成本、提高效能来展开，尤其是降低成本。而今年让我感触最深的可能是“业务价值”这个词。对于一个商业公司来说，其本质就是寻求产生更多的净利润，所以衡量技术的价值根本就是看他能不能产生业务价值。以前做技术选型或者引入，都是以技术价值优先，而今年公司的状况，更应该是先看是否有业务价值，再去考虑技术实现。比较明显的一个例子就是19年引入的APM系统，当时看来是觉得要紧跟业界趋势，为后续的微服务做好基础建设，而如果以业务价值来看，对于今年的业务状况，性能并不是关键问题，这种系统的价值就很低。</p>

<h3>降本</h3>

<p>在业务高速发展的时候，对于技术服务、资源的使用是比较粗暴的，甚至一些Redis都达到了1T的大小。而有了降本的前提，需要围绕资源做以下工作。</p>

<ul>
<li>资源的价格优惠：通过框架协议或者商务谈判来争取更低的折扣，从而实现价格的降低。</li>
<li>提高资源的利用率：通过梳理监控各个资源的使用率，对于使用率较少的资源进行缩容；引入容器技术，弹性分配资源，提高资源利用率；在申请资源时做好充分的量化和预估，减少资源的浪费。</li>
<li>减少不再使用或者价值不高的资源：梳理公司的资源，理清有哪些资源，是否存在闲置无流量的资源。对比业务产出和业务技术成本，对于业务价值无法覆盖技术成本的业务及时反馈，及时决定是否下线。</li>
<li>梳理出成本占比高的资源，评估其是否有性价比更高的方案。</li>
<li>构建业务中台、技术平台、技术组件化，提高资源复用率，避免重复建设，减少浪费。</li>
</ul>


<p>随着业务的调整，也经过一年的努力，最终技术成本降低到了年初的1/3，是今年可圈可点的一部分工作。</p>

<h3>增效</h3>

<p>在提高效能这方面，今年有明显进展的包括以下几部分</p>

<ul>
<li>DevOps平台：研发完全可以通过平台来申请资源，自动生成部署流水线，大大解放了运维的生产力，并且进一步推进了公司所有后端服务的容器化，实现了资源的弹性调度和使用。</li>
<li>Flutter技术：实现了初步的引入，后续需要通过更有效的措施进行推广。从而改变一个功能需要两端开发的现状，降低开发成本。</li>
<li>持续交付流水线：接入了自动化测试环节，同时在客户端得到了有效的推进，使得公司的交付基本完全进入了自动化阶段，有效提高了交付速度和质量。</li>
<li>大数据上云：旨在利用云的弹性特点，减少运维工作量。在综合考虑了运维成本、团队发展、云服务质量、配合度、稳定性、性能等因素后，最终选择了华为云做为多云方案中的第二家供应商。目前已经逐步在实施中。</li>
</ul>


<h3>平台业务</h3>

<p>技术中心的工作还有很大一部分是在平台业务上，包括支撑市场投放的平台、支撑消费品业务的消费品助理平台、支撑数据分析的大数据平台、支撑内部效率的WeOKR平台等。今年这几个平台都有不小的进展。</p>

<ul>
<li>Wolves市场投放系统完成了2.0大版本的开发。</li>
<li>消费品助理平台实现了打款助手、供货商管理、财务结算、数据大盘、选品助手等功能。</li>
<li>WeOKR系统支撑了今年公司考核机制的转型。</li>
<li>Lepoard的事件分析功能已经完成了书签、概览等功能的开发。</li>
</ul>


<p>区别于底层的技术平台，这一块偏向于业务，但又不直接服务于业务。其业务价值也是我一直在思考的事情。
如何量化出其业务价值是非常难的事情。但在公司目前的状况下，却也不得不去思考。目前采取的方式就是根据业务的需求提出量和调用量来分摊人力成本和业务价值。可能更好的思路是采用类似于内部虚拟货币结算的方式来体现业务价值，这也是打算尝试的方案。</p>

<h3>游戏</h3>

<p>12月份左右决定开始启动游戏业务的尝试做为公司的另一个利润增长点。对于我自己来说，不管是直接负责一个业务还是游戏本身这个领域，都是迈出了自己的舒适区。不知道这个行业的现状，不知道一个游戏团队的组成，不知道该不该去做，不知道该怎么做。从决定进入这个行业开始，自己就处于一种既兴奋又紧绷的状态，是一种很久未感受到的压力。</p>

<p>一开始通过去拜访一些游戏行业的公司和参加游戏行业的会议去学习。差不多花了将近两周的时间，在很多朋友的帮助下，基本摸清了游戏行业的一个大概情况。再综合公司目前的状况，确定了团队的构成和游戏的方向。到目前为止，团队基本成型，第一款游戏也快出来了。期间从0到1，自己一个一个人去面试，去沟通，去规划工作，去协调公司和外部的资源，目前看来结果还在期望中。但后续的游戏发行和游戏的立项才是重中之重，紧绷的状态估计还得一直持续下去。</p>

<p>希望游戏业务能有一个好的结果吧。</p>

<h2>学习</h2>

<p>今年的学习，可能主要是对游戏行业的学习了，尤其是对于休闲游戏，自己在求教了很多朋友以及看了很多文章和新闻后，基本上有了自己一个比较客观的认识，也算是开始踏入了游戏这个行业。</p>

<p>而在书籍阅读方面，由于一些客观原因，完成的也有限。</p>

<ul>
<li><p>极客时间<a href="https://time.geekbang.org/column/intro/100034501">《研发效率破局之道》</a></p>

<blockquote><p>出自FaceBook的大神结合自己的实践给出的如何提升研发效率的经验总结。包括软件开发的本质是什么、如何定义和选择研发效率衡量指标。并从研发流程、工程方法、个人效能以及管理和文化四个方面来阐述了如何提高研发效率。其中的很多知识都具有实操性，自己已经借鉴用在了公司中。</p></blockquote></li>
<li><p><a href="https://book.douban.com/subject/6862062/">持续交付: 发布可靠软件的系统方法</a></p>

<blockquote><p>这本书不同于去年读过的《持续交付2.0》，更侧重于持续交付实现的细节，尤其在自动化测试方面花费了很多笔墨。总体上，其从如何让团队达成持续交付的共识、基础设施和环境管理、配置管理、测试策略、数据管理、持续交付管理、部署流水线几部分对实现持续交付做了很详细的阐述。但由于出版时间的原因，某些内容如代码分支模式不是业界最新的内容。但对于想要实现部署流水线，这本书的实操性足够了。</p></blockquote></li>
<li><p>极客时间<a href="https://time.geekbang.org/column/intro/100038501">《项目管理实战20讲》</a>+<a href="https://time.geekbang.org/column/intro/100044301">《说透敏捷》</a></p>

<blockquote><p>虽然经历过前东家的项目管理流程，但一直缺乏对其系统的认识。《项目管理实战20讲》从项目管理的本质、管理角色的转变、十大领域五大过程方面阐述了项目管理。尤其对于五大过程的一些实践性阐述，很干货，我们也借鉴了不少在公司中。后面的《说透敏捷》则从敏捷的本质、敏捷的5条价值观、12原则以及如何推进敏捷上做了经验和实践的阐述，也非常具有借鉴意义。</p></blockquote></li>
<li><p><a href="https://book.douban.com/subject/34960995/">发布！设计与部署稳定的分布式系统</a></p>

<blockquote><p>从上面说的《持续交付》那本书里被引导过来。读完之后总体的感觉是能够让读者对系统稳定性有系统认识和理解，但不够细节和执行。尤其感觉翻译的优点差，很多术语都是中式直译。</p></blockquote></li>
<li><p><a href="https://book.douban.com/subject/2046281/">大道至简：软件工程实践者的思想</a></p>

<blockquote><p>内容主要是基于《愚公移山》故事中来讲述软件工程本质的。对我自己的启发就是，这世上万物很多本质都是一样的。软件工程类比于移山这个工程，其经历的事情和演进都有彼此想通之处。其中提出的软件工程层状模型（EHM）从程序、过程、工程、组织几个方面阐述了作者对软件工程的理解。</p></blockquote></li>
<li><p><a href="https://book.douban.com/subject/26901183/">我读管理经典</a></p>

<blockquote><p>这本书是作者对一些经典管理著作的学习心得的总结和思考。包括《科学管理原理》、《福利特论管理》、《工业管理与一般管理》、《社会组织与经济组织理论》、《管理行为》、《组织与管理》、《工业文明的社会问题》、《经理人员的职能》等等，梳理了管理学从科学管理到管理创新的发展历程。</p></blockquote></li>
<li><p><a href="https://book.douban.com/subject/2230248/">人月神话</a></p>

<blockquote><p>重读这本经典著作，虽然其中有些东西稍显过时(如对软件开发时长的经验值，但其没有银弹、用外科手术团队类比软件开发团队仍然是延续至今可以使用的方法和认知。</p></blockquote></li>
<li><p><a href="https://book.douban.com/subject/26863413/">CEO说：人人都应该像企业家一样思考</a></p>

<blockquote><p>作者拿街头小贩和企业家做类比，阐述了企业的本质是商业智慧。从公司的本质、整体上理解公司、领导需要化繁为简、创造财富而不是赚钱、人岗匹配、打造齐心协力的团队等方面讲述了企业家如何思考和行动以及应该如何思考和行动。</p></blockquote></li>
</ul>


<p>以上是已经完成阅读的书籍，目前包括了2020年未完成以及新加入的待读书籍列表如下：</p>

<h3>工作</h3>

<ul>
<li>数据即未来</li>
<li>未来架构</li>
<li>极客时间《许世伟的架构课》</li>
<li>分布式系统概念与设计</li>
<li>大数据日知录</li>
<li>数据密集型系统设计</li>
</ul>


<h3>管理</h3>

<ul>
<li>别让猴子跳回背上</li>
<li>回归本源看绩效</li>
</ul>


<h3>企业</h3>

<ul>
<li>方舟：数字经济创新史</li>
<li>公司进化论</li>
<li>闪电式扩张</li>
<li>创新者的窘境</li>
<li>良性增长</li>
<li>定位：有史以来对美国营销影响最大观念</li>
<li>刷新：重新发现商业与未来</li>
<li>超级版图：全球供应链、超级城市与新商业文明的崛起</li>
</ul>


<h3>其他</h3>

<ul>
<li>程序员的三门课</li>
<li>程序员修炼之道</li>
<li>极简宇宙史</li>
<li>结构性思维：让思考和表达像搭积木一样有序省力</li>
<li>金字塔原理</li>
<li>模型思维</li>
<li>社会性动物</li>
<li>资本论</li>
<li>智慧的疆界：从图灵机到人工智能</li>
</ul>


<h2>生活</h2>

<p>生活上，每周五会和同事们一起去打两个小时篮球，然后隔一天在家里会利用杠铃、哑铃锻炼锻炼。令自己感到惊喜的是，突然有一天发现以前只能跪着做的健腹轮，现在可以站立做四五个了。但令自己失望的是，年底的体检自己以前的小毛病还是没怎么减少，都有点怀疑自己锻炼的效果了。看来必须同时控制饮食来让自己的各项指标回到以前了。另一方面，年底由于出差的次数越来越多，锻炼次数也受了不少影响。21年需要想办法在出差的时候也能够坚持锻炼。</p>

<p>其他的，生活上一切都在稳步向前，差强人意。</p>

<h2>总结</h2>

<p>以上是2020年的总结。整体来看，没有什么惊喜的一年。新的一年，自己的计划如下：</p>

<ul>
<li>重点的重点，找到游戏业务的突破方向，实现游戏业务的利润增长。</li>
<li>优化研发团队组织架构，提升业务价值，降低成本。</li>
<li>继续监控技术成本，控制成本支出，提高性价比。</li>
<li>有效推进Flutter等跨平台开发技术在公司的使用。</li>
<li>坚持锻炼身体！</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[研发效能杂谈]]></title>
    <link href="http://www.rowkey.me/blog/2020/08/13/dev-efficacy-talk/"/>
    <updated>2020-08-13T11:29:34+00:00</updated>
    <id>http://www.rowkey.me/blog/2020/08/13/dev-efficacy-talk</id>
    <content type="html"><![CDATA[<p>研发效能是什么？为什么现在都在谈如何提高研发效能？研发效能对于一个企业到底有多重要？本文按照Why、What、How三步走沉淀梳理了研发效能相关的知识点。</p>

<!--more-->


<h2>一. 为什么要提升研发效能</h2>

<ul>
<li>传统的职能部门组织架构带来的效率竖井问题</li>
<li>人力的增加没有让项目进度加快</li>
<li>长久加班导致团队士气低落，后续的效率降低</li>
<li>上线前加班、熬夜，压力大</li>
<li>上线后Bug、事故频发，实现效果与需求不匹配</li>
<li>各种重复低效工作，疲于应付业务</li>
<li>想要有限的人力做更多的产出</li>
</ul>


<h2>二. 什么是研发效能</h2>

<p>对于一个企业来说，追求的是企业效能的最大化，包括：利润、用户规模、客户满意度、运营效率等。而对于需要研发自有产品的互联网公司来说，研发效能则是服务于企业效能的至关重要的因素。</p>

<p>一个软件研发的完整流程如下图所示：</p>

<p><img src="http://www.rowkey.me/post_images/dev/devprocess.png" alt="" /></p>

<p>此流程交付期望产品的效率和能力，即研发效能。更进一步的《研发效率破局之道》中将研发效能定义为团队能够持续地为用户产生有效价值的效率，包括 <strong>有效性（Effectiveness）、效率（Efficiency）和可持续性（Sustainability）</strong> 三个方面。其增加的可持续性指出研发效能应该着眼于长期效果。</p>

<p>一句话来讲，研发效能就是持续快速交付价值的能力。</p>

<h2>三. 如何提升研发效能</h2>

<p>对应于第一部分中讲述的软件开发流程，如果想要提升研发效能，那么需要落实到研发流程（组织结构、项目管理、持续交付）、工程方法、个人效能以管理和文化的实践上。本文重点从研发流程、工程方法两方面来讲。</p>

<p><img src="http://www.rowkey.me/post_images/dev/whole.png" width="800"/></p>

<h3>3.1 衡量指标</h3>

<p>评估一个组织持续快速交付价值的能力，需要一组可量化的数据或参数，用来跟踪和评估开发过程的“健康”状况。</p>

<h4>3.1.1 指标分类</h4>

<ul>
<li>持续发布能力

<ul>
<li>发布频率：单位时间内的有效发布次数</li>
<li>发布前置时间：从代码提交到功能上线花费的时间</li>
</ul>
</li>
<li>需求响应周期

<ul>
<li>交付周期时间：从确认用户提出的需求开始，到需求上线经历的平均时长。</li>
<li>开发周期时间：从开发团队理解需求开始，到需求可以上线所经历的平均时长。</li>
</ul>
</li>
<li>交付吞吐率

<ul>
<li>单位时间交付用户需求数量：单个团队的对比</li>
</ul>
</li>
<li>交付过程质量：质量内建

<ul>
<li>缺陷创建和修复时间分布：缺陷能够持续和及时地被发现，并在发现后尽快修复。</li>
<li>缺陷库存：开发过程控制缺陷库存量，让产品始终处于接近可发布状态，是持续交付的基础</li>
</ul>
</li>
<li>交付质量：系统的可用性

<ul>
<li>单位时间问题数目</li>
<li>线上问题解决时长</li>
</ul>
</li>
</ul>


<h4>3.1.2 通用目标</h4>

<ul>
<li>2：2周交付周期。从想法提出并确认到上线的时间。【跨职能、组织的协调一致和紧密协作】</li>
<li>1：1周开发周期。从需求设计完成（对开发就绪）到达到可上线的时间。【需求的拆分和管理，开发团队的分工协作模式，持续交付实践】</li>
<li>1：1小时的发布前置时间。代码提交后可以在1小时内完成发布。【持续交付流水线】</li>
</ul>


<h4>3.1.3 选择优化指标</h4>

<p>流程中总是有一个核心瓶颈。分析关键路径、定位瓶颈，针对优化</p>

<ul>
<li>使用指标来发现问题而不是做绩效考核</li>
<li>使用指标来检验优化效果</li>
<li>使用价值流图/累积流程图发现全局瓶颈，从而确定需要提升的度量指标</li>
</ul>


<h3>3.2 组织结构&amp;&amp;项目管理</h3>

<h4>3.2.1 组织结构</h4>

<p>避免“效率竖井”： 采用以业务为单位的组织架构，保证业务线全栈配齐，目标一致。并从全局定位瓶颈进而进行优化工作。</p>

<h4>3.2.2 项目管理</h4>

<p>使用敏捷开发来提升研发效率</p>

<ul>
<li>敏捷 = 价值观 + 原则 + 一系列符合价值观和原则的方法。

<ul>
<li>软件应该一直处于可工作状态</li>
<li>每个迭代都能将软件部署到一个类生产环境中，并向用户演示</li>
<li>迭代长度不超过两周</li>
<li>透明性、协作性、纪律性和持续改进</li>
</ul>
</li>
<li>使用MVP，度量驱动开发</li>
<li>流程尽快流动：工程方法支撑</li>
<li>发现整个流程中的瓶颈，并解决：可视化工作流、事故复盘</li>
<li>避免“小瀑布”

<ul>
<li>价值排序</li>
<li>满足客户需要</li>
<li>需求拆分成能够独立测试的需求！！！</li>
</ul>
</li>
<li>看板

<ul>
<li>从个人转变到关注价值流动：待开发->设计->开发->开发自测->代码评审->测试->完成</li>
<li>明确的“完成的定义”DoD，明确了状态迁移必须完成的活动</li>
</ul>
</li>
<li>从实际出发、以终为始：以实用主义的态度，从原则出发，灵活优化流程</li>
</ul>


<p>一个可供参考的项目管理标准动作可见：<a href="https://www.rowkey.cn/blog/2020/07/31/project-manage/">项目管理标准模板</a></p>

<h3>3.3 持续交付</h3>

<p>持续交付指的是在短周期内完成软件产品，以保证软件保持在随时可以发布的状态。让每一个变更都经过一条自动化的检验流水线，来检查每一个变更的质量，通过就进入下一个阶段。<strong>其不是一种工具，而是一种实践！</strong></p>

<ul>
<li><strong>不要阻塞开发人员</strong></li>
<li>每个团队指定构建负责人或者发布工程师：优化交付流水线，提升交付效率</li>
<li>项目状态，应该对参与整个过程（包括构建、部署、测试和发布）的所有人都是可见的</li>
<li>风险管理

<ul>
<li><strong>迭代增量式交付</strong>是有效风险管理的关键</li>
<li>手工测试环境、试运行环境和生产环境总是需要严格的访问控制</li>
<li>让风险识别成为每日立会的一部分</li>
</ul>
</li>
<li>审计

<ul>
<li>手工测试环境、试运行环境和生产环境总是需要严格的访问控制：指定谁能够访问“特权”环境。</li>
<li>要求每次部署都要进行审计，以确切知道到底修改了哪些内容。</li>
<li>文档自动化、自文档</li>
</ul>
</li>
</ul>


<p>具体可见：<a href="https://www.rowkey.cn/blog/2020/06/15/cd/">持续交付这点事</a></p>

<h3>3.3 工程方法</h3>

<h4>3.3.1 技术债</h4>

<p>在开发产品或者功能的过程中，没有使用最佳的实现方法而引入的技术问题。需要持续关注业务和技术债。对业务机会敏感，敢放手一搏大量借贷，也知道什么时候必须偿还技术债。</p>

<ul>
<li>利用技术债的好处，必要时要大胆“举债前行”</li>
<li>控制技术债，在适当的时候偿还适当部分的技术债。</li>
</ul>


<h4>3.4.2 云计算</h4>

<p>利用好云计算带来的<strong>服务化、自助化和弹性伸缩</strong>三大优势。初创公司在业务刚起步时，使用 SaaS 或者 PaaS 快速开发业务；业务成长到一定规模之后，再逐步转到 IaaS 以及私有云降低成本。</p>

<ul>
<li>细节抽象得越多，云服务商负责的部分就越多，我们就越能够聚焦自己的业务，从而提高研发效能</li>
<li>使用云资源时，通过工具或者 API 调用来完成工作，减少人工参与，达到自动化</li>
<li>资源共享、弹性伸缩</li>
<li>容器：不可变基础设施；基于K8S建设PaaS</li>
</ul>


<p>在使用云计算时，要妥善处理它带来的挑战，比如分布式系统带来的安全和控制方面的问题。</p>

<ul>
<li>自治和集中管理相结合：信息可视化（系统整体的质量看板、调用链追踪）</li>
<li>错误处理</li>
</ul>


<h4>3.4.3 测试机制</h4>

<p>上文持续交付一部分中最关键的其实就是测试部分，只有具有完善、可靠的测试机制，才能保证研发质量和交付效果，才能从根本上提高研发效能。</p>

<ul>
<li>测试左移：质量内建，即持续交付中的测试机制。

<ul>
<li>按照功能的维度管理团队，让整个功能团队对产品负责；改变团队成员对测试工作的认知</li>
<li>把测试添加到开发和产品需求步骤中</li>
<li>频繁测试，快速测试：提升测试运行的速度，并行运行、提高构建速度、精准测试、分层测试、减少不必要的用例</li>
</ul>
</li>
<li>测试右移

<ul>
<li>利用线上的真实环境测试：需要有完备的数据隔离机制</li>
<li>测试人员介入线上监控和预警，及时发现问题并跟进解决</li>
<li>混沌工程：即在真实环境中通过模拟各种不可预期的故障来验证系统稳定性</li>
</ul>
</li>
</ul>


<h4>3.4.4 平台化</h4>

<p>通过抽象共性组件、功能，达到代码、功能复用，从而减少重复开发，提高研发效能。</p>

<ul>
<li>技术平台：技术设施的复用</li>
<li>数据中台：数据沉淀和输出能力</li>
<li>移动中台：前端组件、跨平台开发、插件化、热加载</li>
<li>业务中台

<ul>
<li>业务能力的复用</li>
<li>赋能业务</li>
</ul>
</li>
</ul>


<p>相关资料可见：<a href="https://www.rowkey.cn/blog/2019/11/23/middle-talk/">中台简谈</a></p>

<h3>3.5 个人效能</h3>

<p>如何提高开发人员自身的开发效率，除了每个人自身的天赋能力外，也有一些可以刻意使用的高效工具和方法。</p>

<ul>
<li>高效工作方法

<ul>
<li>抽象和分而治之</li>
<li>快速迭代</li>
<li>DRY</li>
<li>番茄工作法</li>
</ul>
</li>
<li>高效开发工具

<ul>
<li>好的IDE</li>
<li>操作系统快捷键</li>
<li>思维导图软件</li>
<li>学习笔记软件</li>
<li>文档撰写工具</li>
</ul>
</li>
<li>持续学习：不断地学习新的开发技能，从而提升自己的开发效率</li>
</ul>


<p>此外，还可以通过技术管理从外部驱动个人效能的提升，这在下面的技术管理部分会讲。</p>

<h3>3.6 管理和文化</h3>

<h4>3.6.1 技术管理</h4>

<p>管理包括：看方向、管人、管事。做好技术管理是提高研发效能的关键部分。其中，3.4节个人效能部分的数字驱动也是技术管理的一部分。主要步骤包括：</p>

<ul>
<li>制定目标：兼顾业务目标和技术目标</li>
<li>目标管理：使用OKR等目标管理方案</li>
<li>计划并执行去实现目标</li>
</ul>


<p>此外，技术管理中一个很难的问题是如何进行考核。这里可以使用数字化的方式，以驱动个人效能的提升。</p>

<ul>
<li>选择个人效能度量指标</li>
<li>根据代码提交日志自动生成工作日报和周报、个人贡献值</li>
<li>综合多维数据构建个人的数据画像

<ul>
<li>社会地位：用排名、榜单来实现；</li>
<li>工作本身：用复合型报告去综合评价，告知员工究竟做得好不好</li>
<li>自我改变：通过雷达图，进行多维度的数据分析，精准提炼员工的优点与不足，员工可以有针对性的取长补短。</li>
</ul>
</li>
</ul>


<p>需要说明的是，如果指标不能全方面的衡量，就不要做为考核指标，仅仅用于发现问题，解决问题！</p>

<p>一个可参考的技术管理标准动作模板见：<a href="https://www.rowkey.cn/blog/2020/04/25/tech-leader-manage/">技术管理标准模板</a></p>

<h4>3.6.2 团队文化</h4>

<p>团队文化是团队成员共同认可的价值观和行为准则，良好且有效的文化是保障团队高效产出的关键部分。很多互联网公司都是工程师文化主导的，包括Facebook、Google、百度等。他们也都具有自己独特的企业文化价值观，如百度的简单可依赖、谷歌的不作恶、Netflix的自由和责任。建立团队文化的步骤如下：</p>

<ul>
<li>定义：总结、明确自己团队的文化，提炼出简单易记的文字。</li>
<li>主张：各种形式的传播。从我自己的经历来看，不断地念经是其中最有效的方式。</li>
<li>追求：在奖惩中体现出文化价值观的作用。如对于文化价值观贯彻优秀的同学给与公开的肯定与奖励。</li>
</ul>


<h2>四. 参考资料</h2>

<ul>
<li><a href="https://book.douban.com/subject/6862062/">《持续交付》</a></li>
<li><a href="https://book.douban.com/subject/30419555/">《持续交付2.0》</a></li>
<li><a href="https://time.geekbang.org/column/intro/100034501">《研发效率破局之道》</a></li>
<li><a href="https://developer.aliyun.com/article/690725">如何衡量研发效能？阿里资深技术专家提出了5组指标</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[项目管理标准模板]]></title>
    <link href="http://www.rowkey.me/blog/2020/07/31/project-manage/"/>
    <updated>2020-07-31T11:29:34+00:00</updated>
    <id>http://www.rowkey.me/blog/2020/07/31/project-manage</id>
    <content type="html"><![CDATA[<p>之前写了一篇<a href="https://www.rowkey.cn/blog/2020/04/25/tech-leader-manage/">《技术管理标准模板》</a>，其中项目管理部分并没有具体深入，而这一技能不仅仅是对于技术Leader的要求，从我的经验看来，只要是程序员，具有项目管理能力都是如虎添翼的，即使你走的是专业路线。本文即基于自己的经验，从项目的启动和迭代阶段总结了敏捷项目管理的一些标准动作。</p>

<!--more-->


<h2>启动阶段</h2>

<ul>
<li><p>相关干系人沟通，同步项目背景、业务价值等</p></li>
<li><p>启动会议：召集相关干系人，明确业务相关信息，确定相关流程制度等</p></li>
<li><p>需求收集和分析-><strong>总体需求文档</strong>，概括性的功能与非功能需求列表</p></li>
<li><p>初步的产品规划-><strong>每一轮迭代的需求列表、发布时间</strong></p></li>
<li><p>创建项目基础设施-><strong>可持续交付到测试环境的基础项目</strong>，包括各个端的代码库、到测试环境的流水线等。</p></li>
</ul>


<h2>迭代阶段</h2>

<p>两周为一迭代，包括需求、设计、开发、测试、发布。关键点在于需求的拆分、优先级以及并行化。</p>

<h3>1. 需求评审</h3>

<p>对本轮迭代的需求尽心评审确认。</p>

<p><strong>前置条件</strong>：产品经理对此轮迭代进行需求确认，产出需求条目，按<strong>优先级</strong>排列；需求需要拆的足够小，把大需求拆成一个个<strong>能够独立开发测试发布</strong>的小需求</p>

<h3>2. 工作规划</h3>

<p>根据本轮迭代需求做WBS任务分解</p>

<ul>
<li><p>WBS工作项分解: 甘特图</p></li>
<li><p>里程碑结点: 表格或者里程碑图</p></li>
<li><p>风险管理：风险点预估、严重程度、可能性、应对措施</p></li>
</ul>


<h3>3. 设计/技术评审</h3>

<p>分别对交互设计和技术设计进行评审</p>

<p><strong>前置条件</strong>：设计师需要输出设计图；技术部分做概要设计和系统设计，随着每一轮迭代进行更新维护</p>

<h3>4. 测试用例评审</h3>

<p>由QA安排，会前需要提前将测试用例文档发给产品经理与研发，提前标注有疑问的用例。</p>

<h3>5. 开发、测试过程的监控</h3>

<p>持续交付：开发和迭代测试，需求开发完成后即测试并进行缺陷跟踪。</p>

<p><strong>会议</strong></p>

<ul>
<li><p>每日站会：全员站会，了解整体状况，对暴露出的风险和问题作出集体决策。</p></li>
<li><p>项目周会：10人以上团队。解决整体计划层面、跨团队协同配合的问题。</p></li>
</ul>


<p><strong>项目周报</strong></p>

<p>汇总项目总体状况，回答三个问题</p>

<ul>
<li><p>项目的整体进展状态到底如何？</p></li>
<li><p>风险可控吗？</p></li>
<li><p>目标达成有没有问题？</p></li>
</ul>


<h3>6. 版本全量测试</h3>

<p>对所有已经开发完的功能进行交叉测试、全量测试、埋点测试、回归测试、第三方云测。</p>

<h3>7. 验包发布</h3>

<p>此迭代所有功能开发测试完成后，提交审核流程，各流程审核人验收通过后发布。</p>

<h3>8. 复盘</h3>

<p>项目复盘会：有意识地向过去的行为经验学习</p>

<ul>
<li><p>团队做对了哪些事？</p></li>
<li><p>做错了哪些事？</p></li>
<li><p>再来一次，如何做得更好？</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[你要成为什么样的人？]]></title>
    <link href="http://www.rowkey.me/blog/2020/06/27/mytalk/"/>
    <updated>2020-06-27T11:29:34+00:00</updated>
    <id>http://www.rowkey.me/blog/2020/06/27/mytalk</id>
    <content type="html"><![CDATA[<p>今天参加了TGO鲲鹏会的小组会议，其中ksyun提了一个问题挺发人深思的，大体的意思就是你什么时候才明确地知道以后要成为什么样的人？</p>

<p>对于这个问题，自己挺有感触的。自己在这方面算是开悟比较早的，现在从事的事情也是自己在初中时候就确定的，虽然细节略有不同。</p>

<!--more-->


<p>还记得是97年上小学4年级，学校买了一些电脑（好像是浪潮牌的），让每个班学习比较好的学生上微机兴趣班。那时的我学习还算拔尖，也是其中一员。但那时懂计算机的老师也没有几个，我们每次上计算机课都是在那里对着DOS黑色的命令行在乱敲键盘。很多细节都记不清了，但那确实是自己计算机的启蒙。</p>

<p>后来上了初中，学校里开设了正规的计算机课，系统也成了Win 3.2、Win 95、Win 98这些。我们那个沿海小城已经有很多家里条件不错的同学有了自己的电脑。自己当时的几个好朋友都是其中一员，他们应该算是自己走上计算机这条路非常关键的人物。和大部分人一样，对电脑的频繁接触都是从游戏开始的。从网吧用软盘拷超级玛丽到学校的电脑上玩，在网吧里玩鹿鼎记、沙丘2000、红警95、雷神之锤、魔兽争霸贯穿了我整个初中生涯。当然，初中的计算机课还是很正规的，老师开始教我们使用Word、Excel、PowerPoint、Frontpage这些软件制作文档、PPT、网页。尤其当时家里条件好的同学会把制作的网页传到免费空间上去，然后还有自己的域名（网易的yeah.net免费域名和空间），在学校里都是风云人物。我看到那些网页真的是挺激动的，觉得就那么几行代码就能出来一个可以让很多人访问的东西真的很神奇。自己也就从编写网页开始了自己的程序员生涯。再加上当时互联网领域的世界首富比尔.盖茨和国内网络三剑客丁磊、王志东、张朝阳在财富榜上的崛起，我在心里默默决定选择程序员做为我以后的职业。这里还要提的是，我们那时候小学是五年，初中是四年，而初三的时候会有一个考高中微机实验班的机会，就是我们市的两所省重点高中会提前录取一批学习比较好的学生，集中在初四这年给大家上计算机相关课程。没什么意外的，自己进入了一中的实验班，这一年应该是自己网页编程技术进步最快的一年，包括给自己班级建立主页、维护学校主页这些。</p>

<p>小学和初中应该是自己计算机的启蒙阶段了。而到了高中，由于学业压力的原因，自己的计算机技术也就停留在能做个静态网页、能用js做点简单的动画效果的地步。说起来，我们高中当时在山东省算是信息学竞赛比较厉害的学校，每年都有不少人靠着这个竞赛保送一些名校。而自己当时由于眼界和胆量的问题是不敢赌这条路的，还是在安安稳稳地好好学习、参加高考。值得欣慰的是，最终自己高考的成绩还算不错，在选择学校时坚持了学计算机的想法，综合考虑选择了西电这所电子领域比较强的学校，以至于很多人在知道我高考的分数和省内的位次后都是很不解我为什么不选一些更好的学校的。这也许就是我很早就知道“要成为什么样的人”促使自己在人生一个关键的转折上做的一个抉择吧。</p>

<p>而后来上了大学直到现在工作多年也就一直沿着这条路走了下来。也挺感谢自己能够那么早就能知道自己想成为一个什么样的人的。至少很多事情都是自己的选择，即使后面有失败、有挫折、有失落，也是自己要对自己负责的事情。</p>

<p>“知道自己想成为什么样的人”延伸出来的，就是现在很多人都会疑惑人生该如何规划？我周围也有不少人会问我这个问题，包括还没上大学的、大学毕业即将进入社会的、在社会打拼好多年仍然迷茫的。基于自己的经历，我想说的是：如果你知道自己想成为什么样的人，那么就根据这个目标去筹划自己的人生就好；如果你不知道，那么在学校就好好学习，学习好会是一个最保险最稳妥的人生路径，在社会上就选择最热的行业，至少就业不成问题，经济收入也比较可观。看看这个社会上普遍意义上的成功人士，除了少数那些单纯靠运气发财的，即使是没有高学历的那些人，他们也都是明确知道自己想成为什么样的人，然后追随这个目标付出有效的努力最终才有了成功的结果。</p>

<p>越早知道自己要成为什么样的人，那么就会越早有自己的规划，从而就会越早地为这个目标付出有效的努力和资源。即使最后的结局没那么完美，自己也不会后悔的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[持续交付这点事]]></title>
    <link href="http://www.rowkey.me/blog/2020/06/15/cd/"/>
    <updated>2020-06-15T11:29:34+00:00</updated>
    <id>http://www.rowkey.me/blog/2020/06/15/cd</id>
    <content type="html"><![CDATA[<p>持续交付指的是在短周期内完成软件产品，以保证软件保持在随时可以发布的状态。让每一个变更都经过一条自动化的检验流水线，来检查每一个变更的质量，通过就进入下一个阶段。<strong>其不是一种工具，而是一种实践！</strong></p>

<!--more-->


<p>持续交付的共识和管理机制如下：</p>

<ul>
<li><strong>不要阻塞开发人员</strong>，这是实现持续交付的本质理念</li>
<li>为每个团队指定构建负责人或者发布工程师：优化交付流水线，提升交付效率</li>
<li>项目状态应该对参与整个过程（包括构建、部署、测试和发布）的所有人都是可见的</li>
<li>做好风险管理

<ul>
<li><strong>迭代增量式交付</strong>是有效风险管理的关键</li>
<li>手工测试环境、试运行环境和生产环境总是需要严格的访问控制</li>
<li>让风险识别成为每日立会的一部分</li>
</ul>
</li>
<li>做好审计

<ul>
<li>手工测试环境、试运行环境和生产环境总是需要严格的访问控制：指定谁能够访问“特权”环境。</li>
<li>要求每次部署都要进行审计，以确切知道到底修改了哪些内容。</li>
<li>文档自动化、自文档</li>
</ul>
</li>
</ul>


<p>接下来先说明实现持续交付的一些基础设施和准备工作，然后从本地开发和自动化构建/部署流水线两方面说明持续交付的具体实现。</p>

<h2>一. 基础设施和准备工作</h2>

<h3>1.1 基础设施和环境管理</h3>

<p>让所有测试环境（包括持续集成环境）都要与生产环境相似</p>

<ul>
<li>开发人员要把运维人员当做重要用户</li>
<li>切忌吞噬错误信息</li>
<li>使用运维团队熟悉的技术：开发人员最早负责创建部署脚本，后面移交给运维团队负责维护</li>
<li>把创建和维护基础设施需要的所有内容都进行版本控制</li>
<li>以自动化方式进行配置和部署！</li>
<li>像对待生产环境一样对待测试环境！</li>
<li>容器化技术实现不可变基础设施</li>
</ul>


<h3>1.2 配置管理</h3>

<p>版本控制、依赖管理、软件配置管理</p>

<ul>
<li>各个环境的手工配置 -> 自动化配置</li>
<li>对所有内容进行版本控制</li>
<li>指定依赖库的确切版本，不要用快照或者模式匹配版本</li>
<li>配置文件与二进制文件分离</li>
</ul>


<h3>1.3 测试策略</h3>

<ul>
<li>创建全面的自动化测试套件：单元测试、组件测试、验收测试，每一种测试的代码覆盖率都高于80%以上</li>
<li>每次修改都能运行一次自动化测试集合</li>
<li>分层测试</li>
</ul>


<h3>1.4 数据管理</h3>

<ul>
<li>把创建和迁移数据库全部变成自动化过程，是部署流程的一个组成部分</li>
<li>让测试自己创建它们所需的状态，并确保每个测试都独立于其他测试</li>
<li>对数据库进行版本管理，使用DbDeploy这样的工具管理数据迁移过程的自动化。</li>
<li>在大多数据情况下，不要在测试中使用生产数据集的副本。?</li>
<li>数据库回滚和无停机发布

<ul>
<li>蓝绿部署</li>
<li>大多数修改应该是增加操作（比如向数据库中增加新表或字段），尽可能不修改已存在的结构</li>
</ul>
</li>
<li>测试数据

<ul>
<li>测试的独立性、原子性</li>
<li>其他类型的测试，一定不要使用生产数据库的一个dump，除非有特殊情况</li>
</ul>
</li>
<li>部署流水线中的数据管理

<ul>
<li>提交测试：快速运行，避免复杂的数据准备</li>
<li>验收测试：后续阶段可以复用</li>
<li>容量测试：为测试提供足够的输入数据，可以看做验收测试的重复利用</li>
</ul>
</li>
</ul>


<h3>1.5 主干开发</h3>

<p>主干开发的分支模式实现持续交付最好的模式，但为了在主干模式下保持应用可发布，需要做到</p>

<ul>
<li>每次创建分支，都要认识到它带来的成本</li>
<li>频繁提交代码合并到主干</li>
<li>新功能隐藏：功能开关统一管理达到特性隐藏的目的(Togglz?)</li>
<li>增量开发：将所有的变更都变成一系列的增量式小修改，而且每次小的修改都是可发布的。</li>
<li>抽象模拟分支（无法使用增量开发）：修缮者模式，使用门面模式隔离待改造代码。</li>
<li>使用组件，根据不同部分修改的频率对应用程序进行解耦。</li>
</ul>


<h2>二. 本地开发</h2>

<p><strong>让开发者不受阻塞、不受不必要的干扰 -> 持续开发</strong></p>

<p><img src="http://www.rowkey.me/post_images/dev/localdev.png" alt="" /></p>

<ul>
<li>确保自动化测试、构建部署脚本都能够在开发机上运行</li>
<li>本地自动化测试：预测试提交pretested commit/个人构建personal build/试飞构建preflight build<strong>【保证本地开发所有验证方式与流水线上的验证方式一致，提高开发人员在本地发现问题的能力】</strong></li>
<li>提交前在本地运行所有的提交测试，等提交测试通过后再继续工作</li>
<li>在可控的环境上部署开发的应用程序</li>
<li>修复破坏应用程序的任意修改是最高优先级的任务，<strong>构建失败后不要提交新代码</strong></li>
</ul>


<h3>2.1 六步提交法</h3>

<p>规范开发习惯。主动提前集成；小步提交、完整代码、不影响已有功能；关注代码规范、动静态扫描问题</p>

<ul>
<li>检出最近成功的代码</li>
<li>修改代码</li>
<li>第一次个人构建</li>
<li>第二次个人构建： 拉取主干代码集成后本地测试</li>
<li>提交代码到主干</li>
<li>提交构建</li>
</ul>


<p>提交不影响已有功能！！</p>

<ul>
<li>增量迭代开发</li>
<li>抽象模拟分支</li>
<li>特性隐藏</li>
</ul>


<h3>2.2 规范化、自动化核心步骤</h3>

<p><img src="http://www.rowkey.me/post_images/dev/localdev-detail.png" alt="" /></p>

<ul>
<li>提高开发环境的效率: 环境获取的服务化、自助化；环境的一体化、一致性

<ul>
<li>本地开发环境

<ul>
<li>共享机器池</li>
<li>Git提交日志插入截图：Share Bucket+Google Drive</li>
<li>远程开发机器/Web IDE</li>
<li>依赖的服务

<ul>
<li>维护一个单独的环境，让开发环境接入</li>
<li>服务虚拟化工具来模拟依赖的服务，Mountbank、WireMock</li>
</ul>
</li>
</ul>
</li>
<li>联调环境：提供机器池，确保有两套空闲环境，自助化提供给开发者使用</li>
</ul>
</li>
<li>规范化、自动化本地检查

<ul>
<li>语法检查、规范检查、单元测试：Maven/Gradle插件</li>
</ul>
</li>
<li>建设并自动化代码入库前的检查流程

<ul>
<li>持续集成前的必要工作</li>
<li>代码审查</li>
</ul>
</li>
</ul>


<h3>2.3 代码审查</h3>

<p>人工代码检查</p>

<ul>
<li>统一并明确代码审查标准</li>
<li>统一并明确日志提交规范</li>
<li>传达团队的代码规则、质量基准</li>
<li>LGTM（Looks good to me）</li>
</ul>


<p><strong>方式</strong></p>

<ul>
<li>代码入库前的设计时检查：在设计阶段进行代码审查

<ul>
<li>代码入库前门禁检查，需要考虑灵活性，提供绕过机制</li>
<li>代码入库后检查</li>
</ul>
</li>
<li>工具辅助的线下异步审查：依赖于Gitlab、Gerrit、Code Climate Engines，一对一审查</li>
<li>面对面审查：架构问题、结对编程</li>
<li>代码增量审查/代码全量审查</li>
<li>团队审查：适合专项讨论</li>
<li>代码审查计入工作量和绩效考评</li>
</ul>


<p><strong>代码提交规范</strong></p>

<ul>
<li>原子提交</li>
<li>提交日志规范</li>
</ul>


<p><strong>原则</strong></p>

<ul>
<li>互相尊重</li>
<li>基于讨论</li>
</ul>


<p>相关资料可见：<a href="https://github.com/google/eng-practices/blob/master/review/index.md">谷歌代码审查指南</a></p>

<h3>2.4 快速反馈、增量开发</h3>

<blockquote><p>边开发边验证</p></blockquote>

<ul>
<li>提高运行静态检查和测试的方便性、灵活性：Maven/Gradle插件</li>
<li>提供沙盒环境方便验证和测试

<ul>
<li>容器</li>
<li>小范围的增量构建和验证？</li>
<li>测试数据：直接使用生产环境、生产数据的导出并脱敏</li>
</ul>
</li>
<li>实时检验工具：IDE实时检验、Liveload</li>
</ul>


<h2>三. 自动化构建/部署流水线</h2>

<p>部署流水线就是对软件交付流程的建模。</p>

<p><img src="http://www.rowkey.me/post_images/dev/deploy-pipeline.png" alt="" /></p>

<p>实现部署流水线的一些共识如下：</p>

<ul>
<li><strong>流水线建设原则</strong>

<ul>
<li>测试尽量完整，保证产品质量->完备的测试机制</li>
<li>运行速度够快->尽早反馈、提高交付速度</li>
<li>使用的所有环境尽量和生产环境一致->复现问题</li>
</ul>
</li>
<li>所有相关角色提供构建状态可视化：持续交付流水线大屏显示</li>
<li>存储构建结果报告</li>
<li>只要有环节失败，就停止整个流水线！</li>
<li>制品库是特殊的版本控制系统，不需要保存所有版本。</li>
<li>为部署流水线的每个阶段创建脚本：脚本是系统中的一等公民</li>
<li>增量式实现流水线：如果流程中有手工操作部分，就在流水线中为它创建一个占位符。</li>
</ul>


<p>接下来从流水线的各个阶段分别说明。</p>

<h3>3.1 提交阶段</h3>

<p>从技术角度上断言整个系统是可以工作的。</p>

<ul>
<li><strong>编译、单元测试、组装打包、代码分析</strong></li>
<li>少于五分钟，一定不要超过十分钟</li>
<li>提交测试：单元测试、组件测试</li>
<li>只有在某个错误让提交阶段的其他任务无法执行时，才停下来否则就直至提交阶段全部运行完后，汇总所有的错误和失败报告</li>
<li>此阶段的结果：结果报告、二进制包、元数据</li>
</ul>


<h3>3.2 自动化验收测试</h3>

<p>验证一个用户故事或需求的验收条件是否被满足。针对业务！</p>

<ul>
<li><strong>配置环境、部署二进制文件、冒烟测试、验收测试</strong></li>
<li>令验收测试失败的构建版本不能被部署</li>
<li>先部署再测试，重用部署脚本。</li>
<li>类生产环境运行验收测试：大部分是功能验收测试，关注功能正确性</li>
<li>开发人员能够在自己的开发环境中运行自动化验收测试</li>
<li>测试的关注点在系统的行为，而非数据本身。所以抵制使用生产数据的备份做为验收测试</li>
<li>验收测试的性能不是主要考虑问题，重点在测试的全面性。</li>
<li>正确地做验收测试：不要幼稚地对照着验收测试条件，盲目地把所有东西都自动化。</li>
<li>验收测试可以看作所有后续测试阶段（包括容量测试）的某种模板：从部署准备开始，然后核实环境和应用程序都已被正确配置和部署，最后执行测试。</li>
</ul>


<h3>3.3 后续测试</h3>

<ul>
<li>手工测试：探索性测试、易用性测试</li>
<li>非功能测试：性能、安全、可维护、可扩展</li>
</ul>


<h3>3.4 部署发布</h3>

<p>此阶段的触发不需要自动，测试或者运维人员可以做到自服务即可</p>

<ul>
<li>对不同环境采用同一部署方式：使用同样的脚本向所有环境部署，包括开发机器</li>
<li>一键式部署是对环境进行修改的唯一途径。</li>
<li>部署测试：对部署进行冒烟测试，验证部署是否成功，证明其部署的可靠性</li>
<li>确保部署流程是幂等的</li>
<li>只有通过了自动化构建、测试和部署的那些修改才能发布！</li>
<li>明确每个环境的部署和发布都是由谁负责</li>
<li>发布计划：第一次发布，产出一些文档、自动化脚本或其他形式的流程步骤</li>
<li>首次部署：首个迭代的主要目标之一就是在迭代结束时，让部署流水线的前几个阶段可以运行，实现部署流水线的“抽水泵”。

<ul>
<li>部署流水线的提交阶段。</li>
<li>一个用于部署的类生产环境。</li>
<li>通过一个自动化过程获取在提交阶段中生成的二进制包，并将其部署到这个类生产环境中。</li>
<li>一个简单的冒烟测试，用于验证本次部署是正确的，并且应用程序正在运行。</li>
</ul>
</li>
<li>对发布过程进行建模并让构建晋级

<ul>
<li>为了达到发布质量，一个构建版本要通过哪些测试阶段</li>
<li>每个阶段需要设置什么样的晋级门槛或需要什么样的签字许可。</li>
<li>对于每个晋级门槛来说，谁有权批准让某个构建通过该阶段。</li>
</ul>
</li>
<li>将每次已通过验收测试的变更版本部署在试运行环境中</li>
<li>紧急修复: 紧急修复版本也要走完标准的部署流水线，与其他代码变更没什么区别。

<ul>
<li>结对做！</li>
<li>有时候回滚比部署新的修复版本更划算。</li>
</ul>
</li>
<li>持续部署：每当有版本通过自动化测试之后，就将其部署到生产环境中。【需要依赖强大的自动化测试机制】</li>
</ul>


<h3>3.5 度量</h3>

<p>每次提交后都产生关于这些度量的报告和可视化效果并保存起来</p>

<ul>
<li>周期时间（cycle time），从决定要做某个特性开始，直到把这个特性交付给用户的这段时间</li>
<li>自动化测试覆盖率</li>
<li>代码库特征</li>
<li>缺陷数量</li>
<li>交付速度</li>
<li>提交版本库次数</li>
<li>构建次数</li>
<li>构建失败次数</li>
<li>构建所花时间</li>
</ul>


<h2>四. 其他</h2>

<h3>4.1 DevOps</h3>

<p>Devops是这些年很流行的一个概念，其目的就是打通研发和运维环节，以达到全员目标一致，保障软件高效交付。</p>

<p><img src="http://www.rowkey.me/post_images/dev/devops.png" alt="" /></p>

<ul>
<li>职能团队提供平台和工具，让全栈工程师能够自己处理端到端的工作，实现DevOps。</li>
<li>全栈开发：工程师不再只是对某一个单一职能负责，而是对最终产品负责。</li>
</ul>


<h3>4.2 信息溯源</h3>

<p>打通研发流程中流动的多种标识信息，以方便相关人员快速获取需要的信息，提高工作效率。包括任务工单、代码提交号、版本号、代码审查 ID、测试用例 ID、Bug ID。</p>

<ul>
<li>制品与源代码版本管理：放置在制品包中的元数据，体现源代码版本号。</li>
<li>源代码与需求/Bug的版本关联: 提交代码时需要在注释里注明需求ID、测试用例ID等。</li>
</ul>


<h2>五. 参考资料</h2>

<ul>
<li><a href="https://book.douban.com/subject/6862062/">《持续交付》</a></li>
<li><a href="https://book.douban.com/subject/30419555/">《持续交付2.0》</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《清教徒的礼物》学习笔记]]></title>
    <link href="http://www.rowkey.me/blog/2020/05/31/qjt/"/>
    <updated>2020-05-31T11:29:34+00:00</updated>
    <id>http://www.rowkey.me/blog/2020/05/31/qjt</id>
    <content type="html"><![CDATA[<p>同学推荐的一本管理书籍，主要是讲的美国的管理文化在世界各地的普及，尤其是日本和中国。阐述了清教徒（第一批欧洲移民，起源于英国，在北美殖民地得以实践与发展）的一些特质，也是美国能够打赢两次世界大战的原因，包括：建造“人间天国”的坚定信念；亲力亲为的技师精神；集体主义；组织能力：善于协调各种财力、物力和人力的组织能力。并且在书的最后给出了管理黄金时代优秀实务背后的25条原理。看完这本书，对于其中的一些东西很有共鸣，比如：自下而上的管理、专家（职业经理人）崇拜的危害等。</p>

<!--more-->


<p><img src="http://www.rowkey.me/post_images/qjt-notes.png" alt="" /></p>

<ul>
<li>清教的四个特点

<ul>
<li>建造“人间天国”的坚定信念</li>
<li>亲力亲为的技师精神：重视技术、重视技术人员</li>
<li>集体主义：集体大于个人</li>
<li>组织能力：善于协调各种财力、物力和人力的组织能力</li>
</ul>
</li>
<li>自下而上的管理

<ul>
<li>逐步去中心化</li>
<li>在十分正式的组织上面强加一个高度非正式的组织</li>
<li>把决策权沿指挥链下放至愿意承担又能够承担的最低层级</li>
<li>火线管理者从事基本的管理工作，上级管理层的工作是派生的</li>
<li>所有权力和责任都集中在火线管理者，只有火线管理者独立完成不了的，才交给上级管理者</li>
</ul>
</li>
<li>专家崇拜的危害：不懂业务的管理专家会带来诸多负面影响，包括各种强制量化，唯数据论等。</li>
<li>指导下属自学是自下而上管理的基本方法之一<strong>【杠杆率高的工作】</strong></li>
<li>优秀实务背后的25个原理

<ul>
<li>所有成功组织，不管多么简单，都由系统嵌套而成。</li>
<li>所有系统都离不开常规工作的补充，这些常规要定期审查和更新。</li>
<li>任何组织最重要的子系统都是层级，其基础很有可能是某种形式的直线职能制。</li>
<li>最好的层级形式是“自下而上”。</li>
<li>”集体决策“带来正确的决定<strong>【集体决策是风险最小的决策，但不一定是最正确的决策】</strong></li>
<li>领导层应尽量实行集体决策制或“共治“</li>
<li>中层管理者是管理的”拱心石“</li>
<li>一人一上司<strong>【混血型组织一般是多重汇报机制】</strong></li>
<li>会议是”管理工作的媒介“</li>
<li>计划应该分为短期（1-4年）、中期（5-8年）和长期（9年以上）。</li>
<li>研究前人的成败，从前人的经验中学习。</li>
<li>各个方向尤其是向上的信息流动畅通无阻，对组织的成功非常必要。</li>
<li>管理者在实际意义和道德意义上都应该是领导者</li>
<li>应该保守地使用顾问；应该把顾问”放在手边“而非”供在头上“</li>
<li>管理者应该清楚自己的社会责任，包括把员工当人而非商品对待</li>
<li>不要等坏了才修，要注意保养和改进。</li>
<li>像回避瘟神一样回避债务，如果不可能做到完全回避，那么尽可能少借债。</li>
<li>管理者应该拥有或获得”领域知识“，即深刻了解公司的技术和业务，这种知识只能通过在公司或公司所在行业长期实践才能获得</li>
<li>对管理者的考核和培训应该是实用的、连续的。</li>
<li>任何想晋升到顶层的管理者都该从底层做起。</li>
<li>工作轮换有利于打造”全才型“经理人。</li>
<li>用人应该持长期导向，这个长期至少8年，最好是10年。</li>
<li>互补是任命的关键之一。</li>
<li>薪酬制度应该奖励并促进合作。</li>
<li>像回避瘟神一样回避炫耀和张扬。</li>
</ul>
</li>
</ul>


<p>&ndash;</p>

<p>书籍链接：<a href="https://book.douban.com/subject/26760576/">https://book.douban.com/subject/26760576/</a></p>

<p><img src="http://www.rowkey.me/post_images/qjt.png" width="300"/></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[技术管理标准模板]]></title>
    <link href="http://www.rowkey.me/blog/2020/04/25/tech-leader-manage/"/>
    <updated>2020-04-25T11:29:34+00:00</updated>
    <id>http://www.rowkey.me/blog/2020/04/25/tech-leader-manage</id>
    <content type="html"><![CDATA[<p>对于技术团队新晋升的一些研发Leader，即使在大公司具有完善的培训机制，大多数人在一开始还是会手足无措，不能很好地做到从个人贡献者到团队贡献者角色的转变。于是根据自己以及公司内部很多技术管理者的工作经验梳理出了一些技术管理者的管理模板，可以作为管理工作的实践参考。</p>

<!--more-->


<p><img src="http://www.rowkey.me/post_images/tech-manage.png" alt="" /></p>

<h2>看方向</h2>

<ul>
<li><p>向上级明确团队的职责</p></li>
<li><p>基于职责确定团队的使命、目标</p></li>
<li><p>把职责、使命向团队成员传达清楚</p></li>
<li><p>做好团队规划，包括：规模、分工、梯队、资源盘点等</p></li>
<li><p>建立团队的WIki，包括：职责、使命、目标、团队规划、人员分工、规章制度等</p></li>
</ul>


<h2>管事</h2>

<ul>
<li><p>OKR</p>

<ul>
<li><p>制定团队OKR，对齐公司和部门OKR</p></li>
<li><p>跟进团队成员的个人OKR制定和进度跟踪</p></li>
<li><p>跟踪OKR进展，识别高绩效人才</p></li>
</ul>
</li>
<li><p>技术管理</p>

<ul>
<li><p>参与技术方向决策，将研发规范、例会等信息明确传达给团队成员并推进</p>

<ul>
<li><p>技术评审规范</p></li>
<li><p>代码风格规范</p></li>
<li><p>代码开发规范</p></li>
<li><p>代码管理规范</p></li>
<li><p>CodeReview规范</p></li>
</ul>
</li>
<li><p>组织技术评审、CodeReview</p></li>
<li><p>制定学习分享机制并切实推行</p></li>
<li><p>团队所负责维护的系统的周期巡检</p></li>
<li><p>公司层面基础技术以及成熟开源项目的引入和推进</p></li>
<li><p>了解技术方向相关技术的技术采纳生命周期，根据公司现状知道何时引入相应的技术</p></li>
</ul>
</li>
<li><p>项目管理</p>

<ul>
<li><p>技术方案确定</p>

<ul>
<li><p>技术选型</p></li>
<li><p>技术架构</p></li>
<li><p>技术难点</p></li>
<li><p>性能瓶颈</p></li>
<li><p>上下游系统</p></li>
<li><p>功能模块</p></li>
</ul>
</li>
<li><p>根据技术评审的结果预估开发工期并做好关键时间点的把控</p>

<ul>
<li><p>系统、模块、功能的设计以及简述</p></li>
<li><p>参与的研发人员以及分工</p></li>
<li><p>预估工时</p></li>
<li><p>预计完成时间</p></li>
<li><p>关键时间点、里程碑</p></li>
<li><p>确定会议机制：晨会、周会</p></li>
</ul>
</li>
<li><p>创建并保持项目文档的更新</p>

<ul>
<li><p>技术调研文档</p></li>
<li><p>方案选型文档</p></li>
<li><p>需求文档</p></li>
<li><p>系统设计文档</p></li>
</ul>
</li>
<li><p>项目风险管理</p></li>
<li><p>项目质量管理，包括代码质量把控和监控告警设施的接入</p></li>
<li><p>协调资源推进项目进展</p></li>
</ul>
</li>
<li><p>技术产品运营</p>

<ul>
<li><p>提炼团队项目的公共抽象部分，组件化和平台化</p></li>
<li><p>组件、技术平台的推广</p></li>
</ul>
</li>
<li><p>成本管理</p>

<ul>
<li><p>技术选型时把成本做为重要考量项</p></li>
<li><p>提升团队资源的利用率</p></li>
<li><p>关注团队的人力成本和技术成本</p></li>
<li><p>关注团队的产出价值</p></li>
</ul>
</li>
<li><p>流程改进</p>

<ul>
<li><p>定位阻碍研发的流程节点，寻找有效的解决方案</p></li>
<li><p>寻求有效工具或者方案提升关键流程效率</p></li>
</ul>
</li>
<li><p>制度建设</p>

<ul>
<li><p>明确公司和部门的规章制度并推进实行</p></li>
<li><p>根据团队需要，制定团队规章制度</p></li>
<li><p>制定SOP，保障下限水准</p></li>
<li><p>明确团队例会制度</p></li>
</ul>
</li>
</ul>


<h2>管人</h2>

<ul>
<li><p>定期的一对一沟通</p>

<ul>
<li><p>你所负责业务的完成情况到现在怎么样？目标完成情况怎么样？</p></li>
<li><p>这段时间自我评价绩效如何？什么原因？</p></li>
<li><p>你个人有没有什么你觉得我应该知道的？</p></li>
</ul>
</li>
<li><p>关注团队成员职业规划和能力成长，给与指导和建议</p></li>
<li><p>关注团队成员工作状态</p></li>
<li><p>组织团建，提高团队凝聚力</p></li>
</ul>


<h2>管理仪表盘</h2>

<p>建立自己的管理仪表盘，关注关键数据</p>

<ul>
<li><p>系统监控数据（QPS、硬件资源使用率、错误数等） -> 提前发现系统瓶颈，消除隐患；提高资源利用率，降低成本</p></li>
<li><p>项目构建报告（单元测试覆盖率报告、代码质量报告、构建失败与成功概况） -> 关注项目研发质量，保障持续交付</p></li>
<li><p>项目/任务进度 -> 保证项目/任务正常进行</p></li>
<li><p>业务关键数据指标 -> 关注业务价值，提升团队成员成就感</p></li>
<li><p>OKR进度 -> 关注OKR实现状况，识别高绩效人员</p></li>
<li><p>团队成员的每日/周的工作状况 -> 关注团队成员状况</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java工程师应该知道的Web安全]]></title>
    <link href="http://www.rowkey.me/blog/2020/03/10/web-security/"/>
    <updated>2020-03-10T11:29:34+00:00</updated>
    <id>http://www.rowkey.me/blog/2020/03/10/web-security</id>
    <content type="html"><![CDATA[<p>Java开发很大的一个应用场景就是Web，即使不是Web, 很多时候也是采用的和Web类似的处理方式。因此了解目前常见的Web安全问题并做防范是非常关键的。</p>

<p>Web安全问题，从大的方面可以分为：</p>

<ul>
<li>客户端安全：通过浏览器进行攻击的安全问题。</li>
<li>服务端安全：通过发送请求到服务端进行攻击的安全问题。</li>
</ul>


<p>常见的客户端安全问题有：</p>

<ul>
<li>跨站脚本攻击</li>
<li>跨站点请求伪造</li>
</ul>


<p>常见的服务端安全问题有：</p>

<ul>
<li>SQL注入</li>
<li>基于约束条件的SQL攻击</li>
<li>DDOS攻击</li>
<li>Session fixation</li>
</ul>


<p>本文主要针对这些问题进行讲述。</p>

<!--more-->


<h2>跨站脚本攻击</h2>

<p>跨站脚本攻击，全称Cross Site Script（XSS），故名思议是跨越两个站点的攻击方式。一般指的是攻击方通过“HTML”注入的方式篡改了网页，插入了恶意的脚本，从而在用户浏览网页或者移动客户端使用WebView加载时，默默地做了一些控制操作。</p>

<p>XSS可以说是客户端安全的首要问题，稍有不注意就会漏出相关接口被利用。</p>

<p>一个XSS攻击的例子，如下：</p>

<ul>
<li>一个Java应用提供了一个接口可以上传个人动态，动态内容是富文本的。</li>
<li><p>攻击者上传的内容如下：</p>

<p>  <code>&lt;img src="1" onerror="alert('attack')"/&gt;</code></p></li>
<li><p>在服务端和客户端程序未做任何过滤的情况下，其他用户访问这个动态的页面时，就会执行这个脚本。</p></li>
</ul>


<p>如果脚本不是一个alert，而是换成跳转到一个具有删除操作的URL或者脚本获取用户的Cookie然后发送到远程服务器上，可想而知危害有多大。</p>

<p>防范此种攻击的常用方式有以下几种：</p>

<ul>
<li>对任何允许用户输入的地方做检查，防止其提交脚本相关特殊字符串，如script、onload、onerror等。客户端和服务端都要做检查。</li>
<li>做输入过滤，即将特殊字符都过滤掉或者换成HTML转义后的字符。Java中可以使用Apache commons-lang中的StringEscapeUtils的escape前缀的方法来做转义。</li>
<li>给Cookie属性设置上HttpOnly，可以防止脚本获取到Cookie。</li>
<li>对输出内容做过滤。这个可在客户端做，也可在服务端做。服务端主要就是转义HTML字符，客户端可以使用escape方法来过滤。</li>
</ul>


<h2>跨站点请求伪造</h2>

<p>跨站点请求伪造，全称Cross Site Request Forgery,简称CSRF。也是一种常见的攻击方式。</p>

<p>此种攻击方式，主要是通过诱导用户点击某些链接，从而隐含地发起对其他站点的请求，进而进行数据操作。</p>

<p>一个攻击示例如下：</p>

<ul>
<li>一个用户登录了一个站点，访问<a href="http://xx/delete_notes?id=xx%E5%8D%B3%E5%8F%AF%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E7%AC%94%E8%AE%B0%E3%80%82">http://xx/delete_notes?id=xx%E5%8D%B3%E5%8F%AF%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E7%AC%94%E8%AE%B0%E3%80%82</a></li>
<li><p>攻击者在它的站点中构造一个页面，HTML页面含有以下内容：</p>

<p>  <code>&lt;img src="http://xx/delete_notes?id=xx"/&gt;</code></p></li>
<li><p>当用户被诱导访问攻击者的站点时就发起了一个删除笔记的请求。</p></li>
</ul>


<p>对于CSRF攻击的常用解决方案有以下几种：</p>

<ul>
<li>对重要请求要求验证码输入,这样就能防止在用户不知情的情况下，被发送请求。</li>
<li>使用类似防盗链的机制，对header的refer进行检验以确认请求来自合法的源。</li>
<li>对重要请求都附带一个服务端生成的随机token, 提交时对此token进行验证。这也是业界一个很普遍的做法。</li>
</ul>


<h2>SQL注入</h2>

<p>SQL注入攻击是一个很常见的攻击方式，原理是通过发送特殊的参数，拼接服务端的SQL字符串，从而达到改变SQL功能的目的。</p>

<p>一个攻击例子如下：</p>

<ul>
<li><p>服务端登录验证使用下面的方式,其中userName和userPwd都是用户直接上传的参数</p>

<pre><code class="``">  String sql = "select * from user where user_name = '" + userName + "' and pwd = " + userPwd;
</code></pre></li>
<li>用户提交userName为admin&#8217;&ndash;,userPwd随便字符串xxx</li>
<li>拼接好之后的SQL语句变成了：<code>select * from user where user_name = 'admmin'--' and pwd = 'xxx'</code>（&ndash;为SQL语句的注释）, 这样只要存在user_name为admin的用户，此语句就能成功执行并返回admin用户的信息。</li>
</ul>


<p>这里需要说明的是，如果服务器的请求错误信息没有做进一步封装，直接把原始的数据库错误返回，那么有经验的攻击者通过返回结果多次尝试就会有机会找出SQL注入的机会。</p>

<p>防范此种攻击的方案有以下几个：</p>

<ul>
<li>在Java中构造SQL查询语句时，杜绝拼接用户参数，尤其是拼接SQL查询的where条件。全部使用PreparedStatement预编译语句, 通过？来传递参数。</li>
<li>在业务层面，过滤、转义SQL特殊字符，Apache commons-lang中的StringEscapeUtil提供了escapeSQL的功能（最新的lang3已经删除此方法，因为其只是简单的替换&#8217;为&#8217;&lsquo;）。</li>
</ul>


<h2>基于约束条件的SQL攻击</h2>

<p>基于约束条件的SQL攻击基于的原理如下：</p>

<ul>
<li>在处理SQL中的字符串时，字符串末尾的空格字符都会被删除，包括WHERE子句和INSERT语句，但LIKE子句除外。</li>
<li>在任意INSERT查询中，SQL会根据varchar(n)来限制字符串的最大长度，即超过n的字符串只保留前n个字符。</li>
</ul>


<p>如此，我们设计一个用户表（暂且忽略设计的合理性），对其中的用户名和密码字段都设置为25个字符限制：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CREATE TABLE test_user (
</span><span class='line'>    `user_name` varchar(25),
</span><span class='line'>    `pwd`  varchar(25)
</span><span class='line'>);</span></code></pre></td></tr></table></div></figure>


<p>有一个user_name为<code>user_test</code>的用户注册，于是向数据库添加一条记录。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>insert into test_user values("user_test","111111");</span></code></pre></td></tr></table></div></figure>


<p>接着，一个user_name为&#8217;user_test              1&#8217;(中间留有25个空格)的用户再来注册。一般的业务逻辑如下：</p>

<ul>
<li><p>判断用户名是否存在</p>

<pre><code class="``">  select * from test_user where user_name = 'user_test              1'
</code></pre>

<p>  因为查询语句不会截断字符串，因此这样获取不到记录，表示用户不存在。</p></li>
<li><p>用户名不存在，那么插入新用户。</p>

<pre><code class="``">  insert into test_user values("user_test              1","123456")
</code></pre></li>
</ul>


<p>这样，由于<code>user_name</code>约束为25个字符，那么新用户的<code>user_name</code>成为了&#8217;user_test      &lsquo;（后面是16个空格字符）。现在数据库记录如下（第二个记录后面是16个空格）：</p>

<table>
<thead>
<tr>
<th>user_name </th>
<th> pwd</th>
</tr>
</thead>
<tbody>
<tr>
<td>user_test               </td>
<td> 111111</td>
</tr>
<tr>
<td>user_test               </td>
<td> 123456</td>
</tr>
</tbody>
</table>


<p>这样，当使用<code>user_name='user_test'</code>和<code>pwd='123456'</code>登录时，能匹配到第二条记录，登录是成功的。但是用户信息使用的第一条的记录，于是攻击者就获取到了第一个用户的操作权限。</p>

<p>防范此种攻击的措施如下：</p>

<ul>
<li>为具有唯一性的那些列添加UNIQUE索引。</li>
<li>在数据库操作前先将输入参数修剪为特定长度。</li>
</ul>


<h2>DDOS攻击</h2>

<p>DDOS，全称Distributed Denial of Service, 分布式拒绝服务攻击。攻击者利用很多台机器同时向某个服务发送大量请求，人为构造并发压力，从而使得服务被冲垮，无法为正常用户提供服务。常见的DDOS攻击包括：</p>

<ul>
<li>SYN flood</li>
<li>UDP flood</li>
<li>ICMP flood</li>
</ul>


<p>其中SYN flood是最为经典的DDOS攻击。其利用了TCP连接三次握手时需要先发送SYN的机制，通过发送大量SYN包使得服务端建立大量半连接，消耗非常多的CPU和内存。针对这种攻击，很多解决方案就是在TCP层就使用相关算法识别异常流量，直接拒绝建立连接。但是，如果攻击者控制很多机器对一个资源消耗比较大的服务接口发起正常访问请求，那么这个方式就无效了。</p>

<p>由于难于区分是否是正常用户的请求，因此DDOS是非常难以防范的，但仍有一些措施能够尽量地减少DDOS带来的影响，如下：</p>

<ul>
<li>合理使用缓存、异步等措施提高应用性能。应用抗并发的能力越强，就越不容易被DDOS冲垮服务。</li>
<li>合理使用云计算相关组件，自动识别高峰流量并做自动扩容。</li>
<li><p>在应用中限制来自某一IP或者某一设备ID的请求频率。超过此频率就将其放入黑名单，下次请求直接拒绝服务。Java中可以通过Redis的incr和expire操作来达到。如下：</p>

<pre><code class="``">  String ip = NetworkUtil.getClientIP(request, false); //获取客户端ip地址
  String key = "ddos." + ip;
  long count = suishenRedisTemplate.incr(key); //incr不会影响expire
  if (count &gt; 10000) {
      throw new AccessException("access too frequently with ip: "
           + StringUtils.defaultString(ip));
  } else {
      if (count == 1) {
          suishenRedisTemplate.expire(key, 10);
      }
      return true;
  }
</code></pre>

<p>  上述代码即可将同一IP的请求限制在十秒钟10000次。</p>

<p>  此逻辑越靠近访问链路的前面效果越好，比如直接在Nginx中拦截效果就要比在业务应用中做要好。</p></li>
</ul>


<p>还需要提到的是DDOS一个新的变种，反射型DDOS攻击，也被称为放大攻击。原理如下图所示：</p>

<p><img src="http://www.rowkey.me/post_images/reflect-ddos.png" alt="" /></p>

<p>此种攻击，攻击者并不直接攻击目标服务IP，而是伪造被攻击者的IP，发送请求包到网上一些开放的特殊服务的服务器（放大器。这些服务器由于协议的特点并不会验证源IP的真伪，于是会将数倍于请求报文的回复数据发送到被攻击者的IP，从而对后者间接形成DDOS攻击。任何设计不完善的、基于UDP请求的协议或者ICMP协议都能形成放大器，包括DNS请求、Ping请求、NTP monlist请求、SSDP协议（简单服务发现协议）等。此种攻击不需要大量的肉鸡、难以追踪，正变得越来越流行。防范此种攻击通常的手段就是进行DDOS流量清洗和增加ACL过滤规则。</p>

<h2>Session fixation</h2>

<p>Session fixation攻击，故名思议就是会话固定攻击。在我们平时的Web开发中都是基于Session做用户会话管理的。在浏览器中，Session的ID一般是存储在Cookie中的，甚至直接附带在query参数中。如果Session在未登录变为登录的情况下不发生改变的话，Session fixation攻击就形成了。</p>

<p>一个攻击示例如下：</p>

<ul>
<li>攻击者进入网站<a href="http://xx.com%E3%80%82">http://xx.com%E3%80%82</a></li>
<li>攻击者发送<a href="http://xx.com?JSESSIONID=123456%E7%BB%99%E4%B8%80%E4%B8%AA%E7%94%A8%E6%88%B7%E3%80%82">http://xx.com?JSESSIONID=123456%E7%BB%99%E4%B8%80%E4%B8%AA%E7%94%A8%E6%88%B7%E3%80%82</a></li>
<li>用户点击此链接进入网站，由于URL后面有JSESSIONID，因此直接使用此做为Session的ID。</li>
<li>用户成功登陆后，攻击者就可以利用伪造的Session ID获取用户的各种操作权限。</li>
</ul>


<p>此种攻击的关键点就在于Tomcat使用JSESSIONID做为Session ID。因此，防范此种攻击的核心之一就在于不能使用客户端传来的Session ID。此外还有以下方法：</p>

<ul>
<li>不要接受由GET或者POST参数指定的Session ID值。</li>
<li>针对每一个请求都生成新的Session。</li>
<li>只接受服务端生成的Session ID。</li>
<li>为Session指定过期时间。</li>
</ul>


<p>Java Web项目中,可以实现一个拦截器, 将使用query参数传递JSESSIONID的请求的Session删除掉：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void doFilter(ServletRequest request, ServletResponse response,
</span><span class='line'>                         FilterChain chain) throws IOException, ServletException
</span><span class='line'>    ...
</span><span class='line'>    
</span><span class='line'>    if (httpRequest.isRequestedSessionIdFromURL()) {
</span><span class='line'>        HttpSession session = httpRequest.getSession();
</span><span class='line'>        if (session != null) {
</span><span class='line'>            session.invalidate();
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>此外，对于每一次登录后的Session都重新生成ID, 并设置合理的失效期。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public JSONResult login(@RequestBody LoginRequestBody requestBody,
</span><span class='line'>                            HttpServletRequest request)
</span><span class='line'>    ...
</span><span class='line'>    boolean loginResult = doLogin();
</span><span class='line'>    if(loginResult){
</span><span class='line'>        request.changeSessionId(); //重新生成Session ID
</span><span class='line'>        request.getSession().setMaxInactiveInterval(1800); //30分钟失效
</span><span class='line'>    }
</span><span class='line'>    ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>隐私数据存储</h2>

<p>随着市面上发生一次次数据库被脱导致用户隐私数据被泄漏的事情，越来越多的人意识到了隐私的重要性，在选择一个应用的时候也越来越在意对自己隐私数据的保护。这里所说的隐私数据包括：手机号、实名、身份证号、家庭住址、单位地址、家庭情况、密码等等。那么在技术层面如何存储这些隐私数据来保障用户的隐私安全呢？</p>

<ol>
<li><p>使用单向散列算法</p>

<p> 此种方式对明文进行加密后是无法恢复明文的，因此仅仅适用于密码这种不需要恢复明文只需要做验证的场景。</p></li>
<li><p>使用加密算法</p>

<p> 此种方式，在存储和使用用户数据的时候都进行加/解密运算，能够在一定程度上保护数据的安全性。但每次都要进行加解密使得代价有点高，而如果使用简单的算法则无法面对穷举或者字典攻击。并且加密的数据对于SQL等数据库查询语句优化是不友好的，操作都得通过程序进行。此外，算法所使用的密钥的安全也是一个问题，存储在哪里都有被拿到的机会。而如果进一步对于每个用户或者每条数据都使用不同的密钥，那么就会提高程序的逻辑复杂性。</p>

<p> 还得考虑到日志采集、数据分析等非具体业务场景，这些隐私数据最终还是要变为明文进行流通，无法从根本上保证隐私数据的安全。</p></li>
</ol>


<p>综上分析，可以采取以下这种方案：</p>

<ol>
<li><p>每一个用户都有自己的密钥，对其手机号、身份证等隐私信息使用加密算法来混淆其中的几位。如：159efadsc2681。如此，在只是需要展示这些信息的地方无须解密，直接使用即可。只有诸如发送短信、用户信用验证时才需要解密。</p></li>
<li><p>密钥存储在另一个库中，由另外一个团队维护、独立管理，具有最高级别的访问权限，访问QPS也受严格控制。</p></li>
<li><p>如果给数据分析部门提供数据，则提供隐私数据转换后的数据。例如：对用户的归属地分析，那么可以提供身份证转化为地区归属地后的信息而不是直接提供身份证号。</p></li>
</ol>


<p>如此，即使脱库也无法解密所有数据。而且密钥库和业务库独立，单独脱一个库是没有意义的。密钥库的访问权限和访问频率也都受限制，即使是内部人员脱库都很容易被发现。</p>

<p>总之，对诸如身份证号、通讯录、支付宝账号等隐私信息要注意加密或者散列存储，一定不要明文发送到客户端，展示也不要明文展示，只有当真正使用的时候再去获取明文。</p>

<blockquote><p>本文节选自《Java工程师修炼之道》一书。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java工程师应该知道的RPC]]></title>
    <link href="http://www.rowkey.me/blog/2020/02/17/rpc/"/>
    <updated>2020-02-17T11:29:34+00:00</updated>
    <id>http://www.rowkey.me/blog/2020/02/17/rpc</id>
    <content type="html"><![CDATA[<p>RPC, Remote Procedure Call,故名思议就是远程过程调用，一般都有跨语言支持。大规模分布式应用中普遍使用RPC来做内部服务、模块之间的数据通信，还有助于解耦服务、系统的垂直拆分，使得系统可扩展性更强，并能够让Java程序员用与开发本地程序一样的语法与方式去开发分布式应用程序。</p>

<p>RPC分为客户端（服务调用方）和服务端（服务提供方），都运行在自己的JVM中。客户端只需要引入要使用的接口，接口的实现和运行都在服务端。RPC主要依赖的技术包括序列化、反序列化和数据传输协议。是一种定义与实现相分离的设计：</p>

<p><img src="http://www.rowkey.me/post_images/rpc/rpc.png" alt="" /></p>

<p>目前Java使用比较多的RPC方案主要有RMI、Hessian、Dubbo以及Thrift。</p>

<p>这里需要提出的一点就是，这里的RPC主要指的内部服务之间的调用，因此虽然RESTful也可以用于内部服务间的调用（跨语言、跨网段、跨防火墙），但其主要用途还是为外部系统提供服务，因此本文没有将其包含在内。</p>

<!--more-->


<h2>RMI</h2>

<p>RMI，remote method invoke, 远程方法调用。是JAVA自带的远程方法调用工具，其基于TCP连接，可以使用任意端口，不易跨网段调用，不能穿越防火墙。但它是JAVA语言最开始时的设计，后来很多框架的原理都基于RMI。其调用逻辑如下图所示：</p>

<p><img src="http://www.rowkey.me/post_images/rpc/rmi.png" alt="" /></p>

<ol>
<li>服务注册：服务端注册服务绑定到注册中心registry。</li>
<li>服务查找：客户端根据服务名从注册中心查询要使用的接口获取引用。</li>
<li>服务调用：Stub序列化调用参数并将其发送给Skeleton，后者调用服务方法，并将结果序列化返回给Stub。</li>
</ol>


<p>其序列化和反序列化使用的都是JDK自带的序列化机制。</p>

<p>这里服务注册管理中心是在服务端的。其实这个可以完全独立出来作为一个单独的服务，其他的RPC框架很多都是选择zookeepr充当此角色。</p>

<p>可以使用Spring那一节讲的RmiServiceExporter和RmiProxyFactoryBean来使用RMI。</p>

<h2>Hessian</h2>

<p>Hessian是一个基于HTTP协议的RPC方案，其序列化机制是自己实现的，负载均衡和容错需要依赖于Web容器/服务。其体系结构和RMI类似，不过并没有注册中心Registry这一角色，而是通过使用地址来显式调用。其中需要使用HessianProxyFactory根据配置的地址create一个代理对象。使用此代理对象去调用服务。</p>

<p><img src="http://www.rowkey.me/post_images/rpc/hessian.png" alt="" /></p>

<p>和RMI一样，可以使用Spring那一节讲的HessianServiceExporter和HessianProxyFactoryBean来使用。</p>

<h2>Thrift</h2>

<p>Thrift是Facebook开源的RPC框架，现已进入Apache开源项目。其采用接口描述语言（IDL）定义 RPC 接口和数据类型，通过编译器生成不同语言的代码（支持 C++，Java，Python，Ruby等），数据传输采用二进制格式，是自己实现的序列化机制。没有注册中心的概念。</p>

<p><img src="http://www.rowkey.me/post_images/rpc/thrift.png" alt="" /></p>

<p>Thrift的使用需要先编写接口的IDL，然后使用它自带的工具生成代码。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>namespace java me.rowkey.pje.datatrans.rpc.thrift
</span><span class='line'>
</span><span class='line'>typedef i32 int
</span><span class='line'>service TestService
</span><span class='line'>{
</span><span class='line'>    int add(1:int n1, 2:int n2),
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>//代码生成
</span><span class='line'>thrift --gen java TestService.thrift</span></code></pre></td></tr></table></div></figure>


<p>以上即可在gen-java目录下生成TestService的Java代码TestService.java, 其中的核心是接口TestService.Iface，实现此类即可提供服务。需要注意的是Thrift有一个问题就是在接口比较多的时候，生成的Java代码文件太大。</p>

<p>服务提供方：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>TProcessor tprocessor = 
</span><span class='line'>  new TestService.Processor&lt;TestService.Iface&gt;(new TestServiceImpl());
</span><span class='line'>
</span><span class='line'>TServerSocket serverTransport = new TServerSocket(8088);
</span><span class='line'>TServer.Args tArgs = new TServer.Args(serverTransport);
</span><span class='line'>tArgs.processor(tprocessor);
</span><span class='line'>tArgs.protocolFactory(new TBinaryProtocol.Factory());
</span><span class='line'>
</span><span class='line'>// 简单的单线程服务模型
</span><span class='line'>TServer server = new TSimpleServer(tArgs);
</span><span class='line'>server.serve();</span></code></pre></td></tr></table></div></figure>


<p>服务消费方：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>TTransport transport = new TSocket("localhost", 8088, TIMEOUT);
</span><span class='line'>TestService.Client testService = 
</span><span class='line'>  new TestService.Client(new TBinaryProtocol(transport));
</span><span class='line'>transport.open();
</span><span class='line'>
</span><span class='line'>int result = testService.add(1,2);
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<p>这里需要说明的一点就是，Thrift提供了多种服务器模型、数据传输协议以及传输层供选择：</p>

<ul>
<li><p>服务提供者的服务模型除了上面用的TSimpleServer简单单线程服务模型，还有几个常用的模型：</p>

<ul>
<li>TThreadPoolServer：线程池服务模型，使用标准的阻塞式IO，预先创建一组线程处理请求。</li>
<li>TNonblockingServe：非阻塞式IO。</li>
<li>THsHaServer: 半同步半异步的服务端模型。</li>
</ul>
</li>
<li><p>数据传输协议除了上面例子使用的BinaryProtocol二进制格式，还有下面几种：</p>

<ul>
<li>TCompactProtocol : 压缩格式。</li>
<li>TJSONProtocol : JSON格式。</li>
<li>TSimpleJSONProtocol : 提供JSON只写协议, 生成的文件很容易通过脚本语言解析。</li>
</ul>
</li>
<li><p>传输层除了上面例子的TServerSocket和TSocket，还有</p>

<ul>
<li>TFramedTransport：以frame为单位进行传输，非阻塞式服务中使用。</li>
<li>TFileTransport：以文件形式进行传输。</li>
<li>THttpClient: 以HTTP协议的形式进行传输。</li>
</ul>
</li>
</ul>


<h2>Dubbo</h2>

<p>Dubbo是阿里开源的服务治理框架。与前面讲的几个RPC协议相比，Dubbo不仅仅是一个RPC框架，还包含了服务治理方面的很多功能：</p>

<ul>
<li>服务注册</li>
<li>服务自动发现</li>
<li>负载均衡</li>
<li>集群容错</li>
</ul>


<p>这里仅仅针对Dubbo的RPC协议来讲，其传输是基于TCP协议的，使用了高性能的NIO框架Netty，序列化可以有多种选择，默认使用Hessian的序列化实现。Dubbo默认使用Zookeeper作为服务注册、管理中心。</p>

<p><img src="http://www.rowkey.me/post_images/rpc/dubbo.png" alt="" /></p>

<p>一个基于Spring XML配置的使用例子如下：</p>

<ul>
<li><p>服务提供者XML配置</p>

<pre><code class="``">  &lt;!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --&gt;
  &lt;dubbo:application name="test_server"/&gt;

  &lt;!-- 使用zk注册中心暴露服务地址 --&gt;
  &lt;dubbo:registry address="zookeeper://zk1.dmp.com:2181?backup=zk2.dmp.com:2181,zk3.dmp.com:2181" file="${catalina.base}/logs/eservice/dubbo.cache"/&gt;

  &lt;dubbo:service path="emailService" interface="me.rowkey.pje.rpc.test.service.IEmailService" ref="emailApiService" /&gt;
</code></pre></li>
<li><p>服务消费者XML配置</p>

<pre><code class="``">  &lt;!-- 提供方应用信息，用于计算依赖关系 --&gt;
  &lt;dubbo:application name="test_consumer"/&gt;

  &lt;!-- 使用zk注册中心 --&gt;
  &lt;dubbo:registry address="zookeeper://zk1.dmp.com:2181?backup=zk2.dmp.com:2181,zk3.dmp.com:2181" /&gt;

  &lt;dubbo:reference id="emailService" interface="me.rowkey.pje.rpc.test.service.IEmailService"/&gt;
</code></pre>

<p>  在相关bean中注入emailService即可使用。</p></li>
</ul>


<h2>序列化</h2>

<p>序列化是RPC的一个很关键的地方，序列化、反序列的速度、尺寸大小都关系着RPC的性能。包括上面提到的几个序列化协议，现在使用较为普遍的Java序列化协议有以下几种：</p>

<ol>
<li><p>Java Serialiazer</p>

<p> JDK自带的序列化机制, 使用起来比较方便。但是其是对象结构到内容的完全描述，包含所有的信息，因此速度较慢，占用空间也比较大，且只支持Java语言。一般不推荐使用。</p>

<p> 需要注意的是字段serialVersionUID的作用是为了在序列化时保持版本的兼容性，即在版本升级时反序列化仍保持对象的唯一性。否则如果你在序列化后更改/删除了类的字段，那么再反序列化时就会抛出异常;而如果设置了此字段的值，那么会将不一样的field以type的预设值填充。</p>

<pre><code class="`"> //序列化
 ByteArrayOutputStream bout = new ByteArrayOutputStream();
 ObjectOutputStream out = new ObjectOutputStream(bout);
 out.writeObject(obj);
 byte[] bytes = bout.toByteArray();

 //反序列化
 ObjectInputStream bin = new ObjectInputStream(new ByteArrayInputStream(bytes));
 bin.readObject();
</code></pre></li>
<li><p>Hessian</p>

<p> 底层是基于List和Hashmap实现的，着重于数据，附带简单的类型信息的方法，支持多种语言，兼容性比较好, 与JDK序列化相比高效且空间较小；但其在序列化的类有父类的时候，如果有字段相同，父类的值会覆盖子类的值，因此使用Hessian时一定要注意子类和父类不能有同名字段。</p>

<p> 需要注意的一点，Hessian的实现里有v1和v2两种版本的协议支持，并不兼容，推荐使用Hessian2相关的类。</p>

<p> 与后来出现的其他二进制序列化工具相比，其速度和空间都不是优势。</p>

<pre><code class="`"> //序列化
 ByteArrayOutputStream os = new ByteArrayOutputStream();
 Hessian2Output out = new Hessian2Output(os);
 out.startMessage();
 TestUser user = new TestUser();
 out.writeObject(user);
 out.completeMessage();
 out.flush();
 byte[] bytes = os.toByteArray();
 out.close();
 os.close();

 //反序列化
 ByteArrayInputStream ins = new ByteArrayInputStream(bytes);
 Hessian2Input input = new Hessian2Input(ins);
 input.startMessage();
 TestUser newUser = (TestUser)input.readObject();
 input.completeMessage();
 input.close();
 ins.close();
</code></pre></li>
<li><p>MsgPack</p>

<p> MsgPack是一个非常高效的对象序列化库，支持多种语言，有点像JSON，但是非常快，且占用空间也较小，号称比Protobuf还要快4倍。</p>

<p> 使用MsgPack需要在序列化的类上加@Message注解；为了保证序列化向后兼容，新增加的属性需要加在类的最后面，且要加@Optional注解，否则反序列化会报错。</p>

<p> 此外，MsgPack提供了动态类型的功能，通过接口Value来实现动态类型，首先将字节数组序列化为Value类型的对象，然后用converter转化为本身的类型。</p>

<p> MsgPack不足的一点就是其序列化和反序列都非常消耗资源。</p>

<pre><code class="`"> //TestUser.java
 @Message
 public class TestUser{
     private String name;
     private String mobile;
     ...
 }

 TestUser user = new TestUser();
 MessagePack messagePack = new MessagePack();

 //序列化
 byte[] bs = messagePack.write(user);

 //反序列化
 user = messagePack.read(bs, TestUser.class);
</code></pre></li>
<li><p>Kryo</p>

<p> Kryo是一个快速高效的Java对象图形序列化框架，使用简单、速度快、序列化后体积小。实现代码非常简单，远远小于MsgPack。但其文档较少，跨语言支持也较差，适用于Java语言。目前Kryo的版本到了4.x, 对于之前2.X之前版本的很多问题都做了修复。</p>

<pre><code class="`"> Kryo kryo = new Kryo();

 // 序列化
 ByteArrayOutputStream os = new ByteArrayOutputStream();
 Output output = new Output(os);
 TestUser user = new TestUser();
 kryo.writeObject(output, user);
 output.close();
 byte[] bytes = os.toByteArray();

 // 反序列化
 Input input = new Input(new ByteArrayInputStream(bytes));
 TestUser newUser = kryo.readObject(input, TestUser.class);
 input.close();
</code></pre></li>
<li><p>Thrift</p>

<p> 上面讲的Thrift RPC框架其内部的序列化机制可以单独使用，主要是对TBinaryProtocol的使用。和接口的生成方式类似，需要先定义IDL，再使用Thrift生成。其序列化性能比较高，空间占用也比较少。但其设计目标并非是单独做为序列化框架使用的，一般都是整体作为RPC框架使用的。</p>

<p> 定义IDL:</p>

<pre><code class="`"> //TestUser.thrift
 namespace java me.rowkey.pje.datatrans.rpc.thrift

 struct TestUser {
     1: required string name
     2: required string mobile
 }

 thrift --gen java TestUser.thrift
</code></pre>

<p> 使用生成的TestUser类做序列化和反序列化：</p>

<pre><code class="`"> TestUser user = new TestUser(); //由thrift代码生成引擎生成

 //序列化
 ByteArrayOutputStream bos = new ByteArrayOutputStream();
 user.write(new TBinaryProtocol(new TIOStreamTransport(bos)));
 byte[] result = bos.toByteArray();
 bos.close();

 //反序列化
 ByteArrayInputStream bis = new ByteArrayInputStream(result);
 TestUser user = new TestUser();
 user.read(new TBinaryProtocol(new TIOStreamTransport(bis)));
 bis.close();
</code></pre>

<p> 需要注意的是由于Thrift序列化时,丢弃了部分信息，使用ID+Type来做标识，因此对新增的字段属性, 采用ID递增的方式标识并以Optional修饰来添加才能做到向后兼容。</p></li>
<li><p>Protobuf</p>

<p>Protobuf是Google开源的序列化框架，是Google公司内部的混合语言数据标准，用于RPC系统和持续数据存储系统，非常轻便高效，具有很好的可扩展性、也具有良好的向后兼容和向前兼容性。与上述的几种序列化框架对比，序列化数据紧凑、速度快、空间占用少、资源消耗较低、使用简单，但其缺点在于需要静态编译生成代码、可读性差、缺乏自描述、向后兼容有一定的约束限制。</p>

<p>这里需要注意目前ProtoBuf的版本到了3.x，比2.x支持更多语言但更简洁。去掉了一些复杂的语法和特性，更强调约定而弱化语法。因此，如果是首次使用就直接使用3.x版本。这里也针对Protobuf 3来讲。</p>

<p>首先需要编写.proto文件,并使用Protobuf代码生成引擎生成Java代码。</p>

<pre><code class="`"> //TestUser.proto
 syntax = "proto3";
 option java_package = "me.rowkey.pje.datatrans.rpc.proto";
 option java_outer_classname = "TestUserProto";
 message TestUser
 {
     string name=1;
     string mobile=2;
 }

 protoc --java_out=./ TestUser.proto
</code></pre>

<p>即生成TestUserProto.java，使用此类，即可完成序列化和反序列化：</p>

<pre><code class="`"> //序列化
 TestUserProto.TestUser testUser = 
           TestUserProto.TestUser.newBuilder()
           .setMobile("xxx")
           .setName("xxx")
           .build();

 byte[] bytes = testUser.toByteArray();

 //反序列化
 testUser = TestUserProto.TestUser.parseFrom(bytes);
</code></pre></li>
</ol>


<p>综上，对以上几个序列化框架做对比如下：</p>

<p> | 优点 | 缺点
&mdash;-|&mdash;&ndash;|&mdash;&mdash;
Java | JDK自带实现，包含对象的所有信息| 速度较慢，占用空间也比较大，只支持Java语言
Hessian | 支持语言比较多，兼容性较好 | 较慢
MsgPack | 使用简单，速度快，体积小| 兼容性较差，耗资源
Kryo | 速度快，序列化后体积小 | 跨语言支持较差，文档较少
Thrift | 高效 | 需要静态编译；是Thrift内部序列化机制，很难和其他传输层协议共同使用
Protobuf | 速度快 | 需要静态编译</p>

<p>在兼顾使用简单、速度快、体积小且主要使用在Java开发的场景下，Kryo是比较好的方案；如果特别要求占用空间、性能，那么Protobuf则是更好的选择。此外，JSON其实也是一种序列化方式，如果比较关注阅读性的话，那么JSON是更好的选择。</p>

<h2>提示</h2>

<p>面对这些RPC框架，选择的时候应该从以下几方面进行考虑：</p>

<ul>
<li>是否允许代码侵入：即是否需要依赖相应的代码生成器生成代码，比如Thrift需要，而Dubbo、Hessian就不需要。</li>
<li>是否需要长连接、二进制序列化获取高性能：如果需要性能比较高，那么果断选取基于TCP的Thrift、Dubbo。</li>
<li>是否需要跨网段、跨防火墙：这种情况一般就需要选择基于Http协议的，Hessian和Thrift的HTTP Transport。</li>
<li>是否需要跨语言调用：Thrift、Hessian对于语言的支持是比较丰富的，而Dubbo目前只支持Java语言。</li>
</ul>


<p>此外，除了上述框架之外，Google推出的基于HTTP 2.0的gRPC框架也开始得到了应用，其序列化协议基于Protobuf, 网络框架使用了Netty4。但其需要生成代码，可扩展性也比较差。</p>

<blockquote><p>本文节选自《Java工程师修炼之道》一书。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我是科蜜，20年的...]]></title>
    <link href="http://www.rowkey.me/blog/2020/01/27/kobe/"/>
    <updated>2020-01-27T11:29:34+00:00</updated>
    <id>http://www.rowkey.me/blog/2020/01/27/kobe</id>
    <content type="html"><![CDATA[<p>5：30左右突然惊醒，拿起手机一看有同学给我发微信说科比挂了。我大大的问号，赶快看了一下朋友圈和网易新闻，已经有人发出了国外网站正式的报道。。。心里顿时五味陈杂，一时不知道如何是好。一个陪伴了自己整个少年时代的偶像说没就没了，还是以这种意外的方式，相信好胜心那么强的他也是非常不甘心的。也许有人会说，人家这么一个超级巨星，你们这些粉丝矫情啥，人家都不认识你。确实，我的存在对他来说是无所谓的，但是他对我的意义却是不一般，我也相信他对于无数他的粉丝都有不一样的意义。</p>

<!--more-->


<p>记得2000年我上初中，在同学家里玩NBA Live游戏，同学跟我说这个湖人队8号投篮真准，那是我第一次认识科比。那时候电视只有中央2台每周会播一次nba比赛，每到湖人比赛我都必看。也到处搜集科比的各种贴画，家里贴满了他的海报。那时候自己的爱好就是搜集科比的各种资料。也是因为科比，我开始喜欢上打篮球，虽然受限于身高，水平一直不咋样，但好胜心和他差不多，经常为了赢不了球，摸不到球，上不了场而特别难受。</p>

<p>后来上了初四实验班（相当于高中提前录取），由于是微机实验班，学习比较轻松，有很多时间来做一些自己喜欢的事情。而对我自己来说，除了摆弄一些电脑的事情，就是看各种体育新闻、看科比的新闻。那时候班里同学们会经常一起买篮球报、当代体育、篮球先锋报，然后换着看。当然，青春时代，少不了的就是“比”，经常和同学争论是科比厉害还是艾佛森、卡特、麦迪厉害。而2003年的科比闹出了鹰郡性侵案，迎来了人生的谷底，自己看到了他的各种无助和无奈，感觉全世界都开始抛弃他。不过最终他还是挣脱了出来，有了单场62分、单场81分、赛季场均35.4分的神迹，也把自己的球衣号码换成了24号，那意味着每天每个小时都要努力，也意味着他蜕变成了一个领袖。那时候的我也已经正式开始了高中生涯，和以前不一样的是，学习压力开始变得巨大，每天就是做题考试，生活也开始变得枯燥，一周半天假，一个月一天半假，休息时间也开始变得多余，而且我们班还禁止打篮球。。。自己只能靠去看科比的各种新闻作为调节剂，他每一次表现好，我也就状态好，也就考的好。那时真的以为自己和他有某种关联了。。。也会和同学见缝插针的去打球，即使是课间休息的那十分钟。和他这段经历类似的是，我小学初中一直是年级第一第二，但高中在班级里一直处于十几名的位置，是包括我后面大学的所有学生生涯的谷底，但高考我发挥还不错，第一次考了班级第一，虽然是因为班里几个学神发挥不太好，但是分数我也是比较满意的。</p>

<p>后来上了大学，依然热情不减，宿舍的墙上都是科比的海报，鼠标也是湖人款的。也看着湖人慢慢组建齐了冠军阵容，直到09年夺冠，那一刻我当时就哭了。从巅峰到谷底再到巅峰，那种经历想想就令人动容。尤其是10年，还记得总决赛最后一场的上半场已经落后将近20分，当时我心灰意冷，再加上早起看比赛，实在忍不住困意倒头就睡了。在睡梦中突然听到全宿舍楼的人在欢呼，我心想不会逆转了吧，打开电视看到科比在欢呼，那一刻就感觉自己拿了总冠军一样。那年的我正式本科毕业，专业第一保送了研究生，也算是和科比的巅峰关联吧。</p>

<p>再后面，湖人的夺冠班底逐渐散了，从此一蹶不振。科比也一次次遭遇伤病从而无奈退役。我自己也从研究生毕业开始走上社会，也慢慢变得没时间没兴趣看nba比赛，尤其是科比退役之后，真的是觉得nba这些比赛没啥意思。科比退役后的各种新闻还是会让我激动，他拿了奥斯卡最佳短片动画奖，他开公司，他和马云在企业峰会上高谈阔论，他来中国参加综艺节目，他参加雪碧慈善邀请赛，我真觉得他退役后的成就有可能超越他的篮球成就。记得离他最近的一次就是14年科比受马云的邀请来阿里，虽然是在隔壁的公司里，虽然自己还是没见到。。。我自己一直以来的梦想之一就是有一天可以变得足够优秀能够和他成为朋友，能够在洛杉矶做他的邻居。可惜这一切再也不可能实现。。。也可能成为我这一生最大的遗憾之一。</p>

<p>就是这个人，凌晨四点的洛杉矶、对队友的严格要求、右手受伤就把左手投篮练出来、手指扭了硬生生掰回去继续比赛，他的好胜心、偏执和努力激励我的进步，他是我的青春。这就是科比对一个20年科蜜的意义。</p>

<p>谢谢你，科比！祝福你在天堂里可以继续你的精彩。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我的2019]]></title>
    <link href="http://www.rowkey.me/blog/2020/01/23/my2019/"/>
    <updated>2020-01-23T11:29:34+00:00</updated>
    <id>http://www.rowkey.me/blog/2020/01/23/my2019</id>
    <content type="html"><![CDATA[<p>和去年一样，本文来自自己给部门的公开信。内容经过脱敏。</p>

<hr />

<p>2020年已经过去了快一个月。回顾2019年，真的感谢大家，总体来看，部门的全年产出是符合预期的，也获得了其他需求部门的高度好评。不仅仅支撑了微鲤看看、广告平台、用户增长等业务相关系统的快速迭代，也不断地在探索运维基础设施、前端基础设施、大数据平台、推荐系统、公共组件、技术中间件并取得了一些令人印象深刻的成果。</p>

<p>要求了大家做全年的总结和新的一年的规划，我自己也从工作、学习和生活三个方面来总结一下我自己的2019年。</p>

<!--more-->


<h2>工作</h2>

<p>说到工作，特别想跟大家说一下加班的问题。由于公司战略的要求，公司在年底的几个月开始了大小周，目的是为了增加产出，也是为了让大家能够有一种创业公司的心气。也有部门的同事跟我反映过说部门不怎么加班，感受不到创业公司的气氛。这一点非常值得称赞。我在这里再讲一下我对加班的看法。</p>

<ul>
<li>加班的目的并不是加班，而是提高产出，那么产出是由效率和时间决定的。如果时间增加，但是效率下降，大部分情况下，产出也是下降的。</li>
<li>对于脑力工作者，每天能够高效工作5、6小时就很了不起了，再多的时间其实是低效劳动，太过疲劳反而容易出错。</li>
<li>很多人工作散漫，干活拖拖拉拉，心想着干不完就加会儿班。在合理的时间内干不完活而加班，是工作能力低的表现，这种行为并不值得提倡。</li>
<li>根据我自己的经验看，长期加班，根源问题基本都是“项目失控”。由于技术中心的特殊性，很多项目都是没有产品经理也基本面向的都是内部人员，项目的排期安排一直以来都是让每个人来定的。只要合理，我一般都不会有什么意见，有问题也一直欢迎大家跟我提意见。如果你定了deadline，却经常需要加班来赶进度，明显的就是在评估工时、项目管控上有问题。当然，我过去做的不好的一点就是只给进度要求，不给资源，这一点我会注意改进。</li>
<li>死守自己的deadline-高标准、准时、保质保量、不给其他同事挖坑。最好的团队合作，不是你整天对别人的工作指手画脚，整天看着各种客观原因，而是把自己的事情做到位，做到极致。这也是我今年讲的最多的要具有“owner意识”：把交给自己的任务当成自己的东西，追求极致，最后受益的不仅仅是公司，你自己也会得到最大的成长和他人的认可。</li>
<li>少加班，多动脑。和我之前听到过的说法“脑子要比手快”是一个道理。做事之前，先想想有没有更好的办法，比立即就闷头苦干，最终带来的效果可能是千差万别的。而且，作为一个公司、一个商业组织来说，最终看的只能是功劳，不会是苦劳。</li>
<li>脑力工作者想要划水摸鱼，很难被发现。我并不想给大家营造一种加班的氛围，非得大家每天在公司待到九点十点才行。我希望的是大家都是志同道合的人，是即使不加班，也会在业余时间思考、学习的人。</li>
</ul>


<p>还有一点需要提的是一个概念叫“情绪自由”。怎么说呢？之前，有同事跟我讨论了这个“情绪自由”的问题。就是说你所处的位置有时候决定了你敢不敢发泄你的情绪？比如说，你是一个没有管理职权的开发工程师，那么大部分情况下，即使你心里有情绪也不会发泄出来，因为你知道发泄出来也没用。而如果你是一个Leader，在你团队成员面前，很多时候就会随意让情绪宣泄出来。这个其实非常不好，尤其是对于一个公司的管理层来说，如果总是“情绪自由”，那么大家就会越来越不敢提问题，隐藏在看不到的地方的问题也就越来越多，累积起来一旦爆发那么后果也会严重的多。</p>

<p>接下来，从部门管理、架构、技术团队管理三个部分来讲一下2019年我完成的工作。</p>

<h3>部门管理</h3>

<p>2019年部门发生了一些组织架构改动，组织架构的改动服务于公司的整体目标，随之而来的则是人员的变动，再加上持续的有人加入有人离开，人员的变动带来了一系列问题：如何让大家知道并深刻理解部门的文化，如何融入部门，如何更有凝聚力。对于这些，做的一些工作包括：</p>

<ul>
<li>重新定义了部门的文化：<strong>极客创新、及时反馈</strong>，对之前的“件件有着落、事事有回音”做了简化的同时，还增加了极客创新，目的就是让大家意识到“技术中心”应该是一个创新部门，是一个用创新提升业务的部门。</li>
<li>重新梳理了部门的月度例会流程，包括：

<ul>
<li>不断念经，让大家能够深刻理解并贯彻部门文化</li>
<li>同步OKR进度，让大家随时了解部门的OKR进度，知道关键目标在哪</li>
<li>增加了“每月分享”环节，让大家分享自己工作、生活中的心得，给大家带来启发</li>
</ul>
</li>
<li>探索除了聚餐之外的团建形式，实践形式包括：switch游戏比赛、组队知识竞赛、巅峰故事会等。</li>
</ul>


<p>部门的梯队建设也有了一定程度的起色，在各个团队Leader的共同努力之下，每个团队都有增员。</p>

<p>此外，今年由于某些原因，自己承担了行政人事事务决策的工作，帮助行政人事部门做了一些工作。</p>

<h3>架构</h3>

<p>架构组是今年才正式成立的。也引入了公司第一个专职架构师，从最终的结果来看，大大分担了我自己在架构方面的工作，在业务的保障上也达到了预期，证明了架构师机制的有效性。此外，在公共组件、技术中间件的引入和开发上，相比之前在速度和效果上都有提升。我自己这方面的工作主要集中于上半年。</p>

<p>此外，针对目前公司的技术Leader架构能力欠缺的问题，聘请了外部的技术顾问来做架构方面的培训。</p>

<h3>技术团队管理</h3>

<p>随着业务的增长，2019年公司的技术团队规模也在激增。2019年自己的重心是在技术团队的整体管理上。</p>

<p>首先，一直困扰我的是，做为公司的CTO，职责是什么？重点工作是什么？如果换成一个人来代替我，他会做什么？针对这个，我看了不少书，也问了不少朋友和前同事。最后基本上是扫清了自己的困惑，明确了自己的重点工作。可以分为四个部分：</p>

<ol>
<li>业务支撑：公司是一个产品驱动的公司，因此业务肯定是最重要的。保证业务的稳定性，支撑业务的快速迭代，这些都是重点工作。</li>
<li>工程效率提升：技术团队的规模增大，带来的并不一定是产出提高。必须有相应的配套研发流程、基础设施才能使得人员规模的增大带来整体产能的提高。今年组织技术Leader学习了《持续交付2.0》一书，并结合公司目前的实际情况，针对持续交付流水线进行了升级优化。也针对工程效率专门成立了“工程效率”小组，来识别研发流程的瓶颈，进行针对性优化。此外，今年也着重强调了全端工程化的问题，尤其全端监控体系的建设。</li>
<li>科技能力提升：和第一点有所关联。需要去识别公司业务发展上的一些技术瓶颈，做技术预研。</li>
<li>梯队建设：针对2018年的梯队现状，2019年定的招人基调是“资深带队、高级为主、中级可成长”，主要招聘高级开发，初中级招实习生培养。年底梳理了新的研发岗位职级要求，从最终的定级结果来看，研发梯队的层次基本达到了目标。此外，由于公司的很多技术Leader都是在公司成长起来的，缺乏成熟的管理经验，下半年举办了几次技术管理的培训课，以加强技术管理者对管理的认知和管理技能的掌握。</li>
</ol>


<p>此外，2019年公司强调了横向委员会的横向协同职能。年初正式确认了技术委员会的运行机制，并切实推行了起来。自己也加强了对各个技术方向的工作把控。</p>

<h2>学习</h2>

<p>2019年年初定了将近30本书的阅读计划，到年底完成了大约14本。</p>

<ul>
<li><p><a href="https://book.douban.com/subject/26760576/">清教徒的礼物</a></p>

<blockquote><p>同学推荐的一本管理书籍，主要是讲的美国的管理文化在世界各地的普及，尤其是日本和中国。阐述了清教徒（第一批欧洲移民，起源于英国，在北美殖民地得以实践与发展）的一些特质，也是美国能够打赢两次世界大战的原因，包括：建造“人间天国”的坚定信念；亲力亲为的技师精神；集体主义；组织能力：善于协调各种财力、物力和人力的组织能力。并且在书的最后给出了管理黄金时代优秀实务背后的25条原理。看完这本书，对于其中的一些东西很有共鸣，比如：自下而上的管理、专家（职业经理人）崇拜的危害等。</p></blockquote></li>
<li><p><a href="https://book.douban.com/subject/30419555/">持续交付2.0</a></p>

<blockquote><p>作者乔梁是《持续交付: 发布可靠软件的系统方法》的译者，同时也是此书作者在thoughtworks的同事，目前是腾讯等很多互联网公司的高级管理顾问。这本书称为2.0是在上述一书中加入了精益创业部分，形成双环模型。阐述了持续交付的概念以及具体到部署流水线各个环节的建立、优化等，涵盖了产品、研发、测试、运维等诸多方面。对于提高产研效率有非常大的帮助。</p></blockquote></li>
<li><p><a href="https://book.douban.com/subject/30333919/">架构简洁之道</a></p>

<blockquote><p>作者是鼎鼎大名的Uncle Bob，自己之前一直在看此书的英文原版。此书虽然讲的是传统单体软件架构的一些设计模式、原则等，但是本质上和现在的SOA、微服务是一样的。阐述了什么是架构、如何衡量架构、三大编程范式的本质、架构设计原则、组件原则等。并着重阐述了区别与传统的MVC分层架构的简洁架构是如何解决无法展现具体的业务领域、不能防止跨层调用等问题的。</p></blockquote></li>
<li><p><a href="https://book.douban.com/subject/30254993/">稻盛和夫哲学精要</a></p>

<blockquote><p>稻盛和夫是“盛和塾”（向企业家塾生义务传授经营哲学）的创始人，被称为日本经营之圣。他曾经创办过两家世界五百强企业，并曾经把日航从破产重建带到扭亏为盈。此书主要汇集了他的一些经营哲学。令我印象较深的有：小善大恶，大善小恶；仔细思考直到“看到结果”的状态；乐观构思，悲观计划，乐观实行；付出不亚于任何人的努力；现金与票据一一对应原则；时刻怀有谦卑之心；为别人的成就叫好。书的内容不多，就是一个小册子，时常翻阅能够不断有新的启发和认识。</p></blockquote></li>
<li><p><a href="https://book.douban.com/subject/6749832/">复杂</a></p>

<blockquote><p>什么是复杂科学？其中包括哪些知识。这本书就是对复杂科学的一些讲解。横跨生物、技术和社会学等领域，并探寻复杂系统的普遍规律，此外还探讨了复杂性与进化、人工智能、计算、遗传、信息处理等领域的关系。令我印象深刻的包括遗传算法的普遍形式、自相似分形的意义、冯诺依曼的冯诺依曼计算机体系以及元胞自动机、无尺度网络幂次定律。其中适用于互联网领域的幂次定律能够揭示不少东西。</p></blockquote></li>
<li><p><a href="https://book.douban.com/subject/26895988/">学习之道</a></p>

<blockquote><p>阐述了学习并且能够让学习到的东西成为自己知识的一些高效方法和思维模式。令我印象深刻的有发散思维的3B方法: Bus、Bed、Bath。即专注思维下容易陷入思维定式，这时候试着转换到这三种场景下，能够切换到发散思维，有时候会有意想不到的思路。</p></blockquote></li>
<li><p><a href="https://book.douban.com/subject/34812013/">中台战略：中台建设与数字商业</a>&amp;&amp;<a href="https://book.douban.com/subject/27039508/">企业IT架构转型之道</a>&amp;&amp;<a href="https://time.geekbang.org/column/intro/234">极客时间《说透中台》</a></p>

<blockquote><p>这三本书/课程放在一起，主要都是对中台这个2019年技术圈最流行的词的讲述，第一本是云栖科技基于这些年它们支撑过的企业中台建设经验沉淀出的方法论和实践，第二本则是阿里巴巴的共享业务中台的构建之路以及具体的实现策略，最后一个课程则是来源于thoughtworks的一些企业中台落地场景。综合对比其他各种博文、书籍来看，这三本书讲的比较符合我自己的理解。总体概括：中台是企业级能力复用平台，相比起平台，其更注重自助化、可配置、运营和业务；中台也不是银弹，并非所有企业都需要。对中台的概念以及中台的具体实施感兴趣的可以参考这三本书/课程。</p></blockquote></li>
<li><p><a href="https://book.douban.com/subject/27040502/">CTO说</a></p>

<blockquote><p>此书来自于51CTO举办的CTO训练营的讲师们的课程。通过阅读此书，进一步提升了我对CTO这个角色的认知，包括职责、需要做好的事情、需要具有的能力等。也从中得到了不少可以在公司落地的想法，包括如何更好的做绩效管理、如何建立优秀技术团队、建立自己的管理仪表盘来密切关注数据、把事故复盘会改成宕机培训学校、建立新晋技术管理者的管理模板等等。总体来看，非常值得新的CTO们一读。</p></blockquote></li>
<li><p><a href="https://book.douban.com/subject/26901342/">管理的常识</a></p>

<blockquote><p>作者是陈春花，既是企业管理教授也有企业高管经历，是国内管理大师级的人物，写了非常多的管理著作，其公众号“春暖花开”会经常分享她对管理的一些思考，非常值得订阅。《管理的常识》此书引用了其他经典管理书籍/理论阐述了管理理论中的一些常识，包括了管理、组织、组织结构、领导、激励、决策等。让自己印象深刻的包括：管理最终只以成就做为衡量标准；有效的管理就是帮助同事（上级和下属）发挥长处并避免用到他们的短处；职能部门是不能具有权利的；没有不好的士兵，只有不好的将军，需要针对不同员工选用不同的领导风格；群体决策并不是最好的决策方式，而是风险较小的决策方式。推荐企业管理者阅读此书。</p></blockquote></li>
<li><p><a href="https://book.douban.com/subject/26953606/">人类简史</a></p>

<blockquote><p>认知革命使人类成为想象的共同体，农业革命使人类陷入奢侈生活的陷阱，科技革命终将使人类成为神一样的存在。人类通过想象和虚构的能力将彼此连接、有效合作，国家、宗教、企业都是想象和虚构的现实，人类依靠这种想象来寻找认同、开展合作，由此一步步登上食物链的顶端，抵达其他生物无法企及的地位。这本书从智人的角度回顾并理清影响人类发展的重大脉络，视角很广。概括起来就是人类和其他动物本质没任何区别，甚至基因复杂度还不如一些动物，需要在大历史中重新审视人类自己。宗教那一部分佛教主张在痛苦的时候，去想问题的本质忽略感受就能让自己不痛苦，让自己有所启发。</p></blockquote></li>
<li><p><a href="https://book.douban.com/subject/33424487/">时间的秩序</a></p>

<blockquote><p>这本书主要讲述的是时间的本质，内容不多，但看完的感觉真是不明觉厉。包括：时间不是统一的，区别于海拔高度和速度，时间的快慢都不一样；微观世界不同于宏观世界，很多事情都反常识。感觉需要多看几遍才能不断有所理解。</p></blockquote></li>
<li><p><a href="https://book.douban.com/subject/26910621/">六项思考帽</a></p>

<blockquote><p>这本书讲的是一种简单高效的思考方式，只允许思考者同一时间做一件事情，学会将逻辑与情感、创造与信息区分开来。六项不同颜色的代表不同的思考方式，戴上某一项帽子，那么就要遵循当前的思考方式来思考问题，从而避免大家讨论问题时的各种冲突，以更好地引导集体智慧，从而解决问题，提高生产力。使用这种方法时，团队需要学会怎样把思考过程分为六个不同的方向。</p></blockquote></li>
</ul>


<p>以上是已经完成阅读的书籍，目前包括了2019年未完成以及新加入的待读书籍列表如下：</p>

<h3>工作</h3>

<ul>
<li>极客时间《研发效率破局之道》</li>
<li>持续交付: 发布可靠软件的系统方法</li>
<li>数据即未来</li>
</ul>


<h3>管理</h3>

<ul>
<li>我读管理经典</li>
<li>人月神话</li>
</ul>


<h3>技术</h3>

<ul>
<li>程序员的三门课</li>
<li>许世伟的架构课</li>
<li>未来架构</li>
<li>分布式系统概念与设计</li>
<li>分布式Java应用</li>
<li>大数据日知录</li>
<li>数据密集型系统设计</li>
</ul>


<h3>企业</h3>

<ul>
<li>公司进化论</li>
<li>闪电式扩张</li>
<li>创新者的窘境</li>
<li>良性增长</li>
<li>定位：有史以来对美国营销影响最大观念</li>
<li>刷新：重新发现商业与未来</li>
<li>超级版图：全球供应链、超级城市与新商业文明的崛起</li>
</ul>


<h3>其他</h3>

<ul>
<li>少有人走的路：每天十分钟，一学就会的心灵疗愈法</li>
<li>极简宇宙史</li>
</ul>


<p>需要额外说一下的是，这些书我以前倾向于看纸质书的，但2019年能够在微信读书APP上找到的基本都在上面看了。其中最大的好处就是当某个知识点记不太清楚的时候，很容易就可以搜索到，这个比纸质书籍方便太多了。但不好的就是缺少阅读纸质书的那种感觉，并且很多新书开始只有纸质版。</p>

<h2>生活</h2>

<p>生活上，上半年依然在坚持健身，下半年由于健身房的变动而停止。但是重新开启了篮球运动，基本上能够做到一周两个小时的运动量，自己也会隔几天在家里做俯卧撑、仰卧起坐等运动。整体状态上还算不错，但年底的体检还是一些小毛病，有点郁闷。so，开始从饮食方面来控制。最近感觉体重开始有所下降了。希望能坚持下去。</p>

<h2>总结</h2>

<p>以上就是2019年自己的总结。整体来看，是满意中夹杂着失望的。新的一年，自己的计划如下：</p>

<ul>
<li>加强自己的情绪管理，能够更理性地处理事情、解决问题。</li>
<li>继续弥补自身在业务和数据Sense、成本意识、商业谈判能力、产品管理能力这些方面能力的短板。</li>
<li>完成中台架构（组织和技术）在公司的落地或者不落地。</li>
<li>继续完善整个技术团队的顶层技术体系建设。</li>
<li>重点跟进企业效能提升工作，包括工程效率和内部IT系统建设。</li>
<li>全面优化技术成本，包括提高资源利用率、降低无效成本。</li>
<li>进一步探索并完善架构师机制，保证业务稳定性和技术先进性。</li>
<li>建立客户端架构组，统一把控客户端基础技术体系建设。</li>
<li>推进数据团队的融合，有效完成几个数据相关项目的开发和上线。</li>
<li>推进Devops平台的开发和上线。</li>
<li>完成2019年读书计划中剩下的书籍。</li>
<li>坚持锻炼，身体是最重要的。</li>
</ul>


<p>最后，最近武汉肺炎的事情正在愈演愈烈。大家务必注意自己和家人的安全，少出门，出门记得戴口罩。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《管理的常识》学习笔记]]></title>
    <link href="http://www.rowkey.me/blog/2019/12/20/manage-notes/"/>
    <updated>2019-12-20T11:29:34+00:00</updated>
    <id>http://www.rowkey.me/blog/2019/12/20/manage-notes</id>
    <content type="html"><![CDATA[<blockquote><p>作者是陈春花教授，既是企业管理教授也有企业高管经历，是国内管理大师级的人物，写了非常多的管理著作，其公众号“春暖花开”会经常分享她对管理的一些思考，非常值得订阅。《管理的常识》此书主要讲了管理理论中的一些常识，包括了管理的概念、组织、组织结构、领导、激励、决策等。让自己印象深刻的包括管理最终只以成就做为衡量标准；职能部门是不能具有权利的；群体决策并不是最好的决策方式，而是风险较小的决策方式。推荐企业管理者阅读此书。</p></blockquote>

<p>今年随着公司人员规模的不断扩大，自己越发意识到了管理的重要性。尤其对于技术管理者来说，程序员的思维和管理者的思维有很多地方是截然不同的，如果不做好认知的改变和思维的转变，很容易用惯性思维来做事，那么一个非常优秀的研发工程师很可能会成为一个非常不合格的管理者。所以，自己一直在寻找管理的书籍、课程来学习。其中，《管理的常识》这本书是极客邦TGO寄来的礼物，仔细阅读了一下，还是有不少启发的。</p>

<!--more-->


<p>先给出自己笔记的思维导图，如下：</p>

<p><a href="http://www.rowkey.me/post_images/manage-notes.png" target="_blank"><img src="http://www.rowkey.me/post_images/manage-notes.png"/></a></p>

<p>其中让自己印象比较深刻的几点：</p>

<ul>
<li>管理最终只以成就做为衡量标准，需要知行合一</li>
<li>职能部门不能具有权利，因为其并不直接与业务相关</li>
<li>群体决策并不是最好的决策方式，而是风险较小的决策方式。当品质比成员接受程度高时，独断式决策；当接受程度比品质重要时，群体决策（共识）；品质和接受程度都高时，咨询式决策；品质和成员接受程度都不高时，哪个方便选择哪个</li>
</ul>


<p>&ndash;</p>

<p>书籍链接：<a href="https://book.douban.com/subject/26901342/">https://book.douban.com/subject/26901342/</a></p>

<p><img src="http://www.rowkey.me/post_images/manage.png" width="300"/></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[技术琐话]]></title>
    <link href="http://www.rowkey.me/blog/2019/12/18/tech-talk/"/>
    <updated>2019-12-18T11:29:34+00:00</updated>
    <id>http://www.rowkey.me/blog/2019/12/18/tech-talk</id>
    <content type="html"><![CDATA[<p>日常的工作学习中，经常会看到好的知识点，对自己有提示的一句话，或者是自己突然想通了一件事情。这里以“技术琐话”作为主题来聚合：<a href="http://www.rowkey.me/blog/talks/">技术琐话</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[中台简谈]]></title>
    <link href="http://www.rowkey.me/blog/2019/11/23/middle-talk/"/>
    <updated>2019-11-23T11:29:34+00:00</updated>
    <id>http://www.rowkey.me/blog/2019/11/23/middle-talk</id>
    <content type="html"><![CDATA[<blockquote><p>面对新事物，先接纳，再判断。不要轻易就否定，即使经过自己的思考后确实没啥价值，这期间的思考过程也是一种知识梳理和思维锻炼。</p></blockquote>

<p>2019年技术圈最火的一个词非“中台”莫属了。联想到公司已经在持续做的平台化，其实会让人感到混乱。平台和中台有啥区别？有了中台，那么前台和后台又指的什么？本文是自己在调研中台概念中沉淀出来的一些思考。</p>

<!--more-->


<h2>中台是什么</h2>

<p>一种特殊形式的平台，抽象业务/系统的共性，支撑业务快速发展，是<strong>企业级共享能力平台</strong>。其核心在于对业务、数据、技术的抽象，对服务能力进行复用。解决重复开发、数据分散、试错成本高的问题。中台突出的是规划控制和协调的能力，前台强调的是创新和灵活多变。</p>

<ul>
<li>业务中台：多个前台业务应用共享的需求，关注如何支撑在线主营业务。一般来说业务中台由多个中心系统组成。</li>
<li>数据中台: 专用的数据处理平台，用技术连接大数据计算存储能力，用业务连接数据应用场景能力的平台。</li>
<li>技术中台：整合和包装了云基础设施以及在其上的各种技术中间件，并在此基础上建设和封装了简单易用的能力接口，提供了基础设施重用的能力。</li>
<li>研发中台：关注应用研发效率的管理平台，为应用的开发提供了流程、质量管控和持续交付的能力。</li>
<li>移动中台：平台级的移动端开发支持</li>
<li>AI中台：数据中台之上，模型的训练、发布，智能服务的构建自动化，统一的元数据管理体系，模型的全生命周期管理。</li>
<li>组织中台：与中台技术架构相匹配的组织架构</li>
</ul>


<p>众多的可复用能力只是中台的形，<strong>核心的业务数据和业务流程</strong>才是中台存在的本质。</p>

<h2>为什么要有中台</h2>

<p><strong>传统的烟囱式架构面临的问题</strong></p>

<ul>
<li>重复性建设对人力物力的浪费</li>
<li>系统间交互的集成和协作成本昂贵</li>
<li>不利于业务沉淀和持续发展</li>
</ul>


<p><strong>共享服务带来的优势</strong></p>

<ul>
<li>提高研发效能，赋予业务快速创新和试错能力</li>
<li>打通数据，真正发挥大数据的威力，共享数据价值</li>
<li>中台组织结构提升组织效能</li>
</ul>


<h2>怎么实现中台战略</h2>

<h3>思路的改变</h3>

<ul>
<li>提升自己的研发效率->提升别人的研发效率</li>
<li>从代码->需求，到代码->组件->需求，到代码->组件->可配置->需求</li>
<li>业务逻辑和平台逻辑分离，业务逻辑和业务逻辑隔离</li>
<li>集中配置，分布式运行</li>
</ul>


<h3>总体架构</h3>

<p><img src="http://www.rowkey.me/post_images/middle-office-arch.png" alt="" /></p>

<h3>建设思路</h3>

<ol>
<li><p>中台化改造</p>

<blockquote><p>对已有平台的中台化改造</p></blockquote>

<ul>
<li>平台不断对于自身治理演进、打破技术边界、逐渐拥抱业务、容纳业务、具备更强的业务属性的过程。</li>
<li>通过业务抽象以及可配置化和白屏化（给平台产品做一个配置界面实现自助式服务，没有UI要求，一般是一个白页面加一些配置项）的改造升级</li>
<li>技术平台->技术中台：对于技术平台的治理、安全、可用性和自助式的产品化包装，打造自助服务平台，关注业务的用户使用体验，让业务可以更快速更方便体验更好的使用企业内部的技术能力</li>
</ul>
</li>
<li><p>中台化：利用平台化的思维和手段梳理、识别、沉淀与复用企业级核心能力的过程。根据业务演进逐渐积累而成，<strong>分阶段逐步实施</strong>。多于一个前台业务需要某一种能力，那么此能力即可沉淀为中台能力。切忌大而全的建设中台。</p>

<ul>
<li><strong>资源集中管理->能力抽象->灵活性</strong></li>
<li><strong>共享服务：普通的服务能力->组件化服务，并提供良好的服务治理支持</strong>

<ul>
<li>找到一个合适的服务化对象：API as service，存量API升级成服务化平台的组件服务</li>
<li>建设对象服务化的基础设施：Product as Service，封装API服务</li>
<li>服务化实施阶段: Solution as Service</li>
<li>增强服务和基础设施实现服务的精细治理</li>
</ul>
</li>
</ul>
</li>
<li><p>运营</p>

<ul>
<li>运营前置：制定迭代计划及接入计划。中台产品推广、前台（用户）接入计划以及接入后的运营支持</li>
<li>根据用户分层制定SLA：不同的需求响应机制、不同的沟通管理机制、不同的服务质量控制机制、不同的问题处理及升级机制</li>
</ul>
</li>
<li><p>演进</p>

<ul>
<li>各种中台的逐渐建设</li>
<li>共享服务中心的不断增加</li>
</ul>
</li>
</ol>


<h3>建设要点</h3>

<ul>
<li>在“工具”与“完全为业务服务”之间寻找平衡点，既需要满足业务的需求，又不能过度参与业务。</li>
<li>重视中台的运营、持续治理以及演进</li>
<li>拆分整体应用形成业务组件：抽象程度越高，中台对业务的适配度越高。</li>
<li>可配置，自助白屏化</li>
<li>足够灵活的扩展点，支持定制化扩展</li>
<li>服务文档化</li>
<li>开放体系：对内对外</li>
</ul>


<h2>参考资料</h2>

<ul>
<li>《中台战略》</li>
<li>《企业IT架构转型之道》</li>
<li>极客时间《说透中台》</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何进行有效的技术分享（演讲）]]></title>
    <link href="http://www.rowkey.me/blog/2019/10/23/how-to-tech-share/"/>
    <updated>2019-10-23T11:29:34+00:00</updated>
    <id>http://www.rowkey.me/blog/2019/10/23/how-to-tech-share</id>
    <content type="html"><![CDATA[<p>讲述如何准备一次技术分享（演讲）以及演讲中的注意事项。来自内部分享PPT，后续会发布<strong>详细版</strong>。</p>

<!--more-->


<h2>What-什么是有效的技术分享</h2>

<ul>
<li>演讲

<ul>
<li>知识/技能培训</li>
<li>组件/平台/系统使用培训</li>
<li>工作实践经验/教训</li>
</ul>
</li>
<li>写博客？</li>
</ul>


<p><strong>有效->满足听众的诉求</strong></p>

<h2>Why-存在的问题</h2>

<ul>
<li>语速太快</li>
<li>图解太少</li>
<li>缺乏实践案例</li>
<li>内容太多</li>
<li>内容都在ppt上</li>
</ul>


<h2>How-如何准备技术分享</h2>

<h3>目的</h3>

<ul>
<li>开阔眼界</li>
<li>培训</li>
<li>讨论</li>
</ul>


<p><strong>听众的组成；听众对领域的了解程度；听众的诉求</strong></p>

<h3>结构</h3>

<ul>
<li>Who</li>
<li>What</li>
<li>Why</li>
<li>How：重点选3、4点</li>
<li>Future</li>
<li>Recap</li>
</ul>


<h3>内容</h3>

<ul>
<li><strong>backlog</strong>: 收集、积累信息</li>
<li><strong>逐字稿</strong></li>
<li><strong>形式</strong>：

<ul>
<li>报告：精确的信息和枯燥的细节、事实和图表</li>
<li>故事：具体；强调说服和感染；<strong>赋比兴</strong></li>
<li>演讲：介于报告和故事之间</li>
</ul>
</li>
<li><strong>实践案例</strong>、经验 > 说教

<pre><code>  - Situation: 当时的情况
  - Target: 面临的任务/目标
  - Action: 采取的行动
  - Results: 取得的结果
</code></pre></li>
<li>内容量适可而止</li>
<li><strong>Demo</strong>: 关键特点、容错处理</li>
</ul>


<h3>PPT</h3>

<blockquote><p>烘托效果和提醒，<strong>配角</strong></p></blockquote>

<ul>
<li>How的几个重点，每一个点2-3页，共15-20页</li>
<li>精简文字+图表，多图少字</li>
<li><strong>简洁、干净、一致、跳脱</strong></li>
<li><strong>忌</strong>：交互式幻灯片、大片文字</li>
</ul>


<h3>练习</h3>

<hr />

<blockquote><p>多练出奇迹</p></blockquote>

<ul>
<li>自我练习</li>
<li>让别人听：公司/团队内部试讲</li>
<li>冥想：站在听众的角度去接受信息</li>
</ul>


<p><strong>根据反馈不断进行迭代改进</strong></p>

<h2>分享Tips</h2>

<ul>
<li>紧张

<ul>
<li>觉察：“只要不被听众察觉到紧张，那就不是紧张”。</li>
<li>充分准备</li>
<li>内容量适可而止</li>
<li>简洁PPT：留有自由发挥余地</li>
<li>练习</li>
</ul>
</li>
<li>节奏

<ul>
<li>语速放缓</li>
<li>多准备点内容：演讲时间固定的情况下讲不完比冷场要好</li>
<li>规划要点、时间</li>
</ul>
</li>
<li>目光：面对听众并熟视无睹；巡视听众</li>
<li>语调：有感情；抑扬顿挫</li>
<li>手势：忌手足无措</li>
<li>演讲设备/PPT的备份</li>
</ul>

]]></content>
  </entry>
  
</feed>
