<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: architecture | 后端技术杂谈 | 飒然Hang]]></title>
  <link href="http://www.rowkey.me/blog/categories/architecture/atom.xml" rel="self"/>
  <link href="http://www.rowkey.me/"/>
  <updated>2018-02-07T16:53:47+08:00</updated>
  <id>http://www.rowkey.me/</id>
  <author>
    <name><![CDATA[飒然Hang]]></name>
    <email><![CDATA[superhj1987@126.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[如何快速尝出毒酒？- 用bit解决问题]]></title>
    <link href="http://www.rowkey.me/blog/2018/01/04/king-rec-pois-wine/"/>
    <updated>2018-01-04T19:29:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2018/01/04/king-rec-pois-wine</id>
    <content type="html"><![CDATA[<h2>问题</h2>

<p>国王有一百桶酒，比自己的生命还重要。结果有一天其中一桶被投了慢性毒药，喝了以后半个小时以后就会死掉。国王大怒，命令玩忽职守的侍卫去试毒。酒不能被混合，一个侍卫可以喝多桶酒，一桶酒也可以由多个侍卫喝，怎么样才能用最少的侍卫、在最短的时间知道哪桶是毒酒。侍卫可以理解为线程，即怎么样用最少的线程用最快的速度完成这个工作。</p>

<!--more-->


<h2>方案</h2>

<p>此问题是我在面试时经常用的一道题目，主要考察的是候选人能不能以计算机的思维考虑问题。</p>

<p>最简单的方案肯定是找100个人，每个人试一桶酒，那么用时30分钟，就可以判断出哪一桶就有毒。</p>

<p>再进一步的，可以使用分段法，把酒分成n份，先找n个侍卫试酒，可以定位出哪一段的酒有毒，再接着分段试酒。但这种方案，分段数目越少，试出毒酒的平均耗时就越长。</p>

<p>如果用计算机的思维来分析这个问题，那么首先考虑如何存储这100桶酒。100桶酒可以用二进制7个bit来表示（2<sup>7</sup>>100）。对应那一桶毒酒，其二进制表示中为1的位置如果能够可以定位出来，就可以定位出此桶毒酒。可以找7个侍卫编号1-7。对于每一桶酒的二进制表示（不足七位前面用0表示），从第一位到第七位，如果是1，则对应编号的侍卫喝此桶酒。这样，每个侍卫喝掉对应的酒。30分钟后，侍卫按照编号1-7，死掉的置为1，活着的置为0，如此，侍卫的一个序列如0000111就表示第七桶酒为毒酒。</p>

<h2>总结</h2>

<p>上述最后一种方案提现了在计算机中使用bit来解决问题的思路。当需要节省存储的时候，使用bit来做经常会有出其不易的效果。就比如最近很火的电影《天才枪手》中，主角们记忆选择题的答案A、B、C、D，完全可以使用位编码来表示四种答案:00-A 01-B 10-C 11-D，四个bit转换为一个十六进制数字，如此就可以节省一半的存储，记忆起来也会简单很多。此外，我们处理大数据去重/计数使用的Bitmap、BloomFilter，也都是一种使用bit节省存储的思路。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何实现延时触发/定时器]]></title>
    <link href="http://www.rowkey.me/blog/2017/12/28/delay-trigger/"/>
    <updated>2017-12-28T19:29:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2017/12/28/delay-trigger</id>
    <content type="html"><![CDATA[<h2>问题</h2>

<p>微信公众平台后台有一个功能即定时群发消息，如明晚的20:00群发一条图文消息。那么这种延时触发的逻辑如何实现呢？</p>

<!--more-->


<h2>方案一</h2>

<p><strong>每隔一定的时间扫描所有超时的事件</strong></p>

<p>这是最容易想到的一种方案。此方案最关键的两点是轮训的频率以及如何高效地获取超时任务。</p>

<ul>
<li>如果可以允许一秒左右的误差，每隔一秒轮训一次即可。</li>
<li>采用红黑树或者最小堆存储触发任务，按照触发时间戳排序。如此，每次扫描能够很快地获取超时的任务。实践中，一个很简单的方案就是使用Redis的SortedSet存储触发任务，这样只需要使用zrangeByScore获取超时的任务，再使用zremrangeByScore即可删除已经触发的任务。</li>
</ul>


<p>此种方案的缺点在于即使频率到达一秒，也可能会有一秒的误差。此外，轮训的方式在很多情况下并没有可触发的任务，会浪费资源。</p>

<h2>方案二</h2>

<p><strong>阻塞线程等待时间超时</strong></p>

<p>此方案思路来自于Nginx中定时器的实现（和Java中的DelayQueue原理类似）。任务的存储和上面的方案类似，采用最小堆或者红黑树即可。然后选择最近要被触发的任务的时间距离作为阻塞调用epoll_wait的超时（也可以使用其他可以设置超时的阻塞调用）。阻塞超时后，依次获取最小触发时间戳的任务，超时则执行。</p>

<p>此种方案的最大优点在于不会有空的任务检查周期。</p>

<h2>方案三</h2>

<p><strong>采用环形队列</strong></p>

<p>此方案详细可以见58沈剑的文章<a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651959961&amp;idx=1&amp;sn=afec02c8dc6db9445ce40821b5336736&amp;chksm=bd2d07458a5a8e5314560620c240b1c4cf3bbf801fc0ab524bd5e8aa8b8ef036cf755d7eb0f6">《1分钟实现“延迟消息”功能》</a>。大体的思路如下：</p>

<p>采用环形队列，3600个slot，每隔1秒扫描一个slot，检查当前slot里面的所有任务，检查其cycleNum是否为0, 为0则触发，否则cycleNum-1。添加定时事件时，根据扫描指针的当前slot的index和事件触发的时间，计算cycleNum和要放入的slot。</p>

<p>此种方案的本质是<strong>栅格化与预计算</strong>，相比起前两种方案，大大提升了每次获取可触发任务的效率。但同样存在每次查询任务有可能做无用功的问题。此外，需要特别处理添加任务和扫描任务的临界点的问题，否则也可能会有时间上的误差。</p>

<p><strong>PS: 这个方案原理是和时间轮(Netty中的HashedWheelTimer)一样的，多谢@imangry提示</strong></p>

<h2>方案四</h2>

<p><strong>延时消息队列</strong></p>

<p>目前，RabbitMQ、RocketMQ都支持延时消息队列，直接使用即可。但这种依赖消息队列的方案，如果要取消定时任务，则无法实现。其中，RabbitMQ的实现思路是基于TTL的，详细可见：<a href="http://www.cnblogs.com/haoxinyue/p/6613706.html">http://www.cnblogs.com/haoxinyue/p/6613706.html</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[谈谈架构]]></title>
    <link href="http://www.rowkey.me/blog/2017/08/24/arch/"/>
    <updated>2017-08-24T19:29:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2017/08/24/arch</id>
    <content type="html"><![CDATA[<p>之前开头的《架构设计原则》一文一直没有把坑填上。而最近在公司内部做了一次架构交流/培训，把架构的概念、架构的形式、架构设计原则都做了阐述，正好算是对此文的完成和补充。</p>

<p><a href="http://www.rowkey.me/arch-ppt/index.html" target="_blank">PPT观看</a></p>

<!--more-->


<p><img src="//images/blog_images/arch/arch-2.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-3.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-4.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-5.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-6.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-7.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-8.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-9.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-10.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-11.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-12.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-13.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-14.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-15.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-16.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-17.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-18.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-19.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-20.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-21.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-22.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-23.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-24.jpeg" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一些架构设计原则]]></title>
    <link href="http://www.rowkey.me/blog/2017/01/15/arch-spec/"/>
    <updated>2017-01-15T22:21:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2017/01/15/arch-spec</id>
    <content type="html"><![CDATA[<p><img src="//images/blog_images/arch-spec.png" alt="" /></p>

<p>详细见：<a href="http://www.rowkey.me/blog/2017/08/24/arch/">谈谈架构</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[谈谈系统架构这个东西]]></title>
    <link href="http://www.rowkey.me/blog/2014/06/04/sys-arch/"/>
    <updated>2014-06-04T21:29:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2014/06/04/sys-arch</id>
    <content type="html"><![CDATA[<p>架构这个词在很多人看来都是很高大上的一个东西。事实上，搞架构的这些人却也都是些大神，至少都是在这个领域浸淫N久的专家级人物。现在很火的全栈工程师这个概念，就是架构师的另一种表现形式。</p>

<p>之于架构，其含义无非是从技术细节跳出来自上而下宏观地看待系统的一个思维，就好比建筑设计一样。架构师的角色和建筑设计师在某种意义上是相同的。在微博上看到蔡学镛分享过这么一个架构设计流程的图，从中或多或少能看出架构设计一个大概的流程。</p>

<p><img src="//images/blog_images/arch-1.jpg" alt="arch-1" /></p>

<p>首当其冲的，肯定是需要对整个系统的业务进行拆分，进行业务设计，目的就是要捋清楚系统是干什么的，能提供什么功能，对系统的需求要做到详尽的分析和考虑。不过这部分，在我参与过的一些项目看来，尤其是对现在普遍使用的敏捷开发流程来说，无需考虑的太面面俱到，但至少不能太窄或者偏离正轨，后续的开发过程会不断的反馈回来进行调整。</p>

<p>接下来，系统的业务明确之后，交互设计和领域建模便可以同时执行。当然，这里我是觉得交互设计和架构师是没啥关系的，顶多就是两者要相辅相成。而领域建模这个就显得很重要了。领域建模是业务设计的主要逻辑，把现实中的业务转化成抽象的对象，这个确实是能力的体现了。我觉得这一部分很多出色的架构师相比其他人突出的一个很关键的地方。</p>

<p>技术模块设计则是在理解了系统的业务需求之后，对整体的一个技术框架上的设计。这里对于技术架构，我一直有一个分不太清楚的东西，就是软件架构和系统架构。说到底，这两者都是软件层面的含义，所不同的是前者到了代码层面，而系统架构则是到了软件层面。软件架构是位于系统架构之上的。一个系统，使用了Spring、Hibernater然后用了MVC设计模式，这就是软件架构；一个系统分成负载均衡模块、Link模块、队列模块、数据模块、推送模块等等则就是系统架构。再往下就应该是部署架构了，比如系统部署了几个结点、结点之间的关系、网络的规划结构、系统的高可用、可扩展等等。当然对于一个系统来说，数据的设计是可以拿出来重点进行的，毕竟对于互联网应用来说，数据 is all，系统的很多性能、效率问题是和数据的存储设计有密切关系的。</p>

<p>到最后，业务之上的这些设计会反作用于业务，将系统的关键点反馈回来，从而对业务进行调整，进而再推进整个架构的流程。现在很火的敏捷开发，某种角度看来就是一个不断迭代、反馈的过程，是传统架构设计的一种演化形式。</p>

<p>谈到架构，那么如何才能具有架构能力呢？借鉴在知乎上看到一个回答：</p>

<ul>
<li>视野开阔，知道可以直接用哪个开源项目来满足这样那样的需求。多数时候其实我们并不需要重复造轮子。视野窄的架构师会放着捷径不走，不断让团队重复造轮子，直至把项目拖死。</li>
<li>精通设计模式，但又不泛用。不设计过度，不在各种细节问题上需求蔓延。所有架构设计都是为了满足产品需求的，不满足需求或者过度设计都是菜鸟行为。</li>
<li>把系统拆分成多个子系统或模块，模块之间尽量松耦合，使得原先只能串行的开发任务，可以并行开展，也就是说良好的设计可以通过投入更多人力来缩短工期。反之拙劣的设计需要一个人维护一大坨代码，无法通过加人并行开发来缩短工期。</li>
<li>能清楚地知道系统的瓶颈在什么地方，不断地定位技术难度、研发进度、性能、内存等各方面的瓶颈，不断调整骨干力量解决瓶颈，在风险爆发之前就消除隐患。</li>
<li>行业经验带来的直觉和预见性，可以预先需求可能产生怎样的变化，提前把可扩展性、后向兼容性设计好。但仍然不要过度设计</li>
</ul>


<p>以上对架构的一些理解，很多地方自认还是有点迷糊。在进行系统设计的时候，也经常摸不着头脑，把不同层次的东西混为一谈。记得蔡学镛大神之前还分享过一张图片，对架构讲的挺透彻的。不明白的时候看看这个，会有种茅塞顿开的感觉。</p>

<p><img src="//images/blog_images/arch-2.jpg" alt="arch-2" /></p>
]]></content>
  </entry>
  
</feed>
