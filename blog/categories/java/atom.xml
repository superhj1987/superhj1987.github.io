<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: java | 后端技术杂谈 | 飒然Hang]]></title>
  <link href="http://www.rowkey.me/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://www.rowkey.me/"/>
  <updated>2017-09-11T18:24:01+08:00</updated>
  <id>http://www.rowkey.me/</id>
  <author>
    <name><![CDATA[飒然Hang]]></name>
    <email><![CDATA[superhj1987@126.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[每周一译]Java中的十个"单行代码编程"(One Liner)]]></title>
    <link href="http://www.rowkey.me/blog/2017/09/09/java-oneliners/"/>
    <updated>2017-09-09T19:29:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2017/09/09/java-oneliners</id>
    <content type="html"><![CDATA[<p>本文列举了十个使用一行代码即可独立完成(不依赖其他代码)的业务逻辑，主要依赖的是Java8中的Lambda和Stream等新特性以及try-with-resources、JAXB等。</p>

<!--more-->


<ol>
<li><p>对列表/数组中的每个元素都乘以2</p>

<pre><code class="`"> // Range是半开区间
 int[] ia = range(1, 10).map(i -&gt; i * 2).toArray();
 List&lt;Integer&gt; result = range(1, 10).map(i -&gt; i * 2).boxed().collect(toList());
</code></pre></li>
<li><p>计算集合/数组中的数字之和</p>

<pre><code class="`"> range(1, 1000).sum();
 range(1, 1000).reduce(0, Integer::sum);
 Stream.iterate(0, i -&gt; i + 1).limit(1000).reduce(0, Integer::sum);
 IntStream.iterate(0, i -&gt; i + 1).limit(1000).reduce(0, Integer::sum);
</code></pre></li>
<li><p>验证字符串是否包含集合中的某一字符串</p>

<pre><code class="`">final List&lt;String&gt; keywords = Arrays.asList("brown", "fox", "dog", "pangram");
final String tweet = "The quick brown fox jumps over a lazy dog. #pangram http://www.rinkworks.com/words/pangrams.shtml";

keywords.stream().anyMatch(tweet::contains);
keywords.stream().reduce(false, (b, keyword) -&gt; b || tweet.contains(keyword), (l, r) -&gt; l || r);
</code></pre></li>
<li><p>读取文件内容</p>

<blockquote><p>原作者认为try with resources也是一种单行代码编程。</p></blockquote>

<pre><code class="`"> try (BufferedReader reader = new BufferedReader(new FileReader("data.txt"))) {
   String fileText = reader.lines().reduce("", String::concat);
 }

 try (BufferedReader reader = new BufferedReader(new FileReader("data.txt"))) {
   List&lt;String&gt; fileLines = reader.lines().collect(toCollection(LinkedList&lt;String&gt;::new));
 }

 try (Stream&lt;String&gt; lines = Files.lines(new File("data.txt").toPath(), Charset.defaultCharset())) {
   List&lt;String&gt; fileLines = lines.collect(toCollection(LinkedList&lt;String&gt;::new));
 }
</code></pre></li>
<li><p>输出歌曲《Happy Birthday to You!》 - 根据集合中不同的元素输出不同的字符串</p>

<pre><code class="`"> range(1, 5).boxed().map(i -&gt; { out.print("Happy Birthday "); if (i == 3) return "dear NAME"; else return "to You"; }).forEach(out::println);
</code></pre></li>
<li><p>过滤并分组集合中的数字</p>

<pre><code class="`"> Map&lt;String, List&lt;Integer&gt;&gt; result = Stream.of(49, 58, 76, 82, 88, 90).collect(groupingBy(forPredicate(i -&gt; i &gt; 60, "passed", "failed")));
</code></pre></li>
<li><p>获取并解析xml协议的Web Service</p>

<pre><code class="`">FeedType feed = JAXB.unmarshal(new URL("http://search.twitter.com/search.atom?&amp;q=java8"), FeedType.class);
JAXB.marshal(feed, System.out);
</code></pre></li>
<li><p>获得集合中最小/最大的数字</p>

<pre><code class="`"> int min = Stream.of(14, 35, -7, 46, 98).reduce(Integer::min).get();
 min = Stream.of(14, 35, -7, 46, 98).min(Integer::compare).get();
 min = Stream.of(14, 35, -7, 46, 98).mapToInt(Integer::new).min();

 int max = Stream.of(14, 35, -7, 46, 98).reduce(Integer::max).get();
 max = Stream.of(14, 35, -7, 46, 98).max(Integer::compare).get();
 max = Stream.of(14, 35, -7, 46, 98).mapToInt(Integer::new).max();
</code></pre></li>
<li><p>并行处理</p>

<pre><code class="`"> long result = dataList.parallelStream().mapToInt(line -&gt; processItem(line)).sum();
</code></pre></li>
<li><p>集合上的各种查询(LINQ in Java)</p>

<pre><code>List&lt;Album&gt; albums = Arrays.asList(unapologetic, tailgates, red);

//筛选出至少有一个track评级4分以上的专辑，并按照名称排序后打印出来。
albums.stream()
  .filter(a -&gt; a.tracks.stream().anyMatch(t -&gt; (t.rating &gt;= 4)))
  .sorted(comparing(album -&gt; album.name))
  .forEach(album -&gt; System.out.println(album.name));

//合并所有专辑的track
List&lt;Track&gt; allTracks = albums.stream()
  .flatMap(album -&gt; album.tracks.stream())
  .collect(toList());

//根据track的评分对所有track分组
Map&lt;Integer, List&lt;Track&gt;&gt; tracksByRating = allTracks.stream()
  .collect(groupingBy(Track::getRating));
</code></pre></li>
</ol>


<p>原文: <a href="https://github.com/aruld/java-oneliners/wiki">https://github.com/aruld/java-oneliners/wiki</a></p>

<hr />

<p><strong><em>补充 by 飒然Hang</em></strong>: 上述的<strong>单行代码编程</strong>确实能够减少代码的字符数，也经常能够给人以高大上的感觉，但是在Java编程中字符其实是非常廉价的，尤其是现在诸如Intellij等IDE已经具有自动补充/生成代码、重构等智能化功能。如果仅仅是为了减少字符的数量，那么没必要刻意去追求<strong>单行代码编程</strong>。让你的代码易于阅读才是最关键的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[每周一译]更好地使用Java8中的方法引用]]></title>
    <link href="http://www.rowkey.me/blog/2017/09/02/java8-method-reference-work/"/>
    <updated>2017-09-02T19:29:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2017/09/02/java8-method-reference-work</id>
    <content type="html"><![CDATA[<p>在Java8中，使用方法引用非常简单，如String::isEmpty，但无法使用它否定的方法引用。本文内容即如何解决此问题使得我们能够更加全面地使用方法引用。</p>

<!--more-->


<p>首先看一个使用方法引用的例子：</p>

<pre><code>Stream.of("A", "", "B").filter(String::isEmpty).count()
</code></pre>

<p>上面代码的输出为1，即空字符串的数目。如果我们想要获取非空字符串的数目，就不能直接使用方法引用了。</p>

<pre><code>Stream.of("A", "", "B").filter(s -&gt; !s.isEmpty()).count()
</code></pre>

<p>Java8中的Predicate，有predicate.negate()可以转换为断言的否定形式，但String::isEmpty却无法这么做(String::isEmpty.negate()或者!String::isEmpty)。因为方法引用并不是一个lambda或者函数接口，它能够被解析为一个或者多个函数接口。如，String::isEmpty至少可以被解析如下：</p>

<ul>
<li><code>Predicate&lt;String&gt;</code></li>
<li><code>Function&lt;String, Boolean&gt;</code></li>
</ul>


<p>为了解决上述的问题，我们可以通过某种机制显式地将方法引用转换为一个函数接口：</p>

<pre><code>public static &lt;T&gt; Predicate&lt;T&gt; as(Predicate&lt;T&gt; predicate) {
    return predicate;
}
</code></pre>

<p>通过使用一个静态方法，接受方法引用参数，返回一个函数接口，即可实现方法引用到函数接口的转换。接着，我们就可以使用方法引用来实现上面例子中的获取非空字符串的数目。</p>

<pre><code>Stream.of("A", "", "B").filter(as(String::isEmpty).negate()).count();
</code></pre>

<p>进一步还能使用各种组合的Predicate。</p>

<pre><code>.filter(as(String::isEmpty).negate().and("A"::equals))
</code></pre>

<p>由于一个方法引用可能会被解析为多种函数接口，因此如果我们实现很多参数不同的as方法，那么很容易造成混淆。更好的方式则是在方法名中加入函数参数的类型来区分。</p>

<pre><code>import java.util.function.*;

public class FunctionCastUtil {
    public static &lt;T, U&gt; BiConsumer&lt;T, U&gt; asBiConsumer(BiConsumer&lt;T, U&gt; biConsumer) {
        return biConsumer;
    }
    public static &lt;T, U, R&gt; BiFunction&lt;T, U, R&gt; asBiFunction(BiFunction&lt;T, U, R&gt; biFunction) {
        return biFunction;
    }
    public static &lt;T&gt; BinaryOperator&lt;T&gt; asBinaryOperator(BinaryOperator&lt;T&gt; binaryOperator) {
        return binaryOperator;
    }
    public static &lt;T, U&gt; BiPredicate&lt;T, U&gt; asBiPredicate(BiPredicate&lt;T, U&gt; biPredicate) {
        return biPredicate;
    }
    public static BooleanSupplier asBooleanSupplier(BooleanSupplier booleanSupplier) {
        return booleanSupplier;
    }
    public static &lt;T&gt; Consumer&lt;T&gt; asConsumer(Consumer&lt;T&gt; consumer) {
        return consumer;
    }
    public static DoubleBinaryOperator asDoubleBinaryOperator(DoubleBinaryOperator doubleBinaryOperator) {
        return doubleBinaryOperator;
    }
    public static DoubleConsumer asDoubleConsumer(DoubleConsumer doubleConsumer) {
        return doubleConsumer;
    }
    public static &lt;R&gt; DoubleFunction&lt;R&gt; asDoubleFunction(DoubleFunction&lt;R&gt; doubleFunction) {
        return doubleFunction;
    }
    public static DoublePredicate asDoublePredicate(DoublePredicate doublePredicate) {
        return doublePredicate;
    }
    public static DoubleToIntFunction asDoubleToIntFunction(DoubleToIntFunction doubleToIntFunctiontem) {
        return doubleToIntFunctiontem;
    }
    public static DoubleToLongFunction asDoubleToLongFunction(DoubleToLongFunction doubleToLongFunction) {
        return doubleToLongFunction;
    }
    public static DoubleUnaryOperator asDoubleUnaryOperator(DoubleUnaryOperator doubleUnaryOperator) {
        return doubleUnaryOperator;
    }
    public static &lt;T, R&gt; Function&lt;T, R&gt; asFunction(Function&lt;T, R&gt; function) {
        return function;
    }
    public static IntBinaryOperator asIntBinaryOperator(IntBinaryOperator intBinaryOperator) {
        return intBinaryOperator;
    }
    public static IntConsumer asIntConsumer(IntConsumer intConsumer) {
        return intConsumer;
    }
    public static &lt;R&gt; IntFunction&lt;R&gt; asIntFunction(IntFunction&lt;R&gt; intFunction) {
        return intFunction;
    }
    public static IntPredicate asIntPredicate(IntPredicate intPredicate) {
        return intPredicate;
    }
    public static IntSupplier asIntSupplier(IntSupplier intSupplier) {
        return intSupplier;
    }
    public static IntToDoubleFunction asIntToDoubleFunction(IntToDoubleFunction intToDoubleFunction) {
        return intToDoubleFunction;
    }
    public static IntToLongFunction asIntToLongFunction(IntToLongFunction intToLongFunction) {
        return intToLongFunction;
    }
    public static IntUnaryOperator asIntUnaryOperator(IntUnaryOperator intUnaryOperator) {
        return intUnaryOperator;
    }
    public static LongBinaryOperator asLongBinaryOperator(LongBinaryOperator longBinaryOperator) {
        return longBinaryOperator;
    }
    public static LongConsumer asLongConsumer(LongConsumer longConsumer) {
        return longConsumer;
    }
    public static &lt;R&gt; LongFunction&lt;R&gt; asLongFunction(LongFunction&lt;R&gt; longFunction) {
        return longFunction;
    }
    public static LongPredicate asLongPredicate(LongPredicate longPredicate) {
        return longPredicate;
    }
    public static &lt;T&gt; LongSupplier asLongSupplier(LongSupplier longSupplier) {
        return longSupplier;
    }
    public static LongToDoubleFunction asLongToDoubleFunction(LongToDoubleFunction longToDoubleFunction) {
        return longToDoubleFunction;
    }
    public static LongToIntFunction asLongToIntFunction(LongToIntFunction longToIntFunction) {
        return longToIntFunction;
    }
    public static LongUnaryOperator asLongUnaryOperator(LongUnaryOperator longUnaryOperator) {
        return longUnaryOperator;
    }
    public static &lt;T&gt; ObjDoubleConsumer&lt;T&gt; asObjDoubleConsumer(ObjDoubleConsumer&lt;T&gt; objDoubleConsumer) {
        return objDoubleConsumer;
    }
    public static &lt;T&gt; ObjIntConsumer&lt;T&gt; asObjIntConsumer(ObjIntConsumer&lt;T&gt; objIntConsumer) {
        return objIntConsumer;
    }
    public static &lt;T&gt; ObjLongConsumer&lt;T&gt; asObjLongConsumer(ObjLongConsumer&lt;T&gt; objLongConsumer) {
        return objLongConsumer;
    }
    public static &lt;T&gt; Predicate&lt;T&gt; asPredicate(Predicate&lt;T&gt; predicate) {
        return predicate;
    }
    public static &lt;T&gt; Supplier&lt;T&gt; asSupplier(Supplier&lt;T&gt; supplier) {
        return supplier;
    }
    public static &lt;T, U&gt; ToDoubleBiFunction&lt;T, U&gt; asToDoubleBiFunction(ToDoubleBiFunction&lt;T, U&gt; toDoubleBiFunction) {
        return toDoubleBiFunction;
    }
    public static &lt;T&gt; ToDoubleFunction&lt;T&gt; asToDoubleFunction(ToDoubleFunction&lt;T&gt; toDoubleFunction) {
        return toDoubleFunction;
    }
    public static &lt;T, U&gt; ToIntBiFunction&lt;T, U&gt; asToIntBiFunction(ToIntBiFunction&lt;T, U&gt; toIntBiFunction) {
        return toIntBiFunction;
    }
    public static &lt;T&gt; ToIntFunction&lt;T&gt; asToIntFunction(ToIntFunction&lt;T&gt; ioIntFunction) {
        return ioIntFunction;
    }
    public static &lt;T, U&gt; ToLongBiFunction&lt;T, U&gt; asToLongBiFunction(ToLongBiFunction&lt;T, U&gt; toLongBiFunction) {
        return toLongBiFunction;
    }
    public static &lt;T&gt; ToLongFunction&lt;T&gt; asToLongFunction(ToLongFunction&lt;T&gt; toLongFunction) {
        return toLongFunction;
    }
    public static &lt;T&gt; UnaryOperator&lt;T&gt; asUnaryOperator(UnaryOperator&lt;T&gt; unaryOperator) {
        return unaryOperator;
    }
    private FunctionCastUtil() {
    }
}

Stream.of("A", "", "B").filter(asPredicate(String::isEmpty).negate()).count();
</code></pre>

<p>英文原文：<a href="https://dzone.com/articles/put-your-java-8-method-references-to-work">https://dzone.com/articles/put-your-java-8-method-references-to-work</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[谈谈架构]]></title>
    <link href="http://www.rowkey.me/blog/2017/08/24/arch/"/>
    <updated>2017-08-24T19:29:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2017/08/24/arch</id>
    <content type="html"><![CDATA[<p>之前开头的《架构设计原则》一文一直没有把坑填上。而最近在公司内部做了一次架构交流/培训，把架构的概念、架构的形式、架构设计原则都做了阐述，正好算是对此文的完成和补充。</p>

<p><a href="http://www.rowkey.me/arch-ppt/index.html" target="_blank">PPT观看</a></p>

<!--more-->


<p><img src="//images/blog_images/arch/arch-2.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-3.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-4.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-5.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-6.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-7.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-8.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-9.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-10.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-11.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-12.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-13.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-14.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-15.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-16.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-17.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-18.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-19.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-20.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-21.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-22.jpeg" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[每周一译]在Java中提升函数以更好地“函数式”编程]]></title>
    <link href="http://www.rowkey.me/blog/2017/08/18/lift-functions/"/>
    <updated>2017-08-18T19:29:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2017/08/18/lift-functions</id>
    <content type="html"><![CDATA[<p>Java8中的Stream和Optional给我们带来了函数式编程的乐趣，但Java仍然缺少很多函数编程的关键特性。Lambda表达式、Optional和Stream只是函数式编程的冰山一角。这也导致了<a href="https://github.com/vavr-io/vavr">varvr</a>和<a href="https://github.com/functionaljava/functionaljava">functionlajava</a>这些类库的出现，他们都源于Haskell这个纯函数式编程语言。</p>

<p>如果想要更加地“函数式”编程，那么首先要注意的是不要过早的中断monad(一种设计模式，表示将一个运算过程通过函数拆解成互相连接的多个步骤。只要提供下一步运算所需的函数，整个运算就会自动进行下去, Optional、Stream都是monad)，比如，很多人经常会在还不需要的时候就调用了Optional.get()和Stream.collect()提前终止monad。本文主要讲述如何通过提升方法来使得代码更&#8221;函数式&#8221;。</p>

<!--more-->


<p>假设有一个接口可以对数字进行计算。</p>

<pre><code>public interface Math {
    int multiply(int a, int b);
    double divide(int a, int b);
    ..
}
</code></pre>

<p>我们要使用这个接口来对使用Optional做包装的数字做计算。</p>

<pre><code>public interface NumberProvider {
    Optional&lt;Integer&gt; getNumber();
}
</code></pre>

<p>接着我们来实现一个方法能够返回两个数字相除的结果，结果用Optional包装。如果这两个数字有一个为空则返回空Optional。如下：</p>

<pre><code>public Optional&lt;Double&gt; divideFirstTwo(NumberProvider numberProvider, Math math) {
    Optional&lt;Integer&gt; first = numberProvider.getNumber();
    Optional&lt;Integer&gt; second = numberProvider.getNumber();
    if(first.isPresent() &amp;&amp; second.isPresent()) {
        double result = math.divide(first.get(), second.get());
        return Optional.of(result);
    } else {
        return Optional.empty();
    }
}
</code></pre>

<p>上面的代码非常不优雅，有大量的代码都是在做Optional的包装和解包装。可以让上面的代码变得更加“函数式”，如下：</p>

<pre><code>public Optional&lt;Double&gt; divideFirstTwo(NumberProvider numberProvider, Math math) {
    return numberProvider.getNumber()
           .flatMap(first -&gt; numberProvider.getNumber()
                                     .map(second -&gt; math.divide(first, second)));
}
</code></pre>

<p>这样代码少了很多，也优雅了很多。先调用第一个Optional的flatMap，再在lambda中调用第二个Optional的map，进一步可以抽取出一个提升方法：</p>

<pre><code>public interface Optionals {
    static &lt;R, T, Z&gt; BiFunction&lt;Optional&lt;T&gt;, Optional&lt;R&gt;, Optional&lt;Z&gt;&gt; lift(BiFunction&lt;? super T, ? super R, ? extends Z&gt; function) {
        return (left, right) -&gt; left.flatMap(leftVal -&gt; right.map(rightVal -&gt; function.apply(leftVal, rightVal)));
    }
}
</code></pre>

<p>如上，可知这个方法提升能够提升任何具有两个Optional参数、一个Optional结果的函数，使得被提升的函数具有Optional的一个特性：如果一个参数是空的，那么结果就是空的。如果JDK抽取flatMap和map到一个公共接口，如Monad，那么我们可以为Java Monad的每一个实例(Stream、Optional、自己的实现类)实现一个公共的提升函数。但现实是我们不得不为每一个实例都复制粘贴上面的代码。最终的divideFirstTwo代码如下：</p>

<pre><code>import static com.ps.functional.monad.optional.Optionals.lift;
...
public Optional&lt;Double&gt; divideFirstTwo(NumberProvider numberProvider, Math math) {
    return lift(math::divide).apply(numberProvider.getNumber(), numberProvider.getNumber());
}
</code></pre>

<p><strong>ps: 此文内容来自<a href="https://dzone.com/articles/lifting-functions-to-work-with-monads-in-java?edition=311409&amp;edition=0&amp;utm_source=Zone%20Newsletter&amp;utm_medium=email&amp;utm_campaign=java%202017-08-01">https://dzone.com/articles/lifting-functions-to-work-with-monads-in-java?edition=311409&amp;edition=0&amp;utm_source=Zone%20Newsletter&amp;utm_medium=email&amp;utm_campaign=java%202017-08-01</a>，加入了本人的理解和认知。</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《Java工程师修炼之道》内容概览]]></title>
    <link href="http://www.rowkey.me/blog/2017/08/10/pragmatic-java-engineer/"/>
    <updated>2017-08-10T19:29:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2017/08/10/pragmatic-java-engineer</id>
    <content type="html"><![CDATA[<p>最近几个月由于工作和正在筹备《Java工程师修炼之道》一书的原因一直没有写新的文章。不过，忙里偷闲，自己陆续读完了《格鲁夫给经理人的第一课》、《架构真经》、《聊聊架构》这几本书，收获了不少干货，之前自己挖坑的《一些架构设计原则》一文后面会尽快填上。本文则先介绍一下《Java工程师修炼之道》一书^_^。</p>

<p>《Java工程师修炼之道》一书主要内容是Java后端工程师必备的基本技能大纲。内容主要来自于公司内的后端工程师学习计划、自己以前的一些博客文章和自己从业以来积累的知识库。但由于后端工程师的每一个技能点都具有一定的深度，都不是一两篇文章就能讲述清楚的，因此本书不可能对每一个技能点都讲的特别透彻。</p>

<p>本书可以看做是一本Java工程师的入职指南，也可以看做一本串联Java后端技能点的参考手册。对其中每一个技能点的学习，推荐通过他们的官方文档来深入学习，此外，本书也给出了自己觉得有价值的参考学习书籍。</p>

<!--more-->


<p>初步的目录如下：</p>

<ul>
<li><p>第一章 后端技术导言</p>

<ul>
<li>1.1 后端基础设施</li>
<li>1.2 Java后端技术概览</li>
<li>1.3 如何学习后端技术</li>
</ul>
</li>
<li><p>第二章 Java项目工程化</p>

<ul>
<li>2.1 项目构建</li>
<li>2.2 代码版本协作</li>
<li>2.3 代码质量</li>
</ul>
</li>
<li><p>第三章 开发框架</p>

<ul>
<li>3.1 依赖注入</li>
<li>3.2 对象关系映射</li>
<li>3.3 日志</li>
<li>3.4 Web MVC</li>
</ul>
</li>
<li><p>第四章 Spring</p>

<ul>
<li>4.1 Spring Core</li>
<li>4.2 数据操作</li>
<li>4.3 Spring Boot</li>
<li>4.4 常用组件</li>
<li>4.5 总结</li>
</ul>
</li>
<li><p>第五章 数据存储</p>

<ul>
<li>5.1 关系型数据库</li>
<li>5.2 NoSQL数据库</li>
<li>5.3 缓存</li>
<li>5.4 搜索引擎</li>
</ul>
</li>
<li><p>第六章 数据通信</p>

<ul>
<li>6.1 RESTful</li>
<li>6.2 RPC</li>
<li>6.3 消息队列</li>
</ul>
</li>
<li><p>第七章 Java编程进阶</p>

<ul>
<li>7.1 Java内存管理</li>
<li>7.2 Java网络编程</li>
<li>7.3 Java并发编程</li>
<li>7.4 Java开发武器</li>
<li>7.5 New Java</li>
<li>7.6 总结</li>
</ul>
</li>
<li><p>第八章 性能调优</p>

<ul>
<li>8.1 调优准备</li>
<li>8.2 性能分析</li>
<li>8.3 性能调优</li>
</ul>
</li>
<li><p>第九章 安全技术</p>

<ul>
<li>9.1 Java加密</li>
<li>9.2 HTTPS</li>
<li>9.3 Web安全</li>
</ul>
</li>
</ul>


<p>其中的部分内容，会在此书正式出版后陆续放出。</p>

<p><strong>希望这本书会给想要学习Java后端开发的同学或者还未形成自己技术体系的Java工程师们带来帮助。</strong></p>

<p>题外的，再给我们的新产品打一个广告。</p>

<p>哔哔是一个对话式故事阅读app，对话式故事也叫话本，一个故事就类似于微信的一段对话，形式如下：</p>

<p><img src="//images/blog_images/bibi.png" alt="" /></p>

<p>区别于其他阅读类app，我们还重视社交关系的维护以及故事的直播。</p>

<p><img src="//images/blog_images/bibi-live.png" alt="" /></p>

<p>此外，我们已经吸引了大量优秀故事创作者在我们平台上贡献内容。故事类型丰富多样，故事内容千奇百怪。爱讲段子的段子手能够在这里凭借自己段子的魅力俘获万千粉丝，获得打赏；爱看故事的童鞋也可以在这里追随各种故事达人，看他们直播讲故事/段子，给自己喜欢的作者送礼物。</p>

<p>扫码下载：</p>

<p><img src="//images/blog_images/bibi-url.png" alt="" /></p>
]]></content>
  </entry>
  
</feed>
